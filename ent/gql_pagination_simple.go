// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"strconv"

	"github.com/99designs/gqlgen/graphql"
)

var simplePaginationKey = "github.com/woocoos/entco/pkg/ent.SimplePaginzation"

type SimplePagination struct {
	CurrentIndex int
	PageIndex    int
}

// NewSimplePagination creates a new SimplePagination from the given page and count. If both are empty, it returns nil.
func NewSimplePagination(p, c string) (*SimplePagination, error) {
	if p == "" && c == "" {
		return nil, nil
	}
	sp := &SimplePagination{}
	if p != "" {
		i, err := strconv.Atoi(p)
		if err != nil {
			return nil, err
		}
		sp.PageIndex = i
	}
	if c != "" {
		i, err := strconv.Atoi(c)
		if err != nil {
			return nil, err
		}
		sp.CurrentIndex = i
	}
	return sp, nil
}

func (a *AppQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AppPaginateOption,
) (*AppConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAppPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AppConnection{Edges: []*AppEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	a = pager.applyOrder(a)
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			a.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			a.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (aa *AppActionQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AppActionPaginateOption,
) (*AppActionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAppActionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if aa, err = pager.applyFilter(aa); err != nil {
		return nil, err
	}
	conn := &AppActionConnection{Edges: []*AppActionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = aa.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if aa, err = pager.applyCursors(aa, after, before); err != nil {
		return nil, err
	}
	aa = pager.applyOrder(aa)
	if limit := paginateLimit(first, last); limit != 0 {
		aa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := aa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			aa.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			aa.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := aa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (am *AppMenuQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AppMenuPaginateOption,
) (*AppMenuConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAppMenuPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if am, err = pager.applyFilter(am); err != nil {
		return nil, err
	}
	conn := &AppMenuConnection{Edges: []*AppMenuEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = am.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if am, err = pager.applyCursors(am, after, before); err != nil {
		return nil, err
	}
	am = pager.applyOrder(am)
	if limit := paginateLimit(first, last); limit != 0 {
		am.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := am.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			am.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			am.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := am.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (ap *AppPolicyQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AppPolicyPaginateOption,
) (*AppPolicyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAppPolicyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ap, err = pager.applyFilter(ap); err != nil {
		return nil, err
	}
	conn := &AppPolicyConnection{Edges: []*AppPolicyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ap.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if ap, err = pager.applyCursors(ap, after, before); err != nil {
		return nil, err
	}
	ap = pager.applyOrder(ap)
	if limit := paginateLimit(first, last); limit != 0 {
		ap.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ap.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			ap.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			ap.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := ap.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (ar *AppResQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AppResPaginateOption,
) (*AppResConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAppResPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ar, err = pager.applyFilter(ar); err != nil {
		return nil, err
	}
	conn := &AppResConnection{Edges: []*AppResEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ar.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if ar, err = pager.applyCursors(ar, after, before); err != nil {
		return nil, err
	}
	ar = pager.applyOrder(ar)
	if limit := paginateLimit(first, last); limit != 0 {
		ar.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ar.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			ar.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			ar.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := ar.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (ar *AppRoleQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AppRolePaginateOption,
) (*AppRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAppRolePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ar, err = pager.applyFilter(ar); err != nil {
		return nil, err
	}
	conn := &AppRoleConnection{Edges: []*AppRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ar.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if ar, err = pager.applyCursors(ar, after, before); err != nil {
		return nil, err
	}
	ar = pager.applyOrder(ar)
	if limit := paginateLimit(first, last); limit != 0 {
		ar.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ar.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			ar.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			ar.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := ar.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (o *OrgQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgPaginateOption,
) (*OrgConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &OrgConnection{Edges: []*OrgEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = o.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if o, err = pager.applyCursors(o, after, before); err != nil {
		return nil, err
	}
	o = pager.applyOrder(o)
	if limit := paginateLimit(first, last); limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			o.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			o.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (op *OrgPolicyQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgPolicyPaginateOption,
) (*OrgPolicyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgPolicyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if op, err = pager.applyFilter(op); err != nil {
		return nil, err
	}
	conn := &OrgPolicyConnection{Edges: []*OrgPolicyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = op.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if op, err = pager.applyCursors(op, after, before); err != nil {
		return nil, err
	}
	op = pager.applyOrder(op)
	if limit := paginateLimit(first, last); limit != 0 {
		op.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := op.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			op.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			op.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := op.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (or *OrgRoleQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgRolePaginateOption,
) (*OrgRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgRolePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if or, err = pager.applyFilter(or); err != nil {
		return nil, err
	}
	conn := &OrgRoleConnection{Edges: []*OrgRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = or.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if or, err = pager.applyCursors(or, after, before); err != nil {
		return nil, err
	}
	or = pager.applyOrder(or)
	if limit := paginateLimit(first, last); limit != 0 {
		or.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := or.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			or.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			or.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := or.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (pe *PermissionQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PermissionPaginateOption,
) (*PermissionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPermissionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pe, err = pager.applyFilter(pe); err != nil {
		return nil, err
	}
	conn := &PermissionConnection{Edges: []*PermissionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pe.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if pe, err = pager.applyCursors(pe, after, before); err != nil {
		return nil, err
	}
	pe = pager.applyOrder(pe)
	if limit := paginateLimit(first, last); limit != 0 {
		pe.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pe.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			pe.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			pe.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := pe.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (u *UserQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	u = pager.applyOrder(u)
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			u.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			u.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (ud *UserDeviceQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserDevicePaginateOption,
) (*UserDeviceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserDevicePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ud, err = pager.applyFilter(ud); err != nil {
		return nil, err
	}
	conn := &UserDeviceConnection{Edges: []*UserDeviceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ud.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if ud, err = pager.applyCursors(ud, after, before); err != nil {
		return nil, err
	}
	ud = pager.applyOrder(ud)
	if limit := paginateLimit(first, last); limit != 0 {
		ud.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ud.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			ud.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			ud.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := ud.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (ui *UserIdentityQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserIdentityPaginateOption,
) (*UserIdentityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserIdentityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ui, err = pager.applyFilter(ui); err != nil {
		return nil, err
	}
	conn := &UserIdentityConnection{Edges: []*UserIdentityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ui.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if ui, err = pager.applyCursors(ui, after, before); err != nil {
		return nil, err
	}
	ui = pager.applyOrder(ui)
	if limit := paginateLimit(first, last); limit != 0 {
		ui.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ui.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			ui.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			ui.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := ui.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (ulp *UserLoginProfileQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserLoginProfilePaginateOption,
) (*UserLoginProfileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserLoginProfilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ulp, err = pager.applyFilter(ulp); err != nil {
		return nil, err
	}
	conn := &UserLoginProfileConnection{Edges: []*UserLoginProfileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ulp.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if ulp, err = pager.applyCursors(ulp, after, before); err != nil {
		return nil, err
	}
	ulp = pager.applyOrder(ulp)
	if limit := paginateLimit(first, last); limit != 0 {
		ulp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ulp.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			ulp.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			ulp.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := ulp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
func (up *UserPasswordQuery) SimplePaginate(
	ctx context.Context, sp *SimplePagination, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPasswordPaginateOption,
) (*UserPasswordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPasswordPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if up, err = pager.applyFilter(up); err != nil {
		return nil, err
	}
	conn := &UserPasswordConnection{Edges: []*UserPasswordEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = up.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	if up, err = pager.applyCursors(up, after, before); err != nil {
		return nil, err
	}
	up = pager.applyOrder(up)
	if limit := paginateLimit(first, last); limit != 0 {
		up.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := up.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	if sp != nil {
		if first != nil {
			up.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			up.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	nodes, err := up.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}
