// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/woocoos/entco/schemax/typex"
	"github.com/woocoos/knockout/ent/app"
	"github.com/woocoos/knockout/ent/appaction"
	"github.com/woocoos/knockout/ent/appmenu"
	"github.com/woocoos/knockout/ent/apppolicy"
	"github.com/woocoos/knockout/ent/appres"
	"github.com/woocoos/knockout/ent/approle"
	"github.com/woocoos/knockout/ent/approlepolicy"
	"github.com/woocoos/knockout/ent/organization"
	"github.com/woocoos/knockout/ent/organizationapp"
	"github.com/woocoos/knockout/ent/organizationpolicy"
	"github.com/woocoos/knockout/ent/organizationrole"
	"github.com/woocoos/knockout/ent/organizationuser"
	"github.com/woocoos/knockout/ent/permission"
	"github.com/woocoos/knockout/ent/predicate"
	"github.com/woocoos/knockout/ent/user"
	"github.com/woocoos/knockout/ent/userdevice"
	"github.com/woocoos/knockout/ent/useridentity"
	"github.com/woocoos/knockout/ent/userloginprofile"
	"github.com/woocoos/knockout/ent/userpassword"
	"github.com/woocoos/knockout/graph/entgen/types"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp                = "App"
	TypeAppAction          = "AppAction"
	TypeAppMenu            = "AppMenu"
	TypeAppPolicy          = "AppPolicy"
	TypeAppRes             = "AppRes"
	TypeAppRole            = "AppRole"
	TypeAppRolePolicy      = "AppRolePolicy"
	TypeOrganization       = "Organization"
	TypeOrganizationApp    = "OrganizationApp"
	TypeOrganizationPolicy = "OrganizationPolicy"
	TypeOrganizationRole   = "OrganizationRole"
	TypeOrganizationUser   = "OrganizationUser"
	TypePermission         = "Permission"
	TypeUser               = "User"
	TypeUserDevice         = "UserDevice"
	TypeUserIdentity       = "UserIdentity"
	TypeUserLoginProfile   = "UserLoginProfile"
	TypeUserPassword       = "UserPassword"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_by                *int
	addcreated_by             *int
	created_at                *time.Time
	updated_by                *int
	addupdated_by             *int
	updated_at                *time.Time
	name                      *string
	code                      *string
	kind                      *app.Kind
	redirect_uri              *string
	app_key                   *string
	app_secret                *string
	scopes                    *string
	token_validity            *int32
	addtoken_validity         *int32
	refresh_token_validity    *int32
	addrefresh_token_validity *int32
	logo                      *string
	comments                  *string
	status                    *typex.SimpleStatus
	clearedFields             map[string]struct{}
	menus                     map[int]struct{}
	removedmenus              map[int]struct{}
	clearedmenus              bool
	actions                   map[int]struct{}
	removedactions            map[int]struct{}
	clearedactions            bool
	resources                 map[int]struct{}
	removedresources          map[int]struct{}
	clearedresources          bool
	roles                     map[int]struct{}
	removedroles              map[int]struct{}
	clearedroles              bool
	policies                  map[int]struct{}
	removedpolicies           map[int]struct{}
	clearedpolicies           bool
	organizations             map[int]struct{}
	removedorganizations      map[int]struct{}
	clearedorganizations      bool
	done                      bool
	oldValue                  func(context.Context) (*App, error)
	predicates                []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id int) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[app.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[app.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, app.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[app.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[app.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, app.FieldUpdatedAt)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *AppMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AppMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *AppMutation) ResetCode() {
	m.code = nil
}

// SetKind sets the "kind" field.
func (m *AppMutation) SetKind(a app.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AppMutation) Kind() (r app.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldKind(ctx context.Context) (v app.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AppMutation) ResetKind() {
	m.kind = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *AppMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *AppMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ClearRedirectURI clears the value of the "redirect_uri" field.
func (m *AppMutation) ClearRedirectURI() {
	m.redirect_uri = nil
	m.clearedFields[app.FieldRedirectURI] = struct{}{}
}

// RedirectURICleared returns if the "redirect_uri" field was cleared in this mutation.
func (m *AppMutation) RedirectURICleared() bool {
	_, ok := m.clearedFields[app.FieldRedirectURI]
	return ok
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *AppMutation) ResetRedirectURI() {
	m.redirect_uri = nil
	delete(m.clearedFields, app.FieldRedirectURI)
}

// SetAppKey sets the "app_key" field.
func (m *AppMutation) SetAppKey(s string) {
	m.app_key = &s
}

// AppKey returns the value of the "app_key" field in the mutation.
func (m *AppMutation) AppKey() (r string, exists bool) {
	v := m.app_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAppKey returns the old "app_key" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAppKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppKey: %w", err)
	}
	return oldValue.AppKey, nil
}

// ClearAppKey clears the value of the "app_key" field.
func (m *AppMutation) ClearAppKey() {
	m.app_key = nil
	m.clearedFields[app.FieldAppKey] = struct{}{}
}

// AppKeyCleared returns if the "app_key" field was cleared in this mutation.
func (m *AppMutation) AppKeyCleared() bool {
	_, ok := m.clearedFields[app.FieldAppKey]
	return ok
}

// ResetAppKey resets all changes to the "app_key" field.
func (m *AppMutation) ResetAppKey() {
	m.app_key = nil
	delete(m.clearedFields, app.FieldAppKey)
}

// SetAppSecret sets the "app_secret" field.
func (m *AppMutation) SetAppSecret(s string) {
	m.app_secret = &s
}

// AppSecret returns the value of the "app_secret" field in the mutation.
func (m *AppMutation) AppSecret() (r string, exists bool) {
	v := m.app_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSecret returns the old "app_secret" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAppSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSecret: %w", err)
	}
	return oldValue.AppSecret, nil
}

// ClearAppSecret clears the value of the "app_secret" field.
func (m *AppMutation) ClearAppSecret() {
	m.app_secret = nil
	m.clearedFields[app.FieldAppSecret] = struct{}{}
}

// AppSecretCleared returns if the "app_secret" field was cleared in this mutation.
func (m *AppMutation) AppSecretCleared() bool {
	_, ok := m.clearedFields[app.FieldAppSecret]
	return ok
}

// ResetAppSecret resets all changes to the "app_secret" field.
func (m *AppMutation) ResetAppSecret() {
	m.app_secret = nil
	delete(m.clearedFields, app.FieldAppSecret)
}

// SetScopes sets the "scopes" field.
func (m *AppMutation) SetScopes(s string) {
	m.scopes = &s
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *AppMutation) Scopes() (r string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// ClearScopes clears the value of the "scopes" field.
func (m *AppMutation) ClearScopes() {
	m.scopes = nil
	m.clearedFields[app.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *AppMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[app.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *AppMutation) ResetScopes() {
	m.scopes = nil
	delete(m.clearedFields, app.FieldScopes)
}

// SetTokenValidity sets the "token_validity" field.
func (m *AppMutation) SetTokenValidity(i int32) {
	m.token_validity = &i
	m.addtoken_validity = nil
}

// TokenValidity returns the value of the "token_validity" field in the mutation.
func (m *AppMutation) TokenValidity() (r int32, exists bool) {
	v := m.token_validity
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenValidity returns the old "token_validity" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldTokenValidity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenValidity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenValidity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenValidity: %w", err)
	}
	return oldValue.TokenValidity, nil
}

// AddTokenValidity adds i to the "token_validity" field.
func (m *AppMutation) AddTokenValidity(i int32) {
	if m.addtoken_validity != nil {
		*m.addtoken_validity += i
	} else {
		m.addtoken_validity = &i
	}
}

// AddedTokenValidity returns the value that was added to the "token_validity" field in this mutation.
func (m *AppMutation) AddedTokenValidity() (r int32, exists bool) {
	v := m.addtoken_validity
	if v == nil {
		return
	}
	return *v, true
}

// ClearTokenValidity clears the value of the "token_validity" field.
func (m *AppMutation) ClearTokenValidity() {
	m.token_validity = nil
	m.addtoken_validity = nil
	m.clearedFields[app.FieldTokenValidity] = struct{}{}
}

// TokenValidityCleared returns if the "token_validity" field was cleared in this mutation.
func (m *AppMutation) TokenValidityCleared() bool {
	_, ok := m.clearedFields[app.FieldTokenValidity]
	return ok
}

// ResetTokenValidity resets all changes to the "token_validity" field.
func (m *AppMutation) ResetTokenValidity() {
	m.token_validity = nil
	m.addtoken_validity = nil
	delete(m.clearedFields, app.FieldTokenValidity)
}

// SetRefreshTokenValidity sets the "refresh_token_validity" field.
func (m *AppMutation) SetRefreshTokenValidity(i int32) {
	m.refresh_token_validity = &i
	m.addrefresh_token_validity = nil
}

// RefreshTokenValidity returns the value of the "refresh_token_validity" field in the mutation.
func (m *AppMutation) RefreshTokenValidity() (r int32, exists bool) {
	v := m.refresh_token_validity
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenValidity returns the old "refresh_token_validity" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRefreshTokenValidity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenValidity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenValidity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenValidity: %w", err)
	}
	return oldValue.RefreshTokenValidity, nil
}

// AddRefreshTokenValidity adds i to the "refresh_token_validity" field.
func (m *AppMutation) AddRefreshTokenValidity(i int32) {
	if m.addrefresh_token_validity != nil {
		*m.addrefresh_token_validity += i
	} else {
		m.addrefresh_token_validity = &i
	}
}

// AddedRefreshTokenValidity returns the value that was added to the "refresh_token_validity" field in this mutation.
func (m *AppMutation) AddedRefreshTokenValidity() (r int32, exists bool) {
	v := m.addrefresh_token_validity
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefreshTokenValidity clears the value of the "refresh_token_validity" field.
func (m *AppMutation) ClearRefreshTokenValidity() {
	m.refresh_token_validity = nil
	m.addrefresh_token_validity = nil
	m.clearedFields[app.FieldRefreshTokenValidity] = struct{}{}
}

// RefreshTokenValidityCleared returns if the "refresh_token_validity" field was cleared in this mutation.
func (m *AppMutation) RefreshTokenValidityCleared() bool {
	_, ok := m.clearedFields[app.FieldRefreshTokenValidity]
	return ok
}

// ResetRefreshTokenValidity resets all changes to the "refresh_token_validity" field.
func (m *AppMutation) ResetRefreshTokenValidity() {
	m.refresh_token_validity = nil
	m.addrefresh_token_validity = nil
	delete(m.clearedFields, app.FieldRefreshTokenValidity)
}

// SetLogo sets the "logo" field.
func (m *AppMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *AppMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *AppMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[app.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *AppMutation) LogoCleared() bool {
	_, ok := m.clearedFields[app.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *AppMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, app.FieldLogo)
}

// SetComments sets the "comments" field.
func (m *AppMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[app.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[app.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, app.FieldComments)
}

// SetStatus sets the "status" field.
func (m *AppMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *AppMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *AppMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[app.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AppMutation) StatusCleared() bool {
	_, ok := m.clearedFields[app.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AppMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, app.FieldStatus)
}

// AddMenuIDs adds the "menus" edge to the AppMenu entity by ids.
func (m *AppMutation) AddMenuIDs(ids ...int) {
	if m.menus == nil {
		m.menus = make(map[int]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the AppMenu entity.
func (m *AppMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the AppMenu entity was cleared.
func (m *AppMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the AppMenu entity by IDs.
func (m *AppMutation) RemoveMenuIDs(ids ...int) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the AppMenu entity.
func (m *AppMutation) RemovedMenusIDs() (ids []int) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *AppMutation) MenusIDs() (ids []int) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *AppMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddActionIDs adds the "actions" edge to the AppAction entity by ids.
func (m *AppMutation) AddActionIDs(ids ...int) {
	if m.actions == nil {
		m.actions = make(map[int]struct{})
	}
	for i := range ids {
		m.actions[ids[i]] = struct{}{}
	}
}

// ClearActions clears the "actions" edge to the AppAction entity.
func (m *AppMutation) ClearActions() {
	m.clearedactions = true
}

// ActionsCleared reports if the "actions" edge to the AppAction entity was cleared.
func (m *AppMutation) ActionsCleared() bool {
	return m.clearedactions
}

// RemoveActionIDs removes the "actions" edge to the AppAction entity by IDs.
func (m *AppMutation) RemoveActionIDs(ids ...int) {
	if m.removedactions == nil {
		m.removedactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.actions, ids[i])
		m.removedactions[ids[i]] = struct{}{}
	}
}

// RemovedActions returns the removed IDs of the "actions" edge to the AppAction entity.
func (m *AppMutation) RemovedActionsIDs() (ids []int) {
	for id := range m.removedactions {
		ids = append(ids, id)
	}
	return
}

// ActionsIDs returns the "actions" edge IDs in the mutation.
func (m *AppMutation) ActionsIDs() (ids []int) {
	for id := range m.actions {
		ids = append(ids, id)
	}
	return
}

// ResetActions resets all changes to the "actions" edge.
func (m *AppMutation) ResetActions() {
	m.actions = nil
	m.clearedactions = false
	m.removedactions = nil
}

// AddResourceIDs adds the "resources" edge to the AppRes entity by ids.
func (m *AppMutation) AddResourceIDs(ids ...int) {
	if m.resources == nil {
		m.resources = make(map[int]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the AppRes entity.
func (m *AppMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the AppRes entity was cleared.
func (m *AppMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the AppRes entity by IDs.
func (m *AppMutation) RemoveResourceIDs(ids ...int) {
	if m.removedresources == nil {
		m.removedresources = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the AppRes entity.
func (m *AppMutation) RemovedResourcesIDs() (ids []int) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *AppMutation) ResourcesIDs() (ids []int) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *AppMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddRoleIDs adds the "roles" edge to the AppRole entity by ids.
func (m *AppMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the AppRole entity.
func (m *AppMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AppRole entity was cleared.
func (m *AppMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the AppRole entity by IDs.
func (m *AppMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the AppRole entity.
func (m *AppMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AppMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AppMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddPolicyIDs adds the "policies" edge to the AppPolicy entity by ids.
func (m *AppMutation) AddPolicyIDs(ids ...int) {
	if m.policies == nil {
		m.policies = make(map[int]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the "policies" edge to the AppPolicy entity.
func (m *AppMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared reports if the "policies" edge to the AppPolicy entity was cleared.
func (m *AppMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the "policies" edge to the AppPolicy entity by IDs.
func (m *AppMutation) RemovePolicyIDs(ids ...int) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.policies, ids[i])
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed IDs of the "policies" edge to the AppPolicy entity.
func (m *AppMutation) RemovedPoliciesIDs() (ids []int) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the "policies" edge IDs in the mutation.
func (m *AppMutation) PoliciesIDs() (ids []int) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies resets all changes to the "policies" edge.
func (m *AppMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *AppMutation) AddOrganizationIDs(ids ...int) {
	if m.organizations == nil {
		m.organizations = make(map[int]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *AppMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *AppMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *AppMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *AppMutation) RemovedOrganizationsIDs() (ids []int) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *AppMutation) OrganizationsIDs() (ids []int) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *AppMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, app.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.code != nil {
		fields = append(fields, app.FieldCode)
	}
	if m.kind != nil {
		fields = append(fields, app.FieldKind)
	}
	if m.redirect_uri != nil {
		fields = append(fields, app.FieldRedirectURI)
	}
	if m.app_key != nil {
		fields = append(fields, app.FieldAppKey)
	}
	if m.app_secret != nil {
		fields = append(fields, app.FieldAppSecret)
	}
	if m.scopes != nil {
		fields = append(fields, app.FieldScopes)
	}
	if m.token_validity != nil {
		fields = append(fields, app.FieldTokenValidity)
	}
	if m.refresh_token_validity != nil {
		fields = append(fields, app.FieldRefreshTokenValidity)
	}
	if m.logo != nil {
		fields = append(fields, app.FieldLogo)
	}
	if m.comments != nil {
		fields = append(fields, app.FieldComments)
	}
	if m.status != nil {
		fields = append(fields, app.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedBy:
		return m.CreatedBy()
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedBy:
		return m.UpdatedBy()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldName:
		return m.Name()
	case app.FieldCode:
		return m.Code()
	case app.FieldKind:
		return m.Kind()
	case app.FieldRedirectURI:
		return m.RedirectURI()
	case app.FieldAppKey:
		return m.AppKey()
	case app.FieldAppSecret:
		return m.AppSecret()
	case app.FieldScopes:
		return m.Scopes()
	case app.FieldTokenValidity:
		return m.TokenValidity()
	case app.FieldRefreshTokenValidity:
		return m.RefreshTokenValidity()
	case app.FieldLogo:
		return m.Logo()
	case app.FieldComments:
		return m.Comments()
	case app.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldCode:
		return m.OldCode(ctx)
	case app.FieldKind:
		return m.OldKind(ctx)
	case app.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case app.FieldAppKey:
		return m.OldAppKey(ctx)
	case app.FieldAppSecret:
		return m.OldAppSecret(ctx)
	case app.FieldScopes:
		return m.OldScopes(ctx)
	case app.FieldTokenValidity:
		return m.OldTokenValidity(ctx)
	case app.FieldRefreshTokenValidity:
		return m.OldRefreshTokenValidity(ctx)
	case app.FieldLogo:
		return m.OldLogo(ctx)
	case app.FieldComments:
		return m.OldComments(ctx)
	case app.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case app.FieldKind:
		v, ok := value.(app.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case app.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case app.FieldAppKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppKey(v)
		return nil
	case app.FieldAppSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSecret(v)
		return nil
	case app.FieldScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case app.FieldTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenValidity(v)
		return nil
	case app.FieldRefreshTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenValidity(v)
		return nil
	case app.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case app.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case app.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, app.FieldUpdatedBy)
	}
	if m.addtoken_validity != nil {
		fields = append(fields, app.FieldTokenValidity)
	}
	if m.addrefresh_token_validity != nil {
		fields = append(fields, app.FieldRefreshTokenValidity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedBy:
		return m.AddedCreatedBy()
	case app.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case app.FieldTokenValidity:
		return m.AddedTokenValidity()
	case app.FieldRefreshTokenValidity:
		return m.AddedRefreshTokenValidity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case app.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case app.FieldTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenValidity(v)
		return nil
	case app.FieldRefreshTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefreshTokenValidity(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldUpdatedBy) {
		fields = append(fields, app.FieldUpdatedBy)
	}
	if m.FieldCleared(app.FieldUpdatedAt) {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.FieldCleared(app.FieldRedirectURI) {
		fields = append(fields, app.FieldRedirectURI)
	}
	if m.FieldCleared(app.FieldAppKey) {
		fields = append(fields, app.FieldAppKey)
	}
	if m.FieldCleared(app.FieldAppSecret) {
		fields = append(fields, app.FieldAppSecret)
	}
	if m.FieldCleared(app.FieldScopes) {
		fields = append(fields, app.FieldScopes)
	}
	if m.FieldCleared(app.FieldTokenValidity) {
		fields = append(fields, app.FieldTokenValidity)
	}
	if m.FieldCleared(app.FieldRefreshTokenValidity) {
		fields = append(fields, app.FieldRefreshTokenValidity)
	}
	if m.FieldCleared(app.FieldLogo) {
		fields = append(fields, app.FieldLogo)
	}
	if m.FieldCleared(app.FieldComments) {
		fields = append(fields, app.FieldComments)
	}
	if m.FieldCleared(app.FieldStatus) {
		fields = append(fields, app.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case app.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case app.FieldRedirectURI:
		m.ClearRedirectURI()
		return nil
	case app.FieldAppKey:
		m.ClearAppKey()
		return nil
	case app.FieldAppSecret:
		m.ClearAppSecret()
		return nil
	case app.FieldScopes:
		m.ClearScopes()
		return nil
	case app.FieldTokenValidity:
		m.ClearTokenValidity()
		return nil
	case app.FieldRefreshTokenValidity:
		m.ClearRefreshTokenValidity()
		return nil
	case app.FieldLogo:
		m.ClearLogo()
		return nil
	case app.FieldComments:
		m.ClearComments()
		return nil
	case app.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldCode:
		m.ResetCode()
		return nil
	case app.FieldKind:
		m.ResetKind()
		return nil
	case app.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case app.FieldAppKey:
		m.ResetAppKey()
		return nil
	case app.FieldAppSecret:
		m.ResetAppSecret()
		return nil
	case app.FieldScopes:
		m.ResetScopes()
		return nil
	case app.FieldTokenValidity:
		m.ResetTokenValidity()
		return nil
	case app.FieldRefreshTokenValidity:
		m.ResetRefreshTokenValidity()
		return nil
	case app.FieldLogo:
		m.ResetLogo()
		return nil
	case app.FieldComments:
		m.ResetComments()
		return nil
	case app.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.menus != nil {
		edges = append(edges, app.EdgeMenus)
	}
	if m.actions != nil {
		edges = append(edges, app.EdgeActions)
	}
	if m.resources != nil {
		edges = append(edges, app.EdgeResources)
	}
	if m.roles != nil {
		edges = append(edges, app.EdgeRoles)
	}
	if m.policies != nil {
		edges = append(edges, app.EdgePolicies)
	}
	if m.organizations != nil {
		edges = append(edges, app.EdgeOrganizations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeActions:
		ids := make([]ent.Value, 0, len(m.actions))
		for id := range m.actions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmenus != nil {
		edges = append(edges, app.EdgeMenus)
	}
	if m.removedactions != nil {
		edges = append(edges, app.EdgeActions)
	}
	if m.removedresources != nil {
		edges = append(edges, app.EdgeResources)
	}
	if m.removedroles != nil {
		edges = append(edges, app.EdgeRoles)
	}
	if m.removedpolicies != nil {
		edges = append(edges, app.EdgePolicies)
	}
	if m.removedorganizations != nil {
		edges = append(edges, app.EdgeOrganizations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeActions:
		ids := make([]ent.Value, 0, len(m.removedactions))
		for id := range m.removedactions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedmenus {
		edges = append(edges, app.EdgeMenus)
	}
	if m.clearedactions {
		edges = append(edges, app.EdgeActions)
	}
	if m.clearedresources {
		edges = append(edges, app.EdgeResources)
	}
	if m.clearedroles {
		edges = append(edges, app.EdgeRoles)
	}
	if m.clearedpolicies {
		edges = append(edges, app.EdgePolicies)
	}
	if m.clearedorganizations {
		edges = append(edges, app.EdgeOrganizations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeMenus:
		return m.clearedmenus
	case app.EdgeActions:
		return m.clearedactions
	case app.EdgeResources:
		return m.clearedresources
	case app.EdgeRoles:
		return m.clearedroles
	case app.EdgePolicies:
		return m.clearedpolicies
	case app.EdgeOrganizations:
		return m.clearedorganizations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeMenus:
		m.ResetMenus()
		return nil
	case app.EdgeActions:
		m.ResetActions()
		return nil
	case app.EdgeResources:
		m.ResetResources()
		return nil
	case app.EdgeRoles:
		m.ResetRoles()
		return nil
	case app.EdgePolicies:
		m.ResetPolicies()
		return nil
	case app.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppActionMutation represents an operation that mutates the AppAction nodes in the graph.
type AppActionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_by       *int
	addcreated_by    *int
	created_at       *time.Time
	updated_by       *int
	addupdated_by    *int
	updated_at       *time.Time
	name             *string
	kind             *appaction.Kind
	method           *appaction.Method
	comments         *string
	clearedFields    map[string]struct{}
	app              *int
	clearedapp       bool
	menus            map[int]struct{}
	removedmenus     map[int]struct{}
	clearedmenus     bool
	resources        map[int]struct{}
	removedresources map[int]struct{}
	clearedresources bool
	done             bool
	oldValue         func(context.Context) (*AppAction, error)
	predicates       []predicate.AppAction
}

var _ ent.Mutation = (*AppActionMutation)(nil)

// appactionOption allows management of the mutation configuration using functional options.
type appactionOption func(*AppActionMutation)

// newAppActionMutation creates new mutation for the AppAction entity.
func newAppActionMutation(c config, op Op, opts ...appactionOption) *AppActionMutation {
	m := &AppActionMutation{
		config:        c,
		op:            op,
		typ:           TypeAppAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppActionID sets the ID field of the mutation.
func withAppActionID(id int) appactionOption {
	return func(m *AppActionMutation) {
		var (
			err   error
			once  sync.Once
			value *AppAction
		)
		m.oldValue = func(ctx context.Context) (*AppAction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppAction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppAction sets the old AppAction of the mutation.
func withAppAction(node *AppAction) appactionOption {
	return func(m *AppActionMutation) {
		m.oldValue = func(context.Context) (*AppAction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppAction entities.
func (m *AppActionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppActionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppAction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppActionMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppActionMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppActionMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppActionMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppActionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppActionMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppActionMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppActionMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppActionMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppActionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[appaction.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppActionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[appaction.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppActionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, appaction.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppActionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppActionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppActionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appaction.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppActionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appaction.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppActionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appaction.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppActionMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppActionMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppActionMutation) ResetAppID() {
	m.app = nil
}

// SetName sets the "name" field.
func (m *AppActionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppActionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppActionMutation) ResetName() {
	m.name = nil
}

// SetKind sets the "kind" field.
func (m *AppActionMutation) SetKind(a appaction.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AppActionMutation) Kind() (r appaction.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldKind(ctx context.Context) (v appaction.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AppActionMutation) ResetKind() {
	m.kind = nil
}

// SetMethod sets the "method" field.
func (m *AppActionMutation) SetMethod(a appaction.Method) {
	m.method = &a
}

// Method returns the value of the "method" field in the mutation.
func (m *AppActionMutation) Method() (r appaction.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldMethod(ctx context.Context) (v appaction.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AppActionMutation) ResetMethod() {
	m.method = nil
}

// SetComments sets the "comments" field.
func (m *AppActionMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppActionMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppActionMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[appaction.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppActionMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[appaction.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppActionMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, appaction.FieldComments)
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppActionMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppActionMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppActionMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppActionMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddMenuIDs adds the "menus" edge to the AppMenu entity by ids.
func (m *AppActionMutation) AddMenuIDs(ids ...int) {
	if m.menus == nil {
		m.menus = make(map[int]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the AppMenu entity.
func (m *AppActionMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the AppMenu entity was cleared.
func (m *AppActionMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the AppMenu entity by IDs.
func (m *AppActionMutation) RemoveMenuIDs(ids ...int) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the AppMenu entity.
func (m *AppActionMutation) RemovedMenusIDs() (ids []int) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *AppActionMutation) MenusIDs() (ids []int) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *AppActionMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddResourceIDs adds the "resources" edge to the AppRes entity by ids.
func (m *AppActionMutation) AddResourceIDs(ids ...int) {
	if m.resources == nil {
		m.resources = make(map[int]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the AppRes entity.
func (m *AppActionMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the AppRes entity was cleared.
func (m *AppActionMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the AppRes entity by IDs.
func (m *AppActionMutation) RemoveResourceIDs(ids ...int) {
	if m.removedresources == nil {
		m.removedresources = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the AppRes entity.
func (m *AppActionMutation) RemovedResourcesIDs() (ids []int) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *AppActionMutation) ResourcesIDs() (ids []int) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *AppActionMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// Where appends a list predicates to the AppActionMutation builder.
func (m *AppActionMutation) Where(ps ...predicate.AppAction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppAction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppAction).
func (m *AppActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppActionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, appaction.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, appaction.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, appaction.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, appaction.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, appaction.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, appaction.FieldName)
	}
	if m.kind != nil {
		fields = append(fields, appaction.FieldKind)
	}
	if m.method != nil {
		fields = append(fields, appaction.FieldMethod)
	}
	if m.comments != nil {
		fields = append(fields, appaction.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appaction.FieldCreatedBy:
		return m.CreatedBy()
	case appaction.FieldCreatedAt:
		return m.CreatedAt()
	case appaction.FieldUpdatedBy:
		return m.UpdatedBy()
	case appaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case appaction.FieldAppID:
		return m.AppID()
	case appaction.FieldName:
		return m.Name()
	case appaction.FieldKind:
		return m.Kind()
	case appaction.FieldMethod:
		return m.Method()
	case appaction.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appaction.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case appaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appaction.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case appaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appaction.FieldAppID:
		return m.OldAppID(ctx)
	case appaction.FieldName:
		return m.OldName(ctx)
	case appaction.FieldKind:
		return m.OldKind(ctx)
	case appaction.FieldMethod:
		return m.OldMethod(ctx)
	case appaction.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown AppAction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appaction.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case appaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appaction.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case appaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appaction.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appaction.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appaction.FieldKind:
		v, ok := value.(appaction.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case appaction.FieldMethod:
		v, ok := value.(appaction.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case appaction.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown AppAction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppActionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, appaction.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, appaction.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appaction.FieldCreatedBy:
		return m.AddedCreatedBy()
	case appaction.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appaction.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case appaction.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AppAction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppActionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appaction.FieldUpdatedBy) {
		fields = append(fields, appaction.FieldUpdatedBy)
	}
	if m.FieldCleared(appaction.FieldUpdatedAt) {
		fields = append(fields, appaction.FieldUpdatedAt)
	}
	if m.FieldCleared(appaction.FieldComments) {
		fields = append(fields, appaction.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppActionMutation) ClearField(name string) error {
	switch name {
	case appaction.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case appaction.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case appaction.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown AppAction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppActionMutation) ResetField(name string) error {
	switch name {
	case appaction.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case appaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appaction.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case appaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appaction.FieldAppID:
		m.ResetAppID()
		return nil
	case appaction.FieldName:
		m.ResetName()
		return nil
	case appaction.FieldKind:
		m.ResetKind()
		return nil
	case appaction.FieldMethod:
		m.ResetMethod()
		return nil
	case appaction.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown AppAction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, appaction.EdgeApp)
	}
	if m.menus != nil {
		edges = append(edges, appaction.EdgeMenus)
	}
	if m.resources != nil {
		edges = append(edges, appaction.EdgeResources)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appaction.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appaction.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case appaction.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmenus != nil {
		edges = append(edges, appaction.EdgeMenus)
	}
	if m.removedresources != nil {
		edges = append(edges, appaction.EdgeResources)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppActionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case appaction.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case appaction.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, appaction.EdgeApp)
	}
	if m.clearedmenus {
		edges = append(edges, appaction.EdgeMenus)
	}
	if m.clearedresources {
		edges = append(edges, appaction.EdgeResources)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppActionMutation) EdgeCleared(name string) bool {
	switch name {
	case appaction.EdgeApp:
		return m.clearedapp
	case appaction.EdgeMenus:
		return m.clearedmenus
	case appaction.EdgeResources:
		return m.clearedresources
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppActionMutation) ClearEdge(name string) error {
	switch name {
	case appaction.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppAction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppActionMutation) ResetEdge(name string) error {
	switch name {
	case appaction.EdgeApp:
		m.ResetApp()
		return nil
	case appaction.EdgeMenus:
		m.ResetMenus()
		return nil
	case appaction.EdgeResources:
		m.ResetResources()
		return nil
	}
	return fmt.Errorf("unknown AppAction edge %s", name)
}

// AppMenuMutation represents an operation that mutates the AppMenu nodes in the graph.
type AppMenuMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_by      *int
	addcreated_by   *int
	created_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_at      *time.Time
	parent_id       *int
	addparent_id    *int
	kind            *appmenu.Kind
	name            *string
	comments        *string
	display_sort    *int32
	adddisplay_sort *int32
	clearedFields   map[string]struct{}
	app             *int
	clearedapp      bool
	action          *int
	clearedaction   bool
	done            bool
	oldValue        func(context.Context) (*AppMenu, error)
	predicates      []predicate.AppMenu
}

var _ ent.Mutation = (*AppMenuMutation)(nil)

// appmenuOption allows management of the mutation configuration using functional options.
type appmenuOption func(*AppMenuMutation)

// newAppMenuMutation creates new mutation for the AppMenu entity.
func newAppMenuMutation(c config, op Op, opts ...appmenuOption) *AppMenuMutation {
	m := &AppMenuMutation{
		config:        c,
		op:            op,
		typ:           TypeAppMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppMenuID sets the ID field of the mutation.
func withAppMenuID(id int) appmenuOption {
	return func(m *AppMenuMutation) {
		var (
			err   error
			once  sync.Once
			value *AppMenu
		)
		m.oldValue = func(ctx context.Context) (*AppMenu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppMenu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppMenu sets the old AppMenu of the mutation.
func withAppMenu(node *AppMenu) appmenuOption {
	return func(m *AppMenuMutation) {
		m.oldValue = func(context.Context) (*AppMenu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppMenu entities.
func (m *AppMenuMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMenuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMenuMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppMenu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppMenuMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppMenuMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppMenuMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppMenuMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppMenuMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMenuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppMenuMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppMenuMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppMenuMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppMenuMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppMenuMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[appmenu.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppMenuMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppMenuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, appmenu.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppMenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appmenu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppMenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appmenu.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppMenuMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppMenuMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppMenuMutation) ResetAppID() {
	m.app = nil
}

// SetParentID sets the "parent_id" field.
func (m *AppMenuMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *AppMenuMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *AppMenuMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *AppMenuMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *AppMenuMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
}

// SetKind sets the "kind" field.
func (m *AppMenuMutation) SetKind(a appmenu.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AppMenuMutation) Kind() (r appmenu.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldKind(ctx context.Context) (v appmenu.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AppMenuMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *AppMenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppMenuMutation) ClearName() {
	m.name = nil
	m.clearedFields[appmenu.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppMenuMutation) NameCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppMenuMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, appmenu.FieldName)
}

// SetActionID sets the "action_id" field.
func (m *AppMenuMutation) SetActionID(i int) {
	m.action = &i
}

// ActionID returns the value of the "action_id" field in the mutation.
func (m *AppMenuMutation) ActionID() (r int, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldActionID returns the old "action_id" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldActionID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionID: %w", err)
	}
	return oldValue.ActionID, nil
}

// ClearActionID clears the value of the "action_id" field.
func (m *AppMenuMutation) ClearActionID() {
	m.action = nil
	m.clearedFields[appmenu.FieldActionID] = struct{}{}
}

// ActionIDCleared returns if the "action_id" field was cleared in this mutation.
func (m *AppMenuMutation) ActionIDCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldActionID]
	return ok
}

// ResetActionID resets all changes to the "action_id" field.
func (m *AppMenuMutation) ResetActionID() {
	m.action = nil
	delete(m.clearedFields, appmenu.FieldActionID)
}

// SetComments sets the "comments" field.
func (m *AppMenuMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppMenuMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppMenuMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[appmenu.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppMenuMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppMenuMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, appmenu.FieldComments)
}

// SetDisplaySort sets the "display_sort" field.
func (m *AppMenuMutation) SetDisplaySort(i int32) {
	m.display_sort = &i
	m.adddisplay_sort = nil
}

// DisplaySort returns the value of the "display_sort" field in the mutation.
func (m *AppMenuMutation) DisplaySort() (r int32, exists bool) {
	v := m.display_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplaySort returns the old "display_sort" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldDisplaySort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplaySort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplaySort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplaySort: %w", err)
	}
	return oldValue.DisplaySort, nil
}

// AddDisplaySort adds i to the "display_sort" field.
func (m *AppMenuMutation) AddDisplaySort(i int32) {
	if m.adddisplay_sort != nil {
		*m.adddisplay_sort += i
	} else {
		m.adddisplay_sort = &i
	}
}

// AddedDisplaySort returns the value that was added to the "display_sort" field in this mutation.
func (m *AppMenuMutation) AddedDisplaySort() (r int32, exists bool) {
	v := m.adddisplay_sort
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplaySort clears the value of the "display_sort" field.
func (m *AppMenuMutation) ClearDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	m.clearedFields[appmenu.FieldDisplaySort] = struct{}{}
}

// DisplaySortCleared returns if the "display_sort" field was cleared in this mutation.
func (m *AppMenuMutation) DisplaySortCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldDisplaySort]
	return ok
}

// ResetDisplaySort resets all changes to the "display_sort" field.
func (m *AppMenuMutation) ResetDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	delete(m.clearedFields, appmenu.FieldDisplaySort)
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppMenuMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppMenuMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppMenuMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppMenuMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// ClearAction clears the "action" edge to the AppAction entity.
func (m *AppMenuMutation) ClearAction() {
	m.clearedaction = true
}

// ActionCleared reports if the "action" edge to the AppAction entity was cleared.
func (m *AppMenuMutation) ActionCleared() bool {
	return m.ActionIDCleared() || m.clearedaction
}

// ActionIDs returns the "action" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActionID instead. It exists only for internal usage by the builders.
func (m *AppMenuMutation) ActionIDs() (ids []int) {
	if id := m.action; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAction resets all changes to the "action" edge.
func (m *AppMenuMutation) ResetAction() {
	m.action = nil
	m.clearedaction = false
}

// Where appends a list predicates to the AppMenuMutation builder.
func (m *AppMenuMutation) Where(ps ...predicate.AppMenu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppMenu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppMenu).
func (m *AppMenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMenuMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, appmenu.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, appmenu.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, appmenu.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, appmenu.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, appmenu.FieldAppID)
	}
	if m.parent_id != nil {
		fields = append(fields, appmenu.FieldParentID)
	}
	if m.kind != nil {
		fields = append(fields, appmenu.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, appmenu.FieldName)
	}
	if m.action != nil {
		fields = append(fields, appmenu.FieldActionID)
	}
	if m.comments != nil {
		fields = append(fields, appmenu.FieldComments)
	}
	if m.display_sort != nil {
		fields = append(fields, appmenu.FieldDisplaySort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appmenu.FieldCreatedBy:
		return m.CreatedBy()
	case appmenu.FieldCreatedAt:
		return m.CreatedAt()
	case appmenu.FieldUpdatedBy:
		return m.UpdatedBy()
	case appmenu.FieldUpdatedAt:
		return m.UpdatedAt()
	case appmenu.FieldAppID:
		return m.AppID()
	case appmenu.FieldParentID:
		return m.ParentID()
	case appmenu.FieldKind:
		return m.Kind()
	case appmenu.FieldName:
		return m.Name()
	case appmenu.FieldActionID:
		return m.ActionID()
	case appmenu.FieldComments:
		return m.Comments()
	case appmenu.FieldDisplaySort:
		return m.DisplaySort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appmenu.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case appmenu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appmenu.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case appmenu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appmenu.FieldAppID:
		return m.OldAppID(ctx)
	case appmenu.FieldParentID:
		return m.OldParentID(ctx)
	case appmenu.FieldKind:
		return m.OldKind(ctx)
	case appmenu.FieldName:
		return m.OldName(ctx)
	case appmenu.FieldActionID:
		return m.OldActionID(ctx)
	case appmenu.FieldComments:
		return m.OldComments(ctx)
	case appmenu.FieldDisplaySort:
		return m.OldDisplaySort(ctx)
	}
	return nil, fmt.Errorf("unknown AppMenu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appmenu.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case appmenu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appmenu.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case appmenu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appmenu.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appmenu.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case appmenu.FieldKind:
		v, ok := value.(appmenu.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case appmenu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appmenu.FieldActionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionID(v)
		return nil
	case appmenu.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case appmenu.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplaySort(v)
		return nil
	}
	return fmt.Errorf("unknown AppMenu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMenuMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, appmenu.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, appmenu.FieldUpdatedBy)
	}
	if m.addparent_id != nil {
		fields = append(fields, appmenu.FieldParentID)
	}
	if m.adddisplay_sort != nil {
		fields = append(fields, appmenu.FieldDisplaySort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appmenu.FieldCreatedBy:
		return m.AddedCreatedBy()
	case appmenu.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case appmenu.FieldParentID:
		return m.AddedParentID()
	case appmenu.FieldDisplaySort:
		return m.AddedDisplaySort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appmenu.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case appmenu.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case appmenu.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case appmenu.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplaySort(v)
		return nil
	}
	return fmt.Errorf("unknown AppMenu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appmenu.FieldUpdatedBy) {
		fields = append(fields, appmenu.FieldUpdatedBy)
	}
	if m.FieldCleared(appmenu.FieldUpdatedAt) {
		fields = append(fields, appmenu.FieldUpdatedAt)
	}
	if m.FieldCleared(appmenu.FieldName) {
		fields = append(fields, appmenu.FieldName)
	}
	if m.FieldCleared(appmenu.FieldActionID) {
		fields = append(fields, appmenu.FieldActionID)
	}
	if m.FieldCleared(appmenu.FieldComments) {
		fields = append(fields, appmenu.FieldComments)
	}
	if m.FieldCleared(appmenu.FieldDisplaySort) {
		fields = append(fields, appmenu.FieldDisplaySort)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMenuMutation) ClearField(name string) error {
	switch name {
	case appmenu.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case appmenu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case appmenu.FieldName:
		m.ClearName()
		return nil
	case appmenu.FieldActionID:
		m.ClearActionID()
		return nil
	case appmenu.FieldComments:
		m.ClearComments()
		return nil
	case appmenu.FieldDisplaySort:
		m.ClearDisplaySort()
		return nil
	}
	return fmt.Errorf("unknown AppMenu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMenuMutation) ResetField(name string) error {
	switch name {
	case appmenu.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case appmenu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appmenu.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case appmenu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appmenu.FieldAppID:
		m.ResetAppID()
		return nil
	case appmenu.FieldParentID:
		m.ResetParentID()
		return nil
	case appmenu.FieldKind:
		m.ResetKind()
		return nil
	case appmenu.FieldName:
		m.ResetName()
		return nil
	case appmenu.FieldActionID:
		m.ResetActionID()
		return nil
	case appmenu.FieldComments:
		m.ResetComments()
		return nil
	case appmenu.FieldDisplaySort:
		m.ResetDisplaySort()
		return nil
	}
	return fmt.Errorf("unknown AppMenu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, appmenu.EdgeApp)
	}
	if m.action != nil {
		edges = append(edges, appmenu.EdgeAction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appmenu.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appmenu.EdgeAction:
		if id := m.action; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMenuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, appmenu.EdgeApp)
	}
	if m.clearedaction {
		edges = append(edges, appmenu.EdgeAction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMenuMutation) EdgeCleared(name string) bool {
	switch name {
	case appmenu.EdgeApp:
		return m.clearedapp
	case appmenu.EdgeAction:
		return m.clearedaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMenuMutation) ClearEdge(name string) error {
	switch name {
	case appmenu.EdgeApp:
		m.ClearApp()
		return nil
	case appmenu.EdgeAction:
		m.ClearAction()
		return nil
	}
	return fmt.Errorf("unknown AppMenu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMenuMutation) ResetEdge(name string) error {
	switch name {
	case appmenu.EdgeApp:
		m.ResetApp()
		return nil
	case appmenu.EdgeAction:
		m.ResetAction()
		return nil
	}
	return fmt.Errorf("unknown AppMenu edge %s", name)
}

// AppPolicyMutation represents an operation that mutates the AppPolicy nodes in the graph.
type AppPolicyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	name          *string
	comments      *string
	rules         *[]types.PolicyRule
	appendrules   []types.PolicyRule
	version       *string
	auto_grant    *bool
	status        *typex.SimpleStatus
	clearedFields map[string]struct{}
	app           *int
	clearedapp    bool
	roles         map[int]struct{}
	removedroles  map[int]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*AppPolicy, error)
	predicates    []predicate.AppPolicy
}

var _ ent.Mutation = (*AppPolicyMutation)(nil)

// apppolicyOption allows management of the mutation configuration using functional options.
type apppolicyOption func(*AppPolicyMutation)

// newAppPolicyMutation creates new mutation for the AppPolicy entity.
func newAppPolicyMutation(c config, op Op, opts ...apppolicyOption) *AppPolicyMutation {
	m := &AppPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeAppPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppPolicyID sets the ID field of the mutation.
func withAppPolicyID(id int) apppolicyOption {
	return func(m *AppPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *AppPolicy
		)
		m.oldValue = func(ctx context.Context) (*AppPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppPolicy sets the old AppPolicy of the mutation.
func withAppPolicy(node *AppPolicy) apppolicyOption {
	return func(m *AppPolicyMutation) {
		m.oldValue = func(context.Context) (*AppPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppPolicy entities.
func (m *AppPolicyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppPolicyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppPolicyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppPolicyMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppPolicyMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppPolicyMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppPolicyMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppPolicyMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppPolicyMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppPolicyMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppPolicyMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppPolicyMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppPolicyMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[apppolicy.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppPolicyMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[apppolicy.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppPolicyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, apppolicy.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppPolicyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[apppolicy.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppPolicyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[apppolicy.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, apppolicy.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppPolicyMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppPolicyMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppPolicyMutation) ResetAppID() {
	m.app = nil
}

// SetName sets the "name" field.
func (m *AppPolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppPolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppPolicyMutation) ResetName() {
	m.name = nil
}

// SetComments sets the "comments" field.
func (m *AppPolicyMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppPolicyMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ResetComments resets all changes to the "comments" field.
func (m *AppPolicyMutation) ResetComments() {
	m.comments = nil
}

// SetRules sets the "rules" field.
func (m *AppPolicyMutation) SetRules(tr []types.PolicyRule) {
	m.rules = &tr
	m.appendrules = nil
}

// Rules returns the value of the "rules" field in the mutation.
func (m *AppPolicyMutation) Rules() (r []types.PolicyRule, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRules returns the old "rules" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldRules(ctx context.Context) (v []types.PolicyRule, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRules: %w", err)
	}
	return oldValue.Rules, nil
}

// AppendRules adds tr to the "rules" field.
func (m *AppPolicyMutation) AppendRules(tr []types.PolicyRule) {
	m.appendrules = append(m.appendrules, tr...)
}

// AppendedRules returns the list of values that were appended to the "rules" field in this mutation.
func (m *AppPolicyMutation) AppendedRules() ([]types.PolicyRule, bool) {
	if len(m.appendrules) == 0 {
		return nil, false
	}
	return m.appendrules, true
}

// ResetRules resets all changes to the "rules" field.
func (m *AppPolicyMutation) ResetRules() {
	m.rules = nil
	m.appendrules = nil
}

// SetVersion sets the "version" field.
func (m *AppPolicyMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AppPolicyMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AppPolicyMutation) ResetVersion() {
	m.version = nil
}

// SetAutoGrant sets the "auto_grant" field.
func (m *AppPolicyMutation) SetAutoGrant(b bool) {
	m.auto_grant = &b
}

// AutoGrant returns the value of the "auto_grant" field in the mutation.
func (m *AppPolicyMutation) AutoGrant() (r bool, exists bool) {
	v := m.auto_grant
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoGrant returns the old "auto_grant" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldAutoGrant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoGrant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoGrant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoGrant: %w", err)
	}
	return oldValue.AutoGrant, nil
}

// ResetAutoGrant resets all changes to the "auto_grant" field.
func (m *AppPolicyMutation) ResetAutoGrant() {
	m.auto_grant = nil
}

// SetStatus sets the "status" field.
func (m *AppPolicyMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *AppPolicyMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *AppPolicyMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[apppolicy.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AppPolicyMutation) StatusCleared() bool {
	_, ok := m.clearedFields[apppolicy.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AppPolicyMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, apppolicy.FieldStatus)
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppPolicyMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppPolicyMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppPolicyMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppPolicyMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddRoleIDs adds the "roles" edge to the AppRole entity by ids.
func (m *AppPolicyMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the AppRole entity.
func (m *AppPolicyMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AppRole entity was cleared.
func (m *AppPolicyMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the AppRole entity by IDs.
func (m *AppPolicyMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the AppRole entity.
func (m *AppPolicyMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AppPolicyMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AppPolicyMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the AppPolicyMutation builder.
func (m *AppPolicyMutation) Where(ps ...predicate.AppPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppPolicy).
func (m *AppPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppPolicyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, apppolicy.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, apppolicy.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, apppolicy.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, apppolicy.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, apppolicy.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, apppolicy.FieldName)
	}
	if m.comments != nil {
		fields = append(fields, apppolicy.FieldComments)
	}
	if m.rules != nil {
		fields = append(fields, apppolicy.FieldRules)
	}
	if m.version != nil {
		fields = append(fields, apppolicy.FieldVersion)
	}
	if m.auto_grant != nil {
		fields = append(fields, apppolicy.FieldAutoGrant)
	}
	if m.status != nil {
		fields = append(fields, apppolicy.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apppolicy.FieldCreatedBy:
		return m.CreatedBy()
	case apppolicy.FieldCreatedAt:
		return m.CreatedAt()
	case apppolicy.FieldUpdatedBy:
		return m.UpdatedBy()
	case apppolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case apppolicy.FieldAppID:
		return m.AppID()
	case apppolicy.FieldName:
		return m.Name()
	case apppolicy.FieldComments:
		return m.Comments()
	case apppolicy.FieldRules:
		return m.Rules()
	case apppolicy.FieldVersion:
		return m.Version()
	case apppolicy.FieldAutoGrant:
		return m.AutoGrant()
	case apppolicy.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apppolicy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case apppolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apppolicy.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case apppolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apppolicy.FieldAppID:
		return m.OldAppID(ctx)
	case apppolicy.FieldName:
		return m.OldName(ctx)
	case apppolicy.FieldComments:
		return m.OldComments(ctx)
	case apppolicy.FieldRules:
		return m.OldRules(ctx)
	case apppolicy.FieldVersion:
		return m.OldVersion(ctx)
	case apppolicy.FieldAutoGrant:
		return m.OldAutoGrant(ctx)
	case apppolicy.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown AppPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apppolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case apppolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apppolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case apppolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apppolicy.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case apppolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apppolicy.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case apppolicy.FieldRules:
		v, ok := value.([]types.PolicyRule)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRules(v)
		return nil
	case apppolicy.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case apppolicy.FieldAutoGrant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoGrant(v)
		return nil
	case apppolicy.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AppPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppPolicyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, apppolicy.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, apppolicy.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppPolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apppolicy.FieldCreatedBy:
		return m.AddedCreatedBy()
	case apppolicy.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apppolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case apppolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AppPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apppolicy.FieldUpdatedBy) {
		fields = append(fields, apppolicy.FieldUpdatedBy)
	}
	if m.FieldCleared(apppolicy.FieldUpdatedAt) {
		fields = append(fields, apppolicy.FieldUpdatedAt)
	}
	if m.FieldCleared(apppolicy.FieldStatus) {
		fields = append(fields, apppolicy.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppPolicyMutation) ClearField(name string) error {
	switch name {
	case apppolicy.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case apppolicy.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case apppolicy.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown AppPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppPolicyMutation) ResetField(name string) error {
	switch name {
	case apppolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case apppolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apppolicy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case apppolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apppolicy.FieldAppID:
		m.ResetAppID()
		return nil
	case apppolicy.FieldName:
		m.ResetName()
		return nil
	case apppolicy.FieldComments:
		m.ResetComments()
		return nil
	case apppolicy.FieldRules:
		m.ResetRules()
		return nil
	case apppolicy.FieldVersion:
		m.ResetVersion()
		return nil
	case apppolicy.FieldAutoGrant:
		m.ResetAutoGrant()
		return nil
	case apppolicy.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown AppPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, apppolicy.EdgeApp)
	}
	if m.roles != nil {
		edges = append(edges, apppolicy.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppPolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apppolicy.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case apppolicy.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedroles != nil {
		edges = append(edges, apppolicy.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppPolicyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apppolicy.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, apppolicy.EdgeApp)
	}
	if m.clearedroles {
		edges = append(edges, apppolicy.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppPolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case apppolicy.EdgeApp:
		return m.clearedapp
	case apppolicy.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppPolicyMutation) ClearEdge(name string) error {
	switch name {
	case apppolicy.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppPolicyMutation) ResetEdge(name string) error {
	switch name {
	case apppolicy.EdgeApp:
		m.ResetApp()
		return nil
	case apppolicy.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown AppPolicy edge %s", name)
}

// AppResMutation represents an operation that mutates the AppRes nodes in the graph.
type AppResMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	name          *string
	type_name     *string
	arn_pattern   *string
	clearedFields map[string]struct{}
	app           *int
	clearedapp    bool
	done          bool
	oldValue      func(context.Context) (*AppRes, error)
	predicates    []predicate.AppRes
}

var _ ent.Mutation = (*AppResMutation)(nil)

// appresOption allows management of the mutation configuration using functional options.
type appresOption func(*AppResMutation)

// newAppResMutation creates new mutation for the AppRes entity.
func newAppResMutation(c config, op Op, opts ...appresOption) *AppResMutation {
	m := &AppResMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppResID sets the ID field of the mutation.
func withAppResID(id int) appresOption {
	return func(m *AppResMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRes
		)
		m.oldValue = func(ctx context.Context) (*AppRes, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRes sets the old AppRes of the mutation.
func withAppRes(node *AppRes) appresOption {
	return func(m *AppResMutation) {
		m.oldValue = func(context.Context) (*AppRes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppResMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppResMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRes entities.
func (m *AppResMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppResMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppResMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRes.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppResMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppResMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppResMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppResMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppResMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppResMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppResMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppResMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppResMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppResMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppResMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppResMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppResMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[appres.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppResMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[appres.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppResMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, appres.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppResMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppResMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppResMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appres.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppResMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appres.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppResMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appres.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppResMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppResMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppResMutation) ResetAppID() {
	m.app = nil
}

// SetName sets the "name" field.
func (m *AppResMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppResMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppResMutation) ResetName() {
	m.name = nil
}

// SetTypeName sets the "type_name" field.
func (m *AppResMutation) SetTypeName(s string) {
	m.type_name = &s
}

// TypeName returns the value of the "type_name" field in the mutation.
func (m *AppResMutation) TypeName() (r string, exists bool) {
	v := m.type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "type_name" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName resets all changes to the "type_name" field.
func (m *AppResMutation) ResetTypeName() {
	m.type_name = nil
}

// SetArnPattern sets the "arn_pattern" field.
func (m *AppResMutation) SetArnPattern(s string) {
	m.arn_pattern = &s
}

// ArnPattern returns the value of the "arn_pattern" field in the mutation.
func (m *AppResMutation) ArnPattern() (r string, exists bool) {
	v := m.arn_pattern
	if v == nil {
		return
	}
	return *v, true
}

// OldArnPattern returns the old "arn_pattern" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldArnPattern(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArnPattern is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArnPattern requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArnPattern: %w", err)
	}
	return oldValue.ArnPattern, nil
}

// ResetArnPattern resets all changes to the "arn_pattern" field.
func (m *AppResMutation) ResetArnPattern() {
	m.arn_pattern = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppResMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppResMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppResMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppResMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the AppResMutation builder.
func (m *AppResMutation) Where(ps ...predicate.AppRes) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppResMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppResMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRes, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppResMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppResMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRes).
func (m *AppResMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppResMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, appres.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, appres.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, appres.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, appres.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, appres.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, appres.FieldName)
	}
	if m.type_name != nil {
		fields = append(fields, appres.FieldTypeName)
	}
	if m.arn_pattern != nil {
		fields = append(fields, appres.FieldArnPattern)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppResMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appres.FieldCreatedBy:
		return m.CreatedBy()
	case appres.FieldCreatedAt:
		return m.CreatedAt()
	case appres.FieldUpdatedBy:
		return m.UpdatedBy()
	case appres.FieldUpdatedAt:
		return m.UpdatedAt()
	case appres.FieldAppID:
		return m.AppID()
	case appres.FieldName:
		return m.Name()
	case appres.FieldTypeName:
		return m.TypeName()
	case appres.FieldArnPattern:
		return m.ArnPattern()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppResMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appres.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case appres.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appres.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case appres.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appres.FieldAppID:
		return m.OldAppID(ctx)
	case appres.FieldName:
		return m.OldName(ctx)
	case appres.FieldTypeName:
		return m.OldTypeName(ctx)
	case appres.FieldArnPattern:
		return m.OldArnPattern(ctx)
	}
	return nil, fmt.Errorf("unknown AppRes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppResMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appres.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case appres.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appres.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case appres.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appres.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appres.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appres.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case appres.FieldArnPattern:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArnPattern(v)
		return nil
	}
	return fmt.Errorf("unknown AppRes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppResMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, appres.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, appres.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppResMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appres.FieldCreatedBy:
		return m.AddedCreatedBy()
	case appres.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppResMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appres.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case appres.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AppRes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppResMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appres.FieldUpdatedBy) {
		fields = append(fields, appres.FieldUpdatedBy)
	}
	if m.FieldCleared(appres.FieldUpdatedAt) {
		fields = append(fields, appres.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppResMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppResMutation) ClearField(name string) error {
	switch name {
	case appres.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case appres.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppRes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppResMutation) ResetField(name string) error {
	switch name {
	case appres.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case appres.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appres.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case appres.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appres.FieldAppID:
		m.ResetAppID()
		return nil
	case appres.FieldName:
		m.ResetName()
		return nil
	case appres.FieldTypeName:
		m.ResetTypeName()
		return nil
	case appres.FieldArnPattern:
		m.ResetArnPattern()
		return nil
	}
	return fmt.Errorf("unknown AppRes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppResMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.app != nil {
		edges = append(edges, appres.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppResMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appres.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppResMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppResMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppResMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapp {
		edges = append(edges, appres.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppResMutation) EdgeCleared(name string) bool {
	switch name {
	case appres.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppResMutation) ClearEdge(name string) error {
	switch name {
	case appres.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppRes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppResMutation) ResetEdge(name string) error {
	switch name {
	case appres.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AppRes edge %s", name)
}

// AppRoleMutation represents an operation that mutates the AppRole nodes in the graph.
type AppRoleMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_by      *int
	addcreated_by   *int
	created_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_at      *time.Time
	name            *string
	comments        *string
	auto_grant      *bool
	editable        *bool
	clearedFields   map[string]struct{}
	app             *int
	clearedapp      bool
	policies        map[int]struct{}
	removedpolicies map[int]struct{}
	clearedpolicies bool
	done            bool
	oldValue        func(context.Context) (*AppRole, error)
	predicates      []predicate.AppRole
}

var _ ent.Mutation = (*AppRoleMutation)(nil)

// approleOption allows management of the mutation configuration using functional options.
type approleOption func(*AppRoleMutation)

// newAppRoleMutation creates new mutation for the AppRole entity.
func newAppRoleMutation(c config, op Op, opts ...approleOption) *AppRoleMutation {
	m := &AppRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRoleID sets the ID field of the mutation.
func withAppRoleID(id int) approleOption {
	return func(m *AppRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRole
		)
		m.oldValue = func(ctx context.Context) (*AppRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRole sets the old AppRole of the mutation.
func withAppRole(node *AppRole) approleOption {
	return func(m *AppRoleMutation) {
		m.oldValue = func(context.Context) (*AppRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRole entities.
func (m *AppRoleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppRoleMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppRoleMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppRoleMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppRoleMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppRoleMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppRoleMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppRoleMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppRoleMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppRoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[approle.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[approle.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, approle.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[approle.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[approle.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, approle.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppRoleMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRoleMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRoleMutation) ResetAppID() {
	m.app = nil
}

// SetName sets the "name" field.
func (m *AppRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppRoleMutation) ResetName() {
	m.name = nil
}

// SetComments sets the "comments" field.
func (m *AppRoleMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppRoleMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppRoleMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[approle.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppRoleMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[approle.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppRoleMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, approle.FieldComments)
}

// SetAutoGrant sets the "auto_grant" field.
func (m *AppRoleMutation) SetAutoGrant(b bool) {
	m.auto_grant = &b
}

// AutoGrant returns the value of the "auto_grant" field in the mutation.
func (m *AppRoleMutation) AutoGrant() (r bool, exists bool) {
	v := m.auto_grant
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoGrant returns the old "auto_grant" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldAutoGrant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoGrant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoGrant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoGrant: %w", err)
	}
	return oldValue.AutoGrant, nil
}

// ResetAutoGrant resets all changes to the "auto_grant" field.
func (m *AppRoleMutation) ResetAutoGrant() {
	m.auto_grant = nil
}

// SetEditable sets the "editable" field.
func (m *AppRoleMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the value of the "editable" field in the mutation.
func (m *AppRoleMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old "editable" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldEditable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ResetEditable resets all changes to the "editable" field.
func (m *AppRoleMutation) ResetEditable() {
	m.editable = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppRoleMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppRoleMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppRoleMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppRoleMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddPolicyIDs adds the "policies" edge to the AppPolicy entity by ids.
func (m *AppRoleMutation) AddPolicyIDs(ids ...int) {
	if m.policies == nil {
		m.policies = make(map[int]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the "policies" edge to the AppPolicy entity.
func (m *AppRoleMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared reports if the "policies" edge to the AppPolicy entity was cleared.
func (m *AppRoleMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the "policies" edge to the AppPolicy entity by IDs.
func (m *AppRoleMutation) RemovePolicyIDs(ids ...int) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.policies, ids[i])
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed IDs of the "policies" edge to the AppPolicy entity.
func (m *AppRoleMutation) RemovedPoliciesIDs() (ids []int) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the "policies" edge IDs in the mutation.
func (m *AppRoleMutation) PoliciesIDs() (ids []int) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies resets all changes to the "policies" edge.
func (m *AppRoleMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// Where appends a list predicates to the AppRoleMutation builder.
func (m *AppRoleMutation) Where(ps ...predicate.AppRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRole).
func (m *AppRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, approle.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, approle.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, approle.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, approle.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, approle.FieldName)
	}
	if m.comments != nil {
		fields = append(fields, approle.FieldComments)
	}
	if m.auto_grant != nil {
		fields = append(fields, approle.FieldAutoGrant)
	}
	if m.editable != nil {
		fields = append(fields, approle.FieldEditable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedBy:
		return m.CreatedBy()
	case approle.FieldCreatedAt:
		return m.CreatedAt()
	case approle.FieldUpdatedBy:
		return m.UpdatedBy()
	case approle.FieldUpdatedAt:
		return m.UpdatedAt()
	case approle.FieldAppID:
		return m.AppID()
	case approle.FieldName:
		return m.Name()
	case approle.FieldComments:
		return m.Comments()
	case approle.FieldAutoGrant:
		return m.AutoGrant()
	case approle.FieldEditable:
		return m.Editable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approle.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case approle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approle.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case approle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approle.FieldAppID:
		return m.OldAppID(ctx)
	case approle.FieldName:
		return m.OldName(ctx)
	case approle.FieldComments:
		return m.OldComments(ctx)
	case approle.FieldAutoGrant:
		return m.OldAutoGrant(ctx)
	case approle.FieldEditable:
		return m.OldEditable(ctx)
	}
	return nil, fmt.Errorf("unknown AppRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case approle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approle.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case approle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approle.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case approle.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case approle.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case approle.FieldAutoGrant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoGrant(v)
		return nil
	case approle.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, approle.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, approle.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedBy:
		return m.AddedCreatedBy()
	case approle.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case approle.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approle.FieldUpdatedBy) {
		fields = append(fields, approle.FieldUpdatedBy)
	}
	if m.FieldCleared(approle.FieldUpdatedAt) {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.FieldCleared(approle.FieldComments) {
		fields = append(fields, approle.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRoleMutation) ClearField(name string) error {
	switch name {
	case approle.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case approle.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case approle.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown AppRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRoleMutation) ResetField(name string) error {
	switch name {
	case approle.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case approle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approle.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case approle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approle.FieldAppID:
		m.ResetAppID()
		return nil
	case approle.FieldName:
		m.ResetName()
		return nil
	case approle.FieldComments:
		m.ResetComments()
		return nil
	case approle.FieldAutoGrant:
		m.ResetAutoGrant()
		return nil
	case approle.FieldEditable:
		m.ResetEditable()
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, approle.EdgeApp)
	}
	if m.policies != nil {
		edges = append(edges, approle.EdgePolicies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case approle.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case approle.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpolicies != nil {
		edges = append(edges, approle.EdgePolicies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case approle.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, approle.EdgeApp)
	}
	if m.clearedpolicies {
		edges = append(edges, approle.EdgePolicies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case approle.EdgeApp:
		return m.clearedapp
	case approle.EdgePolicies:
		return m.clearedpolicies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRoleMutation) ClearEdge(name string) error {
	switch name {
	case approle.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRoleMutation) ResetEdge(name string) error {
	switch name {
	case approle.EdgeApp:
		m.ResetApp()
		return nil
	case approle.EdgePolicies:
		m.ResetPolicies()
		return nil
	}
	return fmt.Errorf("unknown AppRole edge %s", name)
}

// AppRolePolicyMutation represents an operation that mutates the AppRolePolicy nodes in the graph.
type AppRolePolicyMutation struct {
	config
	op            Op
	typ           string
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	clearedFields map[string]struct{}
	role          *int
	clearedrole   bool
	policy        *int
	clearedpolicy bool
	done          bool
	oldValue      func(context.Context) (*AppRolePolicy, error)
	predicates    []predicate.AppRolePolicy
}

var _ ent.Mutation = (*AppRolePolicyMutation)(nil)

// approlepolicyOption allows management of the mutation configuration using functional options.
type approlepolicyOption func(*AppRolePolicyMutation)

// newAppRolePolicyMutation creates new mutation for the AppRolePolicy entity.
func newAppRolePolicyMutation(c config, op Op, opts ...approlepolicyOption) *AppRolePolicyMutation {
	m := &AppRolePolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRolePolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRolePolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRolePolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AppRolePolicyMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppRolePolicyMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppRolePolicyMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppRolePolicyMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppRolePolicyMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRolePolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRolePolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRolePolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppRolePolicyMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppRolePolicyMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppRolePolicyMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppRolePolicyMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppRolePolicyMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[approlepolicy.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppRolePolicyMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[approlepolicy.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppRolePolicyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, approlepolicy.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRolePolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRolePolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppRolePolicyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[approlepolicy.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppRolePolicyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[approlepolicy.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRolePolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, approlepolicy.FieldUpdatedAt)
}

// SetRoleID sets the "role_id" field.
func (m *AppRolePolicyMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AppRolePolicyMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AppRolePolicyMutation) ResetRoleID() {
	m.role = nil
}

// SetPolicyID sets the "policy_id" field.
func (m *AppRolePolicyMutation) SetPolicyID(i int) {
	m.policy = &i
}

// PolicyID returns the value of the "policy_id" field in the mutation.
func (m *AppRolePolicyMutation) PolicyID() (r int, exists bool) {
	v := m.policy
	if v == nil {
		return
	}
	return *v, true
}

// ResetPolicyID resets all changes to the "policy_id" field.
func (m *AppRolePolicyMutation) ResetPolicyID() {
	m.policy = nil
}

// ClearRole clears the "role" edge to the AppRole entity.
func (m *AppRolePolicyMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the AppRole entity was cleared.
func (m *AppRolePolicyMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *AppRolePolicyMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *AppRolePolicyMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// ClearPolicy clears the "policy" edge to the AppPolicy entity.
func (m *AppRolePolicyMutation) ClearPolicy() {
	m.clearedpolicy = true
}

// PolicyCleared reports if the "policy" edge to the AppPolicy entity was cleared.
func (m *AppRolePolicyMutation) PolicyCleared() bool {
	return m.clearedpolicy
}

// PolicyIDs returns the "policy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PolicyID instead. It exists only for internal usage by the builders.
func (m *AppRolePolicyMutation) PolicyIDs() (ids []int) {
	if id := m.policy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPolicy resets all changes to the "policy" edge.
func (m *AppRolePolicyMutation) ResetPolicy() {
	m.policy = nil
	m.clearedpolicy = false
}

// Where appends a list predicates to the AppRolePolicyMutation builder.
func (m *AppRolePolicyMutation) Where(ps ...predicate.AppRolePolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppRolePolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppRolePolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRolePolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppRolePolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppRolePolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRolePolicy).
func (m *AppRolePolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRolePolicyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_by != nil {
		fields = append(fields, approlepolicy.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, approlepolicy.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, approlepolicy.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, approlepolicy.FieldUpdatedAt)
	}
	if m.role != nil {
		fields = append(fields, approlepolicy.FieldRoleID)
	}
	if m.policy != nil {
		fields = append(fields, approlepolicy.FieldPolicyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRolePolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approlepolicy.FieldCreatedBy:
		return m.CreatedBy()
	case approlepolicy.FieldCreatedAt:
		return m.CreatedAt()
	case approlepolicy.FieldUpdatedBy:
		return m.UpdatedBy()
	case approlepolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case approlepolicy.FieldRoleID:
		return m.RoleID()
	case approlepolicy.FieldPolicyID:
		return m.PolicyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRolePolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema AppRolePolicy does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRolePolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approlepolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case approlepolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approlepolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case approlepolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approlepolicy.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case approlepolicy.FieldPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicyID(v)
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRolePolicyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, approlepolicy.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, approlepolicy.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRolePolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approlepolicy.FieldCreatedBy:
		return m.AddedCreatedBy()
	case approlepolicy.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRolePolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approlepolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case approlepolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRolePolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approlepolicy.FieldUpdatedBy) {
		fields = append(fields, approlepolicy.FieldUpdatedBy)
	}
	if m.FieldCleared(approlepolicy.FieldUpdatedAt) {
		fields = append(fields, approlepolicy.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRolePolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRolePolicyMutation) ClearField(name string) error {
	switch name {
	case approlepolicy.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case approlepolicy.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRolePolicyMutation) ResetField(name string) error {
	switch name {
	case approlepolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case approlepolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approlepolicy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case approlepolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approlepolicy.FieldRoleID:
		m.ResetRoleID()
		return nil
	case approlepolicy.FieldPolicyID:
		m.ResetPolicyID()
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRolePolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.role != nil {
		edges = append(edges, approlepolicy.EdgeRole)
	}
	if m.policy != nil {
		edges = append(edges, approlepolicy.EdgePolicy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRolePolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case approlepolicy.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case approlepolicy.EdgePolicy:
		if id := m.policy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRolePolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRolePolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRolePolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrole {
		edges = append(edges, approlepolicy.EdgeRole)
	}
	if m.clearedpolicy {
		edges = append(edges, approlepolicy.EdgePolicy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRolePolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case approlepolicy.EdgeRole:
		return m.clearedrole
	case approlepolicy.EdgePolicy:
		return m.clearedpolicy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRolePolicyMutation) ClearEdge(name string) error {
	switch name {
	case approlepolicy.EdgeRole:
		m.ClearRole()
		return nil
	case approlepolicy.EdgePolicy:
		m.ClearPolicy()
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRolePolicyMutation) ResetEdge(name string) error {
	switch name {
	case approlepolicy.EdgeRole:
		m.ResetRole()
		return nil
	case approlepolicy.EdgePolicy:
		m.ResetPolicy()
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_by               *int
	addcreated_by            *int
	created_at               *time.Time
	updated_by               *int
	addupdated_by            *int
	updated_at               *time.Time
	deleted_at               *time.Time
	kind                     *organization.Kind
	domain                   *string
	code                     *string
	name                     *string
	profile                  *string
	status                   *typex.SimpleStatus
	_path                    *string
	display_sort             *int32
	adddisplay_sort          *int32
	country_code             *string
	timezone                 *string
	clearedFields            map[string]struct{}
	parent                   *int
	clearedparent            bool
	children                 map[int]struct{}
	removedchildren          map[int]struct{}
	clearedchildren          bool
	owner                    *int
	clearedowner             bool
	users                    map[int]struct{}
	removedusers             map[int]struct{}
	clearedusers             bool
	rolesAndGroups           map[int]struct{}
	removedrolesAndGroups    map[int]struct{}
	clearedrolesAndGroups    bool
	permissions              map[int]struct{}
	removedpermissions       map[int]struct{}
	clearedpermissions       bool
	policies                 map[int]struct{}
	removedpolicies          map[int]struct{}
	clearedpolicies          bool
	apps                     map[int]struct{}
	removedapps              map[int]struct{}
	clearedapps              bool
	organization_user        map[int]struct{}
	removedorganization_user map[int]struct{}
	clearedorganization_user bool
	done                     bool
	oldValue                 func(context.Context) (*Organization, error)
	predicates               []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id int) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrganizationMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrganizationMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrganizationMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrganizationMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[organization.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, organization.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organization.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organization.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrganizationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrganizationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrganizationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[organization.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrganizationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[organization.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrganizationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, organization.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *OrganizationMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *OrganizationMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *OrganizationMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[organization.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *OrganizationMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *OrganizationMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, organization.FieldOwnerID)
}

// SetKind sets the "kind" field.
func (m *OrganizationMutation) SetKind(o organization.Kind) {
	m.kind = &o
}

// Kind returns the value of the "kind" field in the mutation.
func (m *OrganizationMutation) Kind() (r organization.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldKind(ctx context.Context) (v organization.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ClearKind clears the value of the "kind" field.
func (m *OrganizationMutation) ClearKind() {
	m.kind = nil
	m.clearedFields[organization.FieldKind] = struct{}{}
}

// KindCleared returns if the "kind" field was cleared in this mutation.
func (m *OrganizationMutation) KindCleared() bool {
	_, ok := m.clearedFields[organization.FieldKind]
	return ok
}

// ResetKind resets all changes to the "kind" field.
func (m *OrganizationMutation) ResetKind() {
	m.kind = nil
	delete(m.clearedFields, organization.FieldKind)
}

// SetParentID sets the "parent_id" field.
func (m *OrganizationMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *OrganizationMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *OrganizationMutation) ResetParentID() {
	m.parent = nil
}

// SetDomain sets the "domain" field.
func (m *OrganizationMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *OrganizationMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *OrganizationMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[organization.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *OrganizationMutation) DomainCleared() bool {
	_, ok := m.clearedFields[organization.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *OrganizationMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, organization.FieldDomain)
}

// SetCode sets the "code" field.
func (m *OrganizationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OrganizationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *OrganizationMutation) ClearCode() {
	m.code = nil
	m.clearedFields[organization.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *OrganizationMutation) CodeCleared() bool {
	_, ok := m.clearedFields[organization.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *OrganizationMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, organization.FieldCode)
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetProfile sets the "profile" field.
func (m *OrganizationMutation) SetProfile(s string) {
	m.profile = &s
}

// Profile returns the value of the "profile" field in the mutation.
func (m *OrganizationMutation) Profile() (r string, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldProfile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *OrganizationMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[organization.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *OrganizationMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[organization.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *OrganizationMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, organization.FieldProfile)
}

// SetStatus sets the "status" field.
func (m *OrganizationMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *OrganizationMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[organization.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrganizationMutation) StatusCleared() bool {
	_, ok := m.clearedFields[organization.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, organization.FieldStatus)
}

// SetPath sets the "path" field.
func (m *OrganizationMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *OrganizationMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *OrganizationMutation) ClearPath() {
	m._path = nil
	m.clearedFields[organization.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *OrganizationMutation) PathCleared() bool {
	_, ok := m.clearedFields[organization.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *OrganizationMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, organization.FieldPath)
}

// SetDisplaySort sets the "display_sort" field.
func (m *OrganizationMutation) SetDisplaySort(i int32) {
	m.display_sort = &i
	m.adddisplay_sort = nil
}

// DisplaySort returns the value of the "display_sort" field in the mutation.
func (m *OrganizationMutation) DisplaySort() (r int32, exists bool) {
	v := m.display_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplaySort returns the old "display_sort" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDisplaySort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplaySort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplaySort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplaySort: %w", err)
	}
	return oldValue.DisplaySort, nil
}

// AddDisplaySort adds i to the "display_sort" field.
func (m *OrganizationMutation) AddDisplaySort(i int32) {
	if m.adddisplay_sort != nil {
		*m.adddisplay_sort += i
	} else {
		m.adddisplay_sort = &i
	}
}

// AddedDisplaySort returns the value that was added to the "display_sort" field in this mutation.
func (m *OrganizationMutation) AddedDisplaySort() (r int32, exists bool) {
	v := m.adddisplay_sort
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplaySort clears the value of the "display_sort" field.
func (m *OrganizationMutation) ClearDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	m.clearedFields[organization.FieldDisplaySort] = struct{}{}
}

// DisplaySortCleared returns if the "display_sort" field was cleared in this mutation.
func (m *OrganizationMutation) DisplaySortCleared() bool {
	_, ok := m.clearedFields[organization.FieldDisplaySort]
	return ok
}

// ResetDisplaySort resets all changes to the "display_sort" field.
func (m *OrganizationMutation) ResetDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	delete(m.clearedFields, organization.FieldDisplaySort)
}

// SetCountryCode sets the "country_code" field.
func (m *OrganizationMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *OrganizationMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *OrganizationMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[organization.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *OrganizationMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[organization.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *OrganizationMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, organization.FieldCountryCode)
}

// SetTimezone sets the "timezone" field.
func (m *OrganizationMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OrganizationMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *OrganizationMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[organization.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *OrganizationMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[organization.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OrganizationMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, organization.FieldTimezone)
}

// ClearParent clears the "parent" edge to the Organization entity.
func (m *OrganizationMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Organization entity was cleared.
func (m *OrganizationMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OrganizationMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Organization entity by ids.
func (m *OrganizationMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Organization entity.
func (m *OrganizationMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Organization entity was cleared.
func (m *OrganizationMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Organization entity by IDs.
func (m *OrganizationMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Organization entity.
func (m *OrganizationMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *OrganizationMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *OrganizationMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *OrganizationMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *OrganizationMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OrganizationMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *OrganizationMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OrganizationMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OrganizationMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *OrganizationMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *OrganizationMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *OrganizationMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OrganizationMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddRolesAndGroupIDs adds the "rolesAndGroups" edge to the OrganizationRole entity by ids.
func (m *OrganizationMutation) AddRolesAndGroupIDs(ids ...int) {
	if m.rolesAndGroups == nil {
		m.rolesAndGroups = make(map[int]struct{})
	}
	for i := range ids {
		m.rolesAndGroups[ids[i]] = struct{}{}
	}
}

// ClearRolesAndGroups clears the "rolesAndGroups" edge to the OrganizationRole entity.
func (m *OrganizationMutation) ClearRolesAndGroups() {
	m.clearedrolesAndGroups = true
}

// RolesAndGroupsCleared reports if the "rolesAndGroups" edge to the OrganizationRole entity was cleared.
func (m *OrganizationMutation) RolesAndGroupsCleared() bool {
	return m.clearedrolesAndGroups
}

// RemoveRolesAndGroupIDs removes the "rolesAndGroups" edge to the OrganizationRole entity by IDs.
func (m *OrganizationMutation) RemoveRolesAndGroupIDs(ids ...int) {
	if m.removedrolesAndGroups == nil {
		m.removedrolesAndGroups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rolesAndGroups, ids[i])
		m.removedrolesAndGroups[ids[i]] = struct{}{}
	}
}

// RemovedRolesAndGroups returns the removed IDs of the "rolesAndGroups" edge to the OrganizationRole entity.
func (m *OrganizationMutation) RemovedRolesAndGroupsIDs() (ids []int) {
	for id := range m.removedrolesAndGroups {
		ids = append(ids, id)
	}
	return
}

// RolesAndGroupsIDs returns the "rolesAndGroups" edge IDs in the mutation.
func (m *OrganizationMutation) RolesAndGroupsIDs() (ids []int) {
	for id := range m.rolesAndGroups {
		ids = append(ids, id)
	}
	return
}

// ResetRolesAndGroups resets all changes to the "rolesAndGroups" edge.
func (m *OrganizationMutation) ResetRolesAndGroups() {
	m.rolesAndGroups = nil
	m.clearedrolesAndGroups = false
	m.removedrolesAndGroups = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *OrganizationMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *OrganizationMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *OrganizationMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *OrganizationMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *OrganizationMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *OrganizationMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *OrganizationMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddPolicyIDs adds the "policies" edge to the OrganizationPolicy entity by ids.
func (m *OrganizationMutation) AddPolicyIDs(ids ...int) {
	if m.policies == nil {
		m.policies = make(map[int]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the "policies" edge to the OrganizationPolicy entity.
func (m *OrganizationMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared reports if the "policies" edge to the OrganizationPolicy entity was cleared.
func (m *OrganizationMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the "policies" edge to the OrganizationPolicy entity by IDs.
func (m *OrganizationMutation) RemovePolicyIDs(ids ...int) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.policies, ids[i])
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed IDs of the "policies" edge to the OrganizationPolicy entity.
func (m *OrganizationMutation) RemovedPoliciesIDs() (ids []int) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the "policies" edge IDs in the mutation.
func (m *OrganizationMutation) PoliciesIDs() (ids []int) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies resets all changes to the "policies" edge.
func (m *OrganizationMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// AddAppIDs adds the "apps" edge to the App entity by ids.
func (m *OrganizationMutation) AddAppIDs(ids ...int) {
	if m.apps == nil {
		m.apps = make(map[int]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the App entity.
func (m *OrganizationMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the App entity was cleared.
func (m *OrganizationMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the App entity by IDs.
func (m *OrganizationMutation) RemoveAppIDs(ids ...int) {
	if m.removedapps == nil {
		m.removedapps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the App entity.
func (m *OrganizationMutation) RemovedAppsIDs() (ids []int) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *OrganizationMutation) AppsIDs() (ids []int) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *OrganizationMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// AddOrganizationUserIDs adds the "organization_user" edge to the OrganizationUser entity by ids.
func (m *OrganizationMutation) AddOrganizationUserIDs(ids ...int) {
	if m.organization_user == nil {
		m.organization_user = make(map[int]struct{})
	}
	for i := range ids {
		m.organization_user[ids[i]] = struct{}{}
	}
}

// ClearOrganizationUser clears the "organization_user" edge to the OrganizationUser entity.
func (m *OrganizationMutation) ClearOrganizationUser() {
	m.clearedorganization_user = true
}

// OrganizationUserCleared reports if the "organization_user" edge to the OrganizationUser entity was cleared.
func (m *OrganizationMutation) OrganizationUserCleared() bool {
	return m.clearedorganization_user
}

// RemoveOrganizationUserIDs removes the "organization_user" edge to the OrganizationUser entity by IDs.
func (m *OrganizationMutation) RemoveOrganizationUserIDs(ids ...int) {
	if m.removedorganization_user == nil {
		m.removedorganization_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organization_user, ids[i])
		m.removedorganization_user[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationUser returns the removed IDs of the "organization_user" edge to the OrganizationUser entity.
func (m *OrganizationMutation) RemovedOrganizationUserIDs() (ids []int) {
	for id := range m.removedorganization_user {
		ids = append(ids, id)
	}
	return
}

// OrganizationUserIDs returns the "organization_user" edge IDs in the mutation.
func (m *OrganizationMutation) OrganizationUserIDs() (ids []int) {
	for id := range m.organization_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationUser resets all changes to the "organization_user" edge.
func (m *OrganizationMutation) ResetOrganizationUser() {
	m.organization_user = nil
	m.clearedorganization_user = false
	m.removedorganization_user = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_by != nil {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.owner != nil {
		fields = append(fields, organization.FieldOwnerID)
	}
	if m.kind != nil {
		fields = append(fields, organization.FieldKind)
	}
	if m.parent != nil {
		fields = append(fields, organization.FieldParentID)
	}
	if m.domain != nil {
		fields = append(fields, organization.FieldDomain)
	}
	if m.code != nil {
		fields = append(fields, organization.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.profile != nil {
		fields = append(fields, organization.FieldProfile)
	}
	if m.status != nil {
		fields = append(fields, organization.FieldStatus)
	}
	if m._path != nil {
		fields = append(fields, organization.FieldPath)
	}
	if m.display_sort != nil {
		fields = append(fields, organization.FieldDisplaySort)
	}
	if m.country_code != nil {
		fields = append(fields, organization.FieldCountryCode)
	}
	if m.timezone != nil {
		fields = append(fields, organization.FieldTimezone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedBy:
		return m.CreatedBy()
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedBy:
		return m.UpdatedBy()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldDeletedAt:
		return m.DeletedAt()
	case organization.FieldOwnerID:
		return m.OwnerID()
	case organization.FieldKind:
		return m.Kind()
	case organization.FieldParentID:
		return m.ParentID()
	case organization.FieldDomain:
		return m.Domain()
	case organization.FieldCode:
		return m.Code()
	case organization.FieldName:
		return m.Name()
	case organization.FieldProfile:
		return m.Profile()
	case organization.FieldStatus:
		return m.Status()
	case organization.FieldPath:
		return m.Path()
	case organization.FieldDisplaySort:
		return m.DisplaySort()
	case organization.FieldCountryCode:
		return m.CountryCode()
	case organization.FieldTimezone:
		return m.Timezone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case organization.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case organization.FieldKind:
		return m.OldKind(ctx)
	case organization.FieldParentID:
		return m.OldParentID(ctx)
	case organization.FieldDomain:
		return m.OldDomain(ctx)
	case organization.FieldCode:
		return m.OldCode(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldProfile:
		return m.OldProfile(ctx)
	case organization.FieldStatus:
		return m.OldStatus(ctx)
	case organization.FieldPath:
		return m.OldPath(ctx)
	case organization.FieldDisplaySort:
		return m.OldDisplaySort(ctx)
	case organization.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case organization.FieldTimezone:
		return m.OldTimezone(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case organization.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case organization.FieldKind:
		v, ok := value.(organization.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case organization.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case organization.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case organization.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldProfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case organization.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organization.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case organization.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplaySort(v)
		return nil
	case organization.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case organization.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.adddisplay_sort != nil {
		fields = append(fields, organization.FieldDisplaySort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedBy:
		return m.AddedCreatedBy()
	case organization.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case organization.FieldDisplaySort:
		return m.AddedDisplaySort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case organization.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case organization.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplaySort(v)
		return nil
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldUpdatedBy) {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.FieldCleared(organization.FieldUpdatedAt) {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.FieldCleared(organization.FieldDeletedAt) {
		fields = append(fields, organization.FieldDeletedAt)
	}
	if m.FieldCleared(organization.FieldOwnerID) {
		fields = append(fields, organization.FieldOwnerID)
	}
	if m.FieldCleared(organization.FieldKind) {
		fields = append(fields, organization.FieldKind)
	}
	if m.FieldCleared(organization.FieldDomain) {
		fields = append(fields, organization.FieldDomain)
	}
	if m.FieldCleared(organization.FieldCode) {
		fields = append(fields, organization.FieldCode)
	}
	if m.FieldCleared(organization.FieldProfile) {
		fields = append(fields, organization.FieldProfile)
	}
	if m.FieldCleared(organization.FieldStatus) {
		fields = append(fields, organization.FieldStatus)
	}
	if m.FieldCleared(organization.FieldPath) {
		fields = append(fields, organization.FieldPath)
	}
	if m.FieldCleared(organization.FieldDisplaySort) {
		fields = append(fields, organization.FieldDisplaySort)
	}
	if m.FieldCleared(organization.FieldCountryCode) {
		fields = append(fields, organization.FieldCountryCode)
	}
	if m.FieldCleared(organization.FieldTimezone) {
		fields = append(fields, organization.FieldTimezone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organization.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case organization.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case organization.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case organization.FieldKind:
		m.ClearKind()
		return nil
	case organization.FieldDomain:
		m.ClearDomain()
		return nil
	case organization.FieldCode:
		m.ClearCode()
		return nil
	case organization.FieldProfile:
		m.ClearProfile()
		return nil
	case organization.FieldStatus:
		m.ClearStatus()
		return nil
	case organization.FieldPath:
		m.ClearPath()
		return nil
	case organization.FieldDisplaySort:
		m.ClearDisplaySort()
		return nil
	case organization.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	case organization.FieldTimezone:
		m.ClearTimezone()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case organization.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case organization.FieldKind:
		m.ResetKind()
		return nil
	case organization.FieldParentID:
		m.ResetParentID()
		return nil
	case organization.FieldDomain:
		m.ResetDomain()
		return nil
	case organization.FieldCode:
		m.ResetCode()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldProfile:
		m.ResetProfile()
		return nil
	case organization.FieldStatus:
		m.ResetStatus()
		return nil
	case organization.FieldPath:
		m.ResetPath()
		return nil
	case organization.FieldDisplaySort:
		m.ResetDisplaySort()
		return nil
	case organization.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case organization.FieldTimezone:
		m.ResetTimezone()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.parent != nil {
		edges = append(edges, organization.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.owner != nil {
		edges = append(edges, organization.EdgeOwner)
	}
	if m.users != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.rolesAndGroups != nil {
		edges = append(edges, organization.EdgeRolesAndGroups)
	}
	if m.permissions != nil {
		edges = append(edges, organization.EdgePermissions)
	}
	if m.policies != nil {
		edges = append(edges, organization.EdgePolicies)
	}
	if m.apps != nil {
		edges = append(edges, organization.EdgeApps)
	}
	if m.organization_user != nil {
		edges = append(edges, organization.EdgeOrganizationUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeRolesAndGroups:
		ids := make([]ent.Value, 0, len(m.rolesAndGroups))
		for id := range m.rolesAndGroups {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOrganizationUser:
		ids := make([]ent.Value, 0, len(m.organization_user))
		for id := range m.organization_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedchildren != nil {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.removedusers != nil {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.removedrolesAndGroups != nil {
		edges = append(edges, organization.EdgeRolesAndGroups)
	}
	if m.removedpermissions != nil {
		edges = append(edges, organization.EdgePermissions)
	}
	if m.removedpolicies != nil {
		edges = append(edges, organization.EdgePolicies)
	}
	if m.removedapps != nil {
		edges = append(edges, organization.EdgeApps)
	}
	if m.removedorganization_user != nil {
		edges = append(edges, organization.EdgeOrganizationUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeRolesAndGroups:
		ids := make([]ent.Value, 0, len(m.removedrolesAndGroups))
		for id := range m.removedrolesAndGroups {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeOrganizationUser:
		ids := make([]ent.Value, 0, len(m.removedorganization_user))
		for id := range m.removedorganization_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedparent {
		edges = append(edges, organization.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.clearedowner {
		edges = append(edges, organization.EdgeOwner)
	}
	if m.clearedusers {
		edges = append(edges, organization.EdgeUsers)
	}
	if m.clearedrolesAndGroups {
		edges = append(edges, organization.EdgeRolesAndGroups)
	}
	if m.clearedpermissions {
		edges = append(edges, organization.EdgePermissions)
	}
	if m.clearedpolicies {
		edges = append(edges, organization.EdgePolicies)
	}
	if m.clearedapps {
		edges = append(edges, organization.EdgeApps)
	}
	if m.clearedorganization_user {
		edges = append(edges, organization.EdgeOrganizationUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeParent:
		return m.clearedparent
	case organization.EdgeChildren:
		return m.clearedchildren
	case organization.EdgeOwner:
		return m.clearedowner
	case organization.EdgeUsers:
		return m.clearedusers
	case organization.EdgeRolesAndGroups:
		return m.clearedrolesAndGroups
	case organization.EdgePermissions:
		return m.clearedpermissions
	case organization.EdgePolicies:
		return m.clearedpolicies
	case organization.EdgeApps:
		return m.clearedapps
	case organization.EdgeOrganizationUser:
		return m.clearedorganization_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeParent:
		m.ClearParent()
		return nil
	case organization.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeParent:
		m.ResetParent()
		return nil
	case organization.EdgeChildren:
		m.ResetChildren()
		return nil
	case organization.EdgeOwner:
		m.ResetOwner()
		return nil
	case organization.EdgeUsers:
		m.ResetUsers()
		return nil
	case organization.EdgeRolesAndGroups:
		m.ResetRolesAndGroups()
		return nil
	case organization.EdgePermissions:
		m.ResetPermissions()
		return nil
	case organization.EdgePolicies:
		m.ResetPolicies()
		return nil
	case organization.EdgeApps:
		m.ResetApps()
		return nil
	case organization.EdgeOrganizationUser:
		m.ResetOrganizationUser()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationAppMutation represents an operation that mutates the OrganizationApp nodes in the graph.
type OrganizationAppMutation struct {
	config
	op                  Op
	typ                 string
	created_by          *int
	addcreated_by       *int
	created_at          *time.Time
	updated_by          *int
	addupdated_by       *int
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	app                 *int
	clearedapp          bool
	organization        *int
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*OrganizationApp, error)
	predicates          []predicate.OrganizationApp
}

var _ ent.Mutation = (*OrganizationAppMutation)(nil)

// organizationappOption allows management of the mutation configuration using functional options.
type organizationappOption func(*OrganizationAppMutation)

// newOrganizationAppMutation creates new mutation for the OrganizationApp entity.
func newOrganizationAppMutation(c config, op Op, opts ...organizationappOption) *OrganizationAppMutation {
	m := &OrganizationAppMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationAppMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationAppMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrganizationAppMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrganizationAppMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationAppMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationAppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationAppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationAppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationAppMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationAppMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrganizationAppMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrganizationAppMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationAppMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[organizationapp.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationAppMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationapp.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationAppMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, organizationapp.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationAppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationAppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationAppMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organizationapp.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationAppMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationapp.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationAppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organizationapp.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *OrganizationAppMutation) SetOrgID(i int) {
	m.organization = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrganizationAppMutation) OrgID() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrganizationAppMutation) ResetOrgID() {
	m.organization = nil
}

// SetAppID sets the "app_id" field.
func (m *OrganizationAppMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *OrganizationAppMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *OrganizationAppMutation) ResetAppID() {
	m.app = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *OrganizationAppMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *OrganizationAppMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *OrganizationAppMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *OrganizationAppMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *OrganizationAppMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationAppMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationAppMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *OrganizationAppMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationAppMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationAppMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the OrganizationAppMutation builder.
func (m *OrganizationAppMutation) Where(ps ...predicate.OrganizationApp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationAppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationAppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationApp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationAppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationAppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationApp).
func (m *OrganizationAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationAppMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_by != nil {
		fields = append(fields, organizationapp.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, organizationapp.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationapp.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationapp.FieldUpdatedAt)
	}
	if m.organization != nil {
		fields = append(fields, organizationapp.FieldOrgID)
	}
	if m.app != nil {
		fields = append(fields, organizationapp.FieldAppID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationapp.FieldCreatedBy:
		return m.CreatedBy()
	case organizationapp.FieldCreatedAt:
		return m.CreatedAt()
	case organizationapp.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationapp.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationapp.FieldOrgID:
		return m.OrgID()
	case organizationapp.FieldAppID:
		return m.AppID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema OrganizationApp does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationapp.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationapp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationapp.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationapp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationapp.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case organizationapp.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationAppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, organizationapp.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, organizationapp.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationAppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organizationapp.FieldCreatedBy:
		return m.AddedCreatedBy()
	case organizationapp.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organizationapp.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case organizationapp.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationAppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationapp.FieldUpdatedBy) {
		fields = append(fields, organizationapp.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationapp.FieldUpdatedAt) {
		fields = append(fields, organizationapp.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationAppMutation) ClearField(name string) error {
	switch name {
	case organizationapp.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationapp.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationAppMutation) ResetField(name string) error {
	switch name {
	case organizationapp.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationapp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationapp.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationapp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationapp.FieldOrgID:
		m.ResetOrgID()
		return nil
	case organizationapp.FieldAppID:
		m.ResetAppID()
		return nil
	}
	return fmt.Errorf("unknown OrganizationApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, organizationapp.EdgeApp)
	}
	if m.organization != nil {
		edges = append(edges, organizationapp.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationAppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationapp.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case organizationapp.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationAppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, organizationapp.EdgeApp)
	}
	if m.clearedorganization {
		edges = append(edges, organizationapp.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationAppMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationapp.EdgeApp:
		return m.clearedapp
	case organizationapp.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationAppMutation) ClearEdge(name string) error {
	switch name {
	case organizationapp.EdgeApp:
		m.ClearApp()
		return nil
	case organizationapp.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationAppMutation) ResetEdge(name string) error {
	switch name {
	case organizationapp.EdgeApp:
		m.ResetApp()
		return nil
	case organizationapp.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationApp edge %s", name)
}

// OrganizationPolicyMutation represents an operation that mutates the OrganizationPolicy nodes in the graph.
type OrganizationPolicyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_by          *int
	addcreated_by       *int
	created_at          *time.Time
	updated_by          *int
	addupdated_by       *int
	updated_at          *time.Time
	app_id              *int
	addapp_id           *int
	app_policy_id       *int
	addapp_policy_id    *int
	name                *string
	comments            *string
	rules               *[]types.PolicyRule
	appendrules         []types.PolicyRule
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*OrganizationPolicy, error)
	predicates          []predicate.OrganizationPolicy
}

var _ ent.Mutation = (*OrganizationPolicyMutation)(nil)

// organizationpolicyOption allows management of the mutation configuration using functional options.
type organizationpolicyOption func(*OrganizationPolicyMutation)

// newOrganizationPolicyMutation creates new mutation for the OrganizationPolicy entity.
func newOrganizationPolicyMutation(c config, op Op, opts ...organizationpolicyOption) *OrganizationPolicyMutation {
	m := &OrganizationPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationPolicyID sets the ID field of the mutation.
func withOrganizationPolicyID(id int) organizationpolicyOption {
	return func(m *OrganizationPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationPolicy
		)
		m.oldValue = func(ctx context.Context) (*OrganizationPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationPolicy sets the old OrganizationPolicy of the mutation.
func withOrganizationPolicy(node *OrganizationPolicy) organizationpolicyOption {
	return func(m *OrganizationPolicyMutation) {
		m.oldValue = func(context.Context) (*OrganizationPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationPolicy entities.
func (m *OrganizationPolicyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationPolicyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationPolicyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationPolicyMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationPolicyMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrganizationPolicy entity.
// If the OrganizationPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationPolicyMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrganizationPolicyMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrganizationPolicyMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationPolicyMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationPolicy entity.
// If the OrganizationPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationPolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationPolicyMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationPolicyMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrganizationPolicy entity.
// If the OrganizationPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationPolicyMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrganizationPolicyMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrganizationPolicyMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationPolicyMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[organizationpolicy.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationPolicyMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationpolicy.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationPolicyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, organizationpolicy.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationPolicy entity.
// If the OrganizationPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationPolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationPolicyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organizationpolicy.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationPolicyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationpolicy.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organizationpolicy.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *OrganizationPolicyMutation) SetOrgID(i int) {
	m.organization = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrganizationPolicyMutation) OrgID() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrganizationPolicy entity.
// If the OrganizationPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationPolicyMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrganizationPolicyMutation) ResetOrgID() {
	m.organization = nil
}

// SetAppID sets the "app_id" field.
func (m *OrganizationPolicyMutation) SetAppID(i int) {
	m.app_id = &i
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *OrganizationPolicyMutation) AppID() (r int, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the OrganizationPolicy entity.
// If the OrganizationPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationPolicyMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds i to the "app_id" field.
func (m *OrganizationPolicyMutation) AddAppID(i int) {
	if m.addapp_id != nil {
		*m.addapp_id += i
	} else {
		m.addapp_id = &i
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *OrganizationPolicyMutation) AddedAppID() (r int, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppID clears the value of the "app_id" field.
func (m *OrganizationPolicyMutation) ClearAppID() {
	m.app_id = nil
	m.addapp_id = nil
	m.clearedFields[organizationpolicy.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *OrganizationPolicyMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[organizationpolicy.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *OrganizationPolicyMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
	delete(m.clearedFields, organizationpolicy.FieldAppID)
}

// SetAppPolicyID sets the "app_policy_id" field.
func (m *OrganizationPolicyMutation) SetAppPolicyID(i int) {
	m.app_policy_id = &i
	m.addapp_policy_id = nil
}

// AppPolicyID returns the value of the "app_policy_id" field in the mutation.
func (m *OrganizationPolicyMutation) AppPolicyID() (r int, exists bool) {
	v := m.app_policy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppPolicyID returns the old "app_policy_id" field's value of the OrganizationPolicy entity.
// If the OrganizationPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationPolicyMutation) OldAppPolicyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppPolicyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppPolicyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppPolicyID: %w", err)
	}
	return oldValue.AppPolicyID, nil
}

// AddAppPolicyID adds i to the "app_policy_id" field.
func (m *OrganizationPolicyMutation) AddAppPolicyID(i int) {
	if m.addapp_policy_id != nil {
		*m.addapp_policy_id += i
	} else {
		m.addapp_policy_id = &i
	}
}

// AddedAppPolicyID returns the value that was added to the "app_policy_id" field in this mutation.
func (m *OrganizationPolicyMutation) AddedAppPolicyID() (r int, exists bool) {
	v := m.addapp_policy_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppPolicyID clears the value of the "app_policy_id" field.
func (m *OrganizationPolicyMutation) ClearAppPolicyID() {
	m.app_policy_id = nil
	m.addapp_policy_id = nil
	m.clearedFields[organizationpolicy.FieldAppPolicyID] = struct{}{}
}

// AppPolicyIDCleared returns if the "app_policy_id" field was cleared in this mutation.
func (m *OrganizationPolicyMutation) AppPolicyIDCleared() bool {
	_, ok := m.clearedFields[organizationpolicy.FieldAppPolicyID]
	return ok
}

// ResetAppPolicyID resets all changes to the "app_policy_id" field.
func (m *OrganizationPolicyMutation) ResetAppPolicyID() {
	m.app_policy_id = nil
	m.addapp_policy_id = nil
	delete(m.clearedFields, organizationpolicy.FieldAppPolicyID)
}

// SetName sets the "name" field.
func (m *OrganizationPolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationPolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrganizationPolicy entity.
// If the OrganizationPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationPolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationPolicyMutation) ResetName() {
	m.name = nil
}

// SetComments sets the "comments" field.
func (m *OrganizationPolicyMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *OrganizationPolicyMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the OrganizationPolicy entity.
// If the OrganizationPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationPolicyMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ResetComments resets all changes to the "comments" field.
func (m *OrganizationPolicyMutation) ResetComments() {
	m.comments = nil
}

// SetRules sets the "rules" field.
func (m *OrganizationPolicyMutation) SetRules(tr []types.PolicyRule) {
	m.rules = &tr
	m.appendrules = nil
}

// Rules returns the value of the "rules" field in the mutation.
func (m *OrganizationPolicyMutation) Rules() (r []types.PolicyRule, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRules returns the old "rules" field's value of the OrganizationPolicy entity.
// If the OrganizationPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationPolicyMutation) OldRules(ctx context.Context) (v []types.PolicyRule, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRules: %w", err)
	}
	return oldValue.Rules, nil
}

// AppendRules adds tr to the "rules" field.
func (m *OrganizationPolicyMutation) AppendRules(tr []types.PolicyRule) {
	m.appendrules = append(m.appendrules, tr...)
}

// AppendedRules returns the list of values that were appended to the "rules" field in this mutation.
func (m *OrganizationPolicyMutation) AppendedRules() ([]types.PolicyRule, bool) {
	if len(m.appendrules) == 0 {
		return nil, false
	}
	return m.appendrules, true
}

// ResetRules resets all changes to the "rules" field.
func (m *OrganizationPolicyMutation) ResetRules() {
	m.rules = nil
	m.appendrules = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *OrganizationPolicyMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationPolicyMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationPolicyMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *OrganizationPolicyMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationPolicyMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationPolicyMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the OrganizationPolicyMutation builder.
func (m *OrganizationPolicyMutation) Where(ps ...predicate.OrganizationPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationPolicy).
func (m *OrganizationPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationPolicyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, organizationpolicy.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, organizationpolicy.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationpolicy.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationpolicy.FieldUpdatedAt)
	}
	if m.organization != nil {
		fields = append(fields, organizationpolicy.FieldOrgID)
	}
	if m.app_id != nil {
		fields = append(fields, organizationpolicy.FieldAppID)
	}
	if m.app_policy_id != nil {
		fields = append(fields, organizationpolicy.FieldAppPolicyID)
	}
	if m.name != nil {
		fields = append(fields, organizationpolicy.FieldName)
	}
	if m.comments != nil {
		fields = append(fields, organizationpolicy.FieldComments)
	}
	if m.rules != nil {
		fields = append(fields, organizationpolicy.FieldRules)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationpolicy.FieldCreatedBy:
		return m.CreatedBy()
	case organizationpolicy.FieldCreatedAt:
		return m.CreatedAt()
	case organizationpolicy.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationpolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationpolicy.FieldOrgID:
		return m.OrgID()
	case organizationpolicy.FieldAppID:
		return m.AppID()
	case organizationpolicy.FieldAppPolicyID:
		return m.AppPolicyID()
	case organizationpolicy.FieldName:
		return m.Name()
	case organizationpolicy.FieldComments:
		return m.Comments()
	case organizationpolicy.FieldRules:
		return m.Rules()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationpolicy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organizationpolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationpolicy.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organizationpolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationpolicy.FieldOrgID:
		return m.OldOrgID(ctx)
	case organizationpolicy.FieldAppID:
		return m.OldAppID(ctx)
	case organizationpolicy.FieldAppPolicyID:
		return m.OldAppPolicyID(ctx)
	case organizationpolicy.FieldName:
		return m.OldName(ctx)
	case organizationpolicy.FieldComments:
		return m.OldComments(ctx)
	case organizationpolicy.FieldRules:
		return m.OldRules(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationpolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationpolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationpolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationpolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationpolicy.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case organizationpolicy.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case organizationpolicy.FieldAppPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppPolicyID(v)
		return nil
	case organizationpolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organizationpolicy.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case organizationpolicy.FieldRules:
		v, ok := value.([]types.PolicyRule)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRules(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationPolicyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, organizationpolicy.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, organizationpolicy.FieldUpdatedBy)
	}
	if m.addapp_id != nil {
		fields = append(fields, organizationpolicy.FieldAppID)
	}
	if m.addapp_policy_id != nil {
		fields = append(fields, organizationpolicy.FieldAppPolicyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationPolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organizationpolicy.FieldCreatedBy:
		return m.AddedCreatedBy()
	case organizationpolicy.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case organizationpolicy.FieldAppID:
		return m.AddedAppID()
	case organizationpolicy.FieldAppPolicyID:
		return m.AddedAppPolicyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organizationpolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case organizationpolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case organizationpolicy.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	case organizationpolicy.FieldAppPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppPolicyID(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationpolicy.FieldUpdatedBy) {
		fields = append(fields, organizationpolicy.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationpolicy.FieldUpdatedAt) {
		fields = append(fields, organizationpolicy.FieldUpdatedAt)
	}
	if m.FieldCleared(organizationpolicy.FieldAppID) {
		fields = append(fields, organizationpolicy.FieldAppID)
	}
	if m.FieldCleared(organizationpolicy.FieldAppPolicyID) {
		fields = append(fields, organizationpolicy.FieldAppPolicyID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationPolicyMutation) ClearField(name string) error {
	switch name {
	case organizationpolicy.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationpolicy.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case organizationpolicy.FieldAppID:
		m.ClearAppID()
		return nil
	case organizationpolicy.FieldAppPolicyID:
		m.ClearAppPolicyID()
		return nil
	}
	return fmt.Errorf("unknown OrganizationPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationPolicyMutation) ResetField(name string) error {
	switch name {
	case organizationpolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationpolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationpolicy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationpolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationpolicy.FieldOrgID:
		m.ResetOrgID()
		return nil
	case organizationpolicy.FieldAppID:
		m.ResetAppID()
		return nil
	case organizationpolicy.FieldAppPolicyID:
		m.ResetAppPolicyID()
		return nil
	case organizationpolicy.FieldName:
		m.ResetName()
		return nil
	case organizationpolicy.FieldComments:
		m.ResetComments()
		return nil
	case organizationpolicy.FieldRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown OrganizationPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization != nil {
		edges = append(edges, organizationpolicy.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationPolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationpolicy.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationPolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization {
		edges = append(edges, organizationpolicy.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationPolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationpolicy.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationPolicyMutation) ClearEdge(name string) error {
	switch name {
	case organizationpolicy.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationPolicyMutation) ResetEdge(name string) error {
	switch name {
	case organizationpolicy.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationPolicy edge %s", name)
}

// OrganizationRoleMutation represents an operation that mutates the OrganizationRole nodes in the graph.
type OrganizationRoleMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_by          *int
	addcreated_by       *int
	created_at          *time.Time
	updated_by          *int
	addupdated_by       *int
	updated_at          *time.Time
	kind                *organizationrole.Kind
	name                *string
	app_role_id         *int
	addapp_role_id      *int
	comments            *string
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*OrganizationRole, error)
	predicates          []predicate.OrganizationRole
}

var _ ent.Mutation = (*OrganizationRoleMutation)(nil)

// organizationroleOption allows management of the mutation configuration using functional options.
type organizationroleOption func(*OrganizationRoleMutation)

// newOrganizationRoleMutation creates new mutation for the OrganizationRole entity.
func newOrganizationRoleMutation(c config, op Op, opts ...organizationroleOption) *OrganizationRoleMutation {
	m := &OrganizationRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationRoleID sets the ID field of the mutation.
func withOrganizationRoleID(id int) organizationroleOption {
	return func(m *OrganizationRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationRole
		)
		m.oldValue = func(ctx context.Context) (*OrganizationRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationRole sets the old OrganizationRole of the mutation.
func withOrganizationRole(node *OrganizationRole) organizationroleOption {
	return func(m *OrganizationRoleMutation) {
		m.oldValue = func(context.Context) (*OrganizationRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationRoleMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationRoleMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrganizationRole entity.
// If the OrganizationRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRoleMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrganizationRoleMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrganizationRoleMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationRole entity.
// If the OrganizationRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationRoleMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationRoleMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrganizationRole entity.
// If the OrganizationRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRoleMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrganizationRoleMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrganizationRoleMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationRoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[organizationrole.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationrole.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, organizationrole.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationRole entity.
// If the OrganizationRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organizationrole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationrole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organizationrole.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *OrganizationRoleMutation) SetOrgID(i int) {
	m.organization = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrganizationRoleMutation) OrgID() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrganizationRole entity.
// If the OrganizationRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRoleMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrganizationRoleMutation) ResetOrgID() {
	m.organization = nil
}

// SetKind sets the "kind" field.
func (m *OrganizationRoleMutation) SetKind(o organizationrole.Kind) {
	m.kind = &o
}

// Kind returns the value of the "kind" field in the mutation.
func (m *OrganizationRoleMutation) Kind() (r organizationrole.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the OrganizationRole entity.
// If the OrganizationRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRoleMutation) OldKind(ctx context.Context) (v organizationrole.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *OrganizationRoleMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *OrganizationRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrganizationRole entity.
// If the OrganizationRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationRoleMutation) ResetName() {
	m.name = nil
}

// SetAppRoleID sets the "app_role_id" field.
func (m *OrganizationRoleMutation) SetAppRoleID(i int) {
	m.app_role_id = &i
	m.addapp_role_id = nil
}

// AppRoleID returns the value of the "app_role_id" field in the mutation.
func (m *OrganizationRoleMutation) AppRoleID() (r int, exists bool) {
	v := m.app_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppRoleID returns the old "app_role_id" field's value of the OrganizationRole entity.
// If the OrganizationRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRoleMutation) OldAppRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppRoleID: %w", err)
	}
	return oldValue.AppRoleID, nil
}

// AddAppRoleID adds i to the "app_role_id" field.
func (m *OrganizationRoleMutation) AddAppRoleID(i int) {
	if m.addapp_role_id != nil {
		*m.addapp_role_id += i
	} else {
		m.addapp_role_id = &i
	}
}

// AddedAppRoleID returns the value that was added to the "app_role_id" field in this mutation.
func (m *OrganizationRoleMutation) AddedAppRoleID() (r int, exists bool) {
	v := m.addapp_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppRoleID clears the value of the "app_role_id" field.
func (m *OrganizationRoleMutation) ClearAppRoleID() {
	m.app_role_id = nil
	m.addapp_role_id = nil
	m.clearedFields[organizationrole.FieldAppRoleID] = struct{}{}
}

// AppRoleIDCleared returns if the "app_role_id" field was cleared in this mutation.
func (m *OrganizationRoleMutation) AppRoleIDCleared() bool {
	_, ok := m.clearedFields[organizationrole.FieldAppRoleID]
	return ok
}

// ResetAppRoleID resets all changes to the "app_role_id" field.
func (m *OrganizationRoleMutation) ResetAppRoleID() {
	m.app_role_id = nil
	m.addapp_role_id = nil
	delete(m.clearedFields, organizationrole.FieldAppRoleID)
}

// SetComments sets the "comments" field.
func (m *OrganizationRoleMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *OrganizationRoleMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the OrganizationRole entity.
// If the OrganizationRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationRoleMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *OrganizationRoleMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[organizationrole.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *OrganizationRoleMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[organizationrole.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *OrganizationRoleMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, organizationrole.FieldComments)
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *OrganizationRoleMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationRoleMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationRoleMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *OrganizationRoleMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationRoleMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationRoleMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the OrganizationRoleMutation builder.
func (m *OrganizationRoleMutation) Where(ps ...predicate.OrganizationRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationRole).
func (m *OrganizationRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationRoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, organizationrole.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, organizationrole.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationrole.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationrole.FieldUpdatedAt)
	}
	if m.organization != nil {
		fields = append(fields, organizationrole.FieldOrgID)
	}
	if m.kind != nil {
		fields = append(fields, organizationrole.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, organizationrole.FieldName)
	}
	if m.app_role_id != nil {
		fields = append(fields, organizationrole.FieldAppRoleID)
	}
	if m.comments != nil {
		fields = append(fields, organizationrole.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationrole.FieldCreatedBy:
		return m.CreatedBy()
	case organizationrole.FieldCreatedAt:
		return m.CreatedAt()
	case organizationrole.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationrole.FieldOrgID:
		return m.OrgID()
	case organizationrole.FieldKind:
		return m.Kind()
	case organizationrole.FieldName:
		return m.Name()
	case organizationrole.FieldAppRoleID:
		return m.AppRoleID()
	case organizationrole.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationrole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organizationrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationrole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organizationrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationrole.FieldOrgID:
		return m.OldOrgID(ctx)
	case organizationrole.FieldKind:
		return m.OldKind(ctx)
	case organizationrole.FieldName:
		return m.OldName(ctx)
	case organizationrole.FieldAppRoleID:
		return m.OldAppRoleID(ctx)
	case organizationrole.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationrole.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationrole.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationrole.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case organizationrole.FieldKind:
		v, ok := value.(organizationrole.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case organizationrole.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organizationrole.FieldAppRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppRoleID(v)
		return nil
	case organizationrole.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, organizationrole.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, organizationrole.FieldUpdatedBy)
	}
	if m.addapp_role_id != nil {
		fields = append(fields, organizationrole.FieldAppRoleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organizationrole.FieldCreatedBy:
		return m.AddedCreatedBy()
	case organizationrole.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case organizationrole.FieldAppRoleID:
		return m.AddedAppRoleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organizationrole.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case organizationrole.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case organizationrole.FieldAppRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationrole.FieldUpdatedBy) {
		fields = append(fields, organizationrole.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationrole.FieldUpdatedAt) {
		fields = append(fields, organizationrole.FieldUpdatedAt)
	}
	if m.FieldCleared(organizationrole.FieldAppRoleID) {
		fields = append(fields, organizationrole.FieldAppRoleID)
	}
	if m.FieldCleared(organizationrole.FieldComments) {
		fields = append(fields, organizationrole.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationRoleMutation) ClearField(name string) error {
	switch name {
	case organizationrole.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationrole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case organizationrole.FieldAppRoleID:
		m.ClearAppRoleID()
		return nil
	case organizationrole.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown OrganizationRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationRoleMutation) ResetField(name string) error {
	switch name {
	case organizationrole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationrole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationrole.FieldOrgID:
		m.ResetOrgID()
		return nil
	case organizationrole.FieldKind:
		m.ResetKind()
		return nil
	case organizationrole.FieldName:
		m.ResetName()
		return nil
	case organizationrole.FieldAppRoleID:
		m.ResetAppRoleID()
		return nil
	case organizationrole.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown OrganizationRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization != nil {
		edges = append(edges, organizationrole.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationrole.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization {
		edges = append(edges, organizationrole.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationrole.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationRoleMutation) ClearEdge(name string) error {
	switch name {
	case organizationrole.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationRoleMutation) ResetEdge(name string) error {
	switch name {
	case organizationrole.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationRole edge %s", name)
}

// OrganizationUserMutation represents an operation that mutates the OrganizationUser nodes in the graph.
type OrganizationUserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_by          *int
	addcreated_by       *int
	created_at          *time.Time
	updated_by          *int
	addupdated_by       *int
	updated_at          *time.Time
	display_name        *string
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	user                *int
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*OrganizationUser, error)
	predicates          []predicate.OrganizationUser
}

var _ ent.Mutation = (*OrganizationUserMutation)(nil)

// organizationuserOption allows management of the mutation configuration using functional options.
type organizationuserOption func(*OrganizationUserMutation)

// newOrganizationUserMutation creates new mutation for the OrganizationUser entity.
func newOrganizationUserMutation(c config, op Op, opts ...organizationuserOption) *OrganizationUserMutation {
	m := &OrganizationUserMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationUserID sets the ID field of the mutation.
func withOrganizationUserID(id int) organizationuserOption {
	return func(m *OrganizationUserMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationUser
		)
		m.oldValue = func(ctx context.Context) (*OrganizationUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationUser sets the old OrganizationUser of the mutation.
func withOrganizationUser(node *OrganizationUser) organizationuserOption {
	return func(m *OrganizationUserMutation) {
		m.oldValue = func(context.Context) (*OrganizationUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationUser entities.
func (m *OrganizationUserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationUserMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationUserMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrganizationUserMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrganizationUserMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationUserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationUserMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationUserMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrganizationUserMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrganizationUserMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationUserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[organizationuser.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationUserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organizationuser.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationUserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, organizationuser.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrganizationUserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[organizationuser.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrganizationUserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[organizationuser.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, organizationuser.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *OrganizationUserMutation) SetOrgID(i int) {
	m.organization = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrganizationUserMutation) OrgID() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrganizationUserMutation) ResetOrgID() {
	m.organization = nil
}

// SetUserID sets the "user_id" field.
func (m *OrganizationUserMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrganizationUserMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrganizationUserMutation) ResetUserID() {
	m.user = nil
}

// SetDisplayName sets the "display_name" field.
func (m *OrganizationUserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OrganizationUserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the OrganizationUser entity.
// If the OrganizationUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationUserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OrganizationUserMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *OrganizationUserMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationUserMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationUserMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *OrganizationUserMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationUserMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationUserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrganizationUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrganizationUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrganizationUserMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrganizationUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OrganizationUserMutation builder.
func (m *OrganizationUserMutation) Where(ps ...predicate.OrganizationUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationUser).
func (m *OrganizationUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, organizationuser.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, organizationuser.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, organizationuser.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationuser.FieldUpdatedAt)
	}
	if m.organization != nil {
		fields = append(fields, organizationuser.FieldOrgID)
	}
	if m.user != nil {
		fields = append(fields, organizationuser.FieldUserID)
	}
	if m.display_name != nil {
		fields = append(fields, organizationuser.FieldDisplayName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationuser.FieldCreatedBy:
		return m.CreatedBy()
	case organizationuser.FieldCreatedAt:
		return m.CreatedAt()
	case organizationuser.FieldUpdatedBy:
		return m.UpdatedBy()
	case organizationuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationuser.FieldOrgID:
		return m.OrgID()
	case organizationuser.FieldUserID:
		return m.UserID()
	case organizationuser.FieldDisplayName:
		return m.DisplayName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationuser.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organizationuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationuser.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organizationuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationuser.FieldOrgID:
		return m.OldOrgID(ctx)
	case organizationuser.FieldUserID:
		return m.OldUserID(ctx)
	case organizationuser.FieldDisplayName:
		return m.OldDisplayName(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationuser.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organizationuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationuser.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organizationuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationuser.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case organizationuser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case organizationuser.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, organizationuser.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, organizationuser.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organizationuser.FieldCreatedBy:
		return m.AddedCreatedBy()
	case organizationuser.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organizationuser.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case organizationuser.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organizationuser.FieldUpdatedBy) {
		fields = append(fields, organizationuser.FieldUpdatedBy)
	}
	if m.FieldCleared(organizationuser.FieldUpdatedAt) {
		fields = append(fields, organizationuser.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationUserMutation) ClearField(name string) error {
	switch name {
	case organizationuser.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organizationuser.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationUserMutation) ResetField(name string) error {
	switch name {
	case organizationuser.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organizationuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationuser.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organizationuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationuser.FieldOrgID:
		m.ResetOrgID()
		return nil
	case organizationuser.FieldUserID:
		m.ResetUserID()
		return nil
	case organizationuser.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, organizationuser.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, organizationuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationuser.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case organizationuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, organizationuser.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, organizationuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationUserMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationuser.EdgeOrganization:
		return m.clearedorganization
	case organizationuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationUserMutation) ClearEdge(name string) error {
	switch name {
	case organizationuser.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case organizationuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationUserMutation) ResetEdge(name string) error {
	switch name {
	case organizationuser.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case organizationuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OrganizationUser edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_by          *int
	addcreated_by       *int
	created_at          *time.Time
	updated_by          *int
	addupdated_by       *int
	updated_at          *time.Time
	principal_kind      *permission.PrincipalKind
	role_id             *int
	addrole_id          *int
	org_policy_id       *int
	addorg_policy_id    *int
	start_at            *time.Time
	end_at              *time.Time
	status              *typex.SimpleStatus
	clearedFields       map[string]struct{}
	organization        *int
	clearedorganization bool
	user                *int
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*Permission, error)
	predicates          []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *PermissionMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PermissionMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PermissionMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PermissionMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PermissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PermissionMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PermissionMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PermissionMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PermissionMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PermissionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[permission.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PermissionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[permission.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PermissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, permission.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PermissionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[permission.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PermissionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, permission.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *PermissionMutation) SetOrgID(i int) {
	m.organization = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *PermissionMutation) OrgID() (r int, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *PermissionMutation) ResetOrgID() {
	m.organization = nil
}

// SetPrincipalKind sets the "principal_kind" field.
func (m *PermissionMutation) SetPrincipalKind(pk permission.PrincipalKind) {
	m.principal_kind = &pk
}

// PrincipalKind returns the value of the "principal_kind" field in the mutation.
func (m *PermissionMutation) PrincipalKind() (r permission.PrincipalKind, exists bool) {
	v := m.principal_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldPrincipalKind returns the old "principal_kind" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldPrincipalKind(ctx context.Context) (v permission.PrincipalKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrincipalKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrincipalKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrincipalKind: %w", err)
	}
	return oldValue.PrincipalKind, nil
}

// ResetPrincipalKind resets all changes to the "principal_kind" field.
func (m *PermissionMutation) ResetPrincipalKind() {
	m.principal_kind = nil
}

// SetUserID sets the "user_id" field.
func (m *PermissionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PermissionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *PermissionMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[permission.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *PermissionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[permission.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PermissionMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, permission.FieldUserID)
}

// SetRoleID sets the "role_id" field.
func (m *PermissionMutation) SetRoleID(i int) {
	m.role_id = &i
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *PermissionMutation) RoleID() (r int, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds i to the "role_id" field.
func (m *PermissionMutation) AddRoleID(i int) {
	if m.addrole_id != nil {
		*m.addrole_id += i
	} else {
		m.addrole_id = &i
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *PermissionMutation) AddedRoleID() (r int, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleID clears the value of the "role_id" field.
func (m *PermissionMutation) ClearRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	m.clearedFields[permission.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *PermissionMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[permission.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *PermissionMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
	delete(m.clearedFields, permission.FieldRoleID)
}

// SetOrgPolicyID sets the "org_policy_id" field.
func (m *PermissionMutation) SetOrgPolicyID(i int) {
	m.org_policy_id = &i
	m.addorg_policy_id = nil
}

// OrgPolicyID returns the value of the "org_policy_id" field in the mutation.
func (m *PermissionMutation) OrgPolicyID() (r int, exists bool) {
	v := m.org_policy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgPolicyID returns the old "org_policy_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldOrgPolicyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgPolicyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgPolicyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgPolicyID: %w", err)
	}
	return oldValue.OrgPolicyID, nil
}

// AddOrgPolicyID adds i to the "org_policy_id" field.
func (m *PermissionMutation) AddOrgPolicyID(i int) {
	if m.addorg_policy_id != nil {
		*m.addorg_policy_id += i
	} else {
		m.addorg_policy_id = &i
	}
}

// AddedOrgPolicyID returns the value that was added to the "org_policy_id" field in this mutation.
func (m *PermissionMutation) AddedOrgPolicyID() (r int, exists bool) {
	v := m.addorg_policy_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrgPolicyID resets all changes to the "org_policy_id" field.
func (m *PermissionMutation) ResetOrgPolicyID() {
	m.org_policy_id = nil
	m.addorg_policy_id = nil
}

// SetStartAt sets the "start_at" field.
func (m *PermissionMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *PermissionMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *PermissionMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[permission.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *PermissionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *PermissionMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, permission.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *PermissionMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *PermissionMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *PermissionMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[permission.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *PermissionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *PermissionMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, permission.FieldEndAt)
}

// SetStatus sets the "status" field.
func (m *PermissionMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *PermissionMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PermissionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[permission.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PermissionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[permission.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PermissionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, permission.FieldStatus)
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *PermissionMutation) SetOrganizationID(id int) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *PermissionMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *PermissionMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *PermissionMutation) OrganizationID() (id int, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) OrganizationIDs() (ids []int) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *PermissionMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *PermissionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PermissionMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PermissionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.organization != nil {
		fields = append(fields, permission.FieldOrgID)
	}
	if m.principal_kind != nil {
		fields = append(fields, permission.FieldPrincipalKind)
	}
	if m.user != nil {
		fields = append(fields, permission.FieldUserID)
	}
	if m.role_id != nil {
		fields = append(fields, permission.FieldRoleID)
	}
	if m.org_policy_id != nil {
		fields = append(fields, permission.FieldOrgPolicyID)
	}
	if m.start_at != nil {
		fields = append(fields, permission.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, permission.FieldEndAt)
	}
	if m.status != nil {
		fields = append(fields, permission.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedBy:
		return m.CreatedBy()
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedBy:
		return m.UpdatedBy()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldOrgID:
		return m.OrgID()
	case permission.FieldPrincipalKind:
		return m.PrincipalKind()
	case permission.FieldUserID:
		return m.UserID()
	case permission.FieldRoleID:
		return m.RoleID()
	case permission.FieldOrgPolicyID:
		return m.OrgPolicyID()
	case permission.FieldStartAt:
		return m.StartAt()
	case permission.FieldEndAt:
		return m.EndAt()
	case permission.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldOrgID:
		return m.OldOrgID(ctx)
	case permission.FieldPrincipalKind:
		return m.OldPrincipalKind(ctx)
	case permission.FieldUserID:
		return m.OldUserID(ctx)
	case permission.FieldRoleID:
		return m.OldRoleID(ctx)
	case permission.FieldOrgPolicyID:
		return m.OldOrgPolicyID(ctx)
	case permission.FieldStartAt:
		return m.OldStartAt(ctx)
	case permission.FieldEndAt:
		return m.OldEndAt(ctx)
	case permission.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case permission.FieldPrincipalKind:
		v, ok := value.(permission.PrincipalKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrincipalKind(v)
		return nil
	case permission.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case permission.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case permission.FieldOrgPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgPolicyID(v)
		return nil
	case permission.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case permission.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case permission.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	if m.addrole_id != nil {
		fields = append(fields, permission.FieldRoleID)
	}
	if m.addorg_policy_id != nil {
		fields = append(fields, permission.FieldOrgPolicyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case permission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case permission.FieldRoleID:
		return m.AddedRoleID()
	case permission.FieldOrgPolicyID:
		return m.AddedOrgPolicyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case permission.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case permission.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	case permission.FieldOrgPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgPolicyID(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldUpdatedBy) {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	if m.FieldCleared(permission.FieldUpdatedAt) {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.FieldCleared(permission.FieldUserID) {
		fields = append(fields, permission.FieldUserID)
	}
	if m.FieldCleared(permission.FieldRoleID) {
		fields = append(fields, permission.FieldRoleID)
	}
	if m.FieldCleared(permission.FieldStartAt) {
		fields = append(fields, permission.FieldStartAt)
	}
	if m.FieldCleared(permission.FieldEndAt) {
		fields = append(fields, permission.FieldEndAt)
	}
	if m.FieldCleared(permission.FieldStatus) {
		fields = append(fields, permission.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case permission.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case permission.FieldUserID:
		m.ClearUserID()
		return nil
	case permission.FieldRoleID:
		m.ClearRoleID()
		return nil
	case permission.FieldStartAt:
		m.ClearStartAt()
		return nil
	case permission.FieldEndAt:
		m.ClearEndAt()
		return nil
	case permission.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldOrgID:
		m.ResetOrgID()
		return nil
	case permission.FieldPrincipalKind:
		m.ResetPrincipalKind()
		return nil
	case permission.FieldUserID:
		m.ResetUserID()
		return nil
	case permission.FieldRoleID:
		m.ResetRoleID()
		return nil
	case permission.FieldOrgPolicyID:
		m.ResetOrgPolicyID()
		return nil
	case permission.FieldStartAt:
		m.ResetStartAt()
		return nil
	case permission.FieldEndAt:
		m.ResetEndAt()
		return nil
	case permission.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, permission.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, permission.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, permission.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, permission.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeOrganization:
		return m.clearedorganization
	case permission.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	case permission.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case permission.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case permission.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_by               *int
	addcreated_by            *int
	created_at               *time.Time
	updated_by               *int
	addupdated_by            *int
	updated_at               *time.Time
	deleted_at               *time.Time
	principal_name           *string
	display_name             *string
	email                    *string
	mobile                   *string
	user_type                *user.UserType
	creation_type            *user.CreationType
	register_ip              *string
	status                   *typex.SimpleStatus
	comments                 *string
	clearedFields            map[string]struct{}
	identities               map[int]struct{}
	removedidentities        map[int]struct{}
	clearedidentities        bool
	login_profile            *int
	clearedlogin_profile     bool
	passwords                map[int]struct{}
	removedpasswords         map[int]struct{}
	clearedpasswords         bool
	devices                  map[int]struct{}
	removeddevices           map[int]struct{}
	cleareddevices           bool
	organizations            map[int]struct{}
	removedorganizations     map[int]struct{}
	clearedorganizations     bool
	permissions              map[int]struct{}
	removedpermissions       map[int]struct{}
	clearedpermissions       bool
	organization_user        map[int]struct{}
	removedorganization_user map[int]struct{}
	clearedorganization_user bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[user.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, user.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetPrincipalName sets the "principal_name" field.
func (m *UserMutation) SetPrincipalName(s string) {
	m.principal_name = &s
}

// PrincipalName returns the value of the "principal_name" field in the mutation.
func (m *UserMutation) PrincipalName() (r string, exists bool) {
	v := m.principal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPrincipalName returns the old "principal_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrincipalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrincipalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrincipalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrincipalName: %w", err)
	}
	return oldValue.PrincipalName, nil
}

// ResetPrincipalName resets all changes to the "principal_name" field.
func (m *UserMutation) ResetPrincipalName() {
	m.principal_name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *UserMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[user.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *UserMutation) MobileCleared() bool {
	_, ok := m.clearedFields[user.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, user.FieldMobile)
}

// SetUserType sets the "user_type" field.
func (m *UserMutation) SetUserType(ut user.UserType) {
	m.user_type = &ut
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *UserMutation) UserType() (r user.UserType, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserType(ctx context.Context) (v user.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ResetUserType resets all changes to the "user_type" field.
func (m *UserMutation) ResetUserType() {
	m.user_type = nil
}

// SetCreationType sets the "creation_type" field.
func (m *UserMutation) SetCreationType(ut user.CreationType) {
	m.creation_type = &ut
}

// CreationType returns the value of the "creation_type" field in the mutation.
func (m *UserMutation) CreationType() (r user.CreationType, exists bool) {
	v := m.creation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationType returns the old "creation_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreationType(ctx context.Context) (v user.CreationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationType: %w", err)
	}
	return oldValue.CreationType, nil
}

// ResetCreationType resets all changes to the "creation_type" field.
func (m *UserMutation) ResetCreationType() {
	m.creation_type = nil
}

// SetRegisterIP sets the "register_ip" field.
func (m *UserMutation) SetRegisterIP(s string) {
	m.register_ip = &s
}

// RegisterIP returns the value of the "register_ip" field in the mutation.
func (m *UserMutation) RegisterIP() (r string, exists bool) {
	v := m.register_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterIP returns the old "register_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegisterIP(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterIP: %w", err)
	}
	return oldValue.RegisterIP, nil
}

// ResetRegisterIP resets all changes to the "register_ip" field.
func (m *UserMutation) ResetRegisterIP() {
	m.register_ip = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetComments sets the "comments" field.
func (m *UserMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *UserMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *UserMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[user.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *UserMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[user.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, user.FieldComments)
}

// AddIdentityIDs adds the "identities" edge to the UserIdentity entity by ids.
func (m *UserMutation) AddIdentityIDs(ids ...int) {
	if m.identities == nil {
		m.identities = make(map[int]struct{})
	}
	for i := range ids {
		m.identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "identities" edge to the UserIdentity entity.
func (m *UserMutation) ClearIdentities() {
	m.clearedidentities = true
}

// IdentitiesCleared reports if the "identities" edge to the UserIdentity entity was cleared.
func (m *UserMutation) IdentitiesCleared() bool {
	return m.clearedidentities
}

// RemoveIdentityIDs removes the "identities" edge to the UserIdentity entity by IDs.
func (m *UserMutation) RemoveIdentityIDs(ids ...int) {
	if m.removedidentities == nil {
		m.removedidentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.identities, ids[i])
		m.removedidentities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "identities" edge to the UserIdentity entity.
func (m *UserMutation) RemovedIdentitiesIDs() (ids []int) {
	for id := range m.removedidentities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "identities" edge IDs in the mutation.
func (m *UserMutation) IdentitiesIDs() (ids []int) {
	for id := range m.identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "identities" edge.
func (m *UserMutation) ResetIdentities() {
	m.identities = nil
	m.clearedidentities = false
	m.removedidentities = nil
}

// SetLoginProfileID sets the "login_profile" edge to the UserLoginProfile entity by id.
func (m *UserMutation) SetLoginProfileID(id int) {
	m.login_profile = &id
}

// ClearLoginProfile clears the "login_profile" edge to the UserLoginProfile entity.
func (m *UserMutation) ClearLoginProfile() {
	m.clearedlogin_profile = true
}

// LoginProfileCleared reports if the "login_profile" edge to the UserLoginProfile entity was cleared.
func (m *UserMutation) LoginProfileCleared() bool {
	return m.clearedlogin_profile
}

// LoginProfileID returns the "login_profile" edge ID in the mutation.
func (m *UserMutation) LoginProfileID() (id int, exists bool) {
	if m.login_profile != nil {
		return *m.login_profile, true
	}
	return
}

// LoginProfileIDs returns the "login_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LoginProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) LoginProfileIDs() (ids []int) {
	if id := m.login_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLoginProfile resets all changes to the "login_profile" edge.
func (m *UserMutation) ResetLoginProfile() {
	m.login_profile = nil
	m.clearedlogin_profile = false
}

// AddPasswordIDs adds the "passwords" edge to the UserPassword entity by ids.
func (m *UserMutation) AddPasswordIDs(ids ...int) {
	if m.passwords == nil {
		m.passwords = make(map[int]struct{})
	}
	for i := range ids {
		m.passwords[ids[i]] = struct{}{}
	}
}

// ClearPasswords clears the "passwords" edge to the UserPassword entity.
func (m *UserMutation) ClearPasswords() {
	m.clearedpasswords = true
}

// PasswordsCleared reports if the "passwords" edge to the UserPassword entity was cleared.
func (m *UserMutation) PasswordsCleared() bool {
	return m.clearedpasswords
}

// RemovePasswordIDs removes the "passwords" edge to the UserPassword entity by IDs.
func (m *UserMutation) RemovePasswordIDs(ids ...int) {
	if m.removedpasswords == nil {
		m.removedpasswords = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.passwords, ids[i])
		m.removedpasswords[ids[i]] = struct{}{}
	}
}

// RemovedPasswords returns the removed IDs of the "passwords" edge to the UserPassword entity.
func (m *UserMutation) RemovedPasswordsIDs() (ids []int) {
	for id := range m.removedpasswords {
		ids = append(ids, id)
	}
	return
}

// PasswordsIDs returns the "passwords" edge IDs in the mutation.
func (m *UserMutation) PasswordsIDs() (ids []int) {
	for id := range m.passwords {
		ids = append(ids, id)
	}
	return
}

// ResetPasswords resets all changes to the "passwords" edge.
func (m *UserMutation) ResetPasswords() {
	m.passwords = nil
	m.clearedpasswords = false
	m.removedpasswords = nil
}

// AddDeviceIDs adds the "devices" edge to the UserDevice entity by ids.
func (m *UserMutation) AddDeviceIDs(ids ...int) {
	if m.devices == nil {
		m.devices = make(map[int]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the UserDevice entity.
func (m *UserMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the UserDevice entity was cleared.
func (m *UserMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the UserDevice entity by IDs.
func (m *UserMutation) RemoveDeviceIDs(ids ...int) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the UserDevice entity.
func (m *UserMutation) RemovedDevicesIDs() (ids []int) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *UserMutation) DevicesIDs() (ids []int) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *UserMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *UserMutation) AddOrganizationIDs(ids ...int) {
	if m.organizations == nil {
		m.organizations = make(map[int]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *UserMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *UserMutation) RemoveOrganizationIDs(ids ...int) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *UserMutation) RemovedOrganizationsIDs() (ids []int) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *UserMutation) OrganizationsIDs() (ids []int) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *UserMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *UserMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *UserMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *UserMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *UserMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *UserMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *UserMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *UserMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddOrganizationUserIDs adds the "organization_user" edge to the OrganizationUser entity by ids.
func (m *UserMutation) AddOrganizationUserIDs(ids ...int) {
	if m.organization_user == nil {
		m.organization_user = make(map[int]struct{})
	}
	for i := range ids {
		m.organization_user[ids[i]] = struct{}{}
	}
}

// ClearOrganizationUser clears the "organization_user" edge to the OrganizationUser entity.
func (m *UserMutation) ClearOrganizationUser() {
	m.clearedorganization_user = true
}

// OrganizationUserCleared reports if the "organization_user" edge to the OrganizationUser entity was cleared.
func (m *UserMutation) OrganizationUserCleared() bool {
	return m.clearedorganization_user
}

// RemoveOrganizationUserIDs removes the "organization_user" edge to the OrganizationUser entity by IDs.
func (m *UserMutation) RemoveOrganizationUserIDs(ids ...int) {
	if m.removedorganization_user == nil {
		m.removedorganization_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.organization_user, ids[i])
		m.removedorganization_user[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationUser returns the removed IDs of the "organization_user" edge to the OrganizationUser entity.
func (m *UserMutation) RemovedOrganizationUserIDs() (ids []int) {
	for id := range m.removedorganization_user {
		ids = append(ids, id)
	}
	return
}

// OrganizationUserIDs returns the "organization_user" edge IDs in the mutation.
func (m *UserMutation) OrganizationUserIDs() (ids []int) {
	for id := range m.organization_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationUser resets all changes to the "organization_user" edge.
func (m *UserMutation) ResetOrganizationUser() {
	m.organization_user = nil
	m.clearedorganization_user = false
	m.removedorganization_user = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.principal_name != nil {
		fields = append(fields, user.FieldPrincipalName)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.user_type != nil {
		fields = append(fields, user.FieldUserType)
	}
	if m.creation_type != nil {
		fields = append(fields, user.FieldCreationType)
	}
	if m.register_ip != nil {
		fields = append(fields, user.FieldRegisterIP)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.comments != nil {
		fields = append(fields, user.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldPrincipalName:
		return m.PrincipalName()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldUserType:
		return m.UserType()
	case user.FieldCreationType:
		return m.CreationType()
	case user.FieldRegisterIP:
		return m.RegisterIP()
	case user.FieldStatus:
		return m.Status()
	case user.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldPrincipalName:
		return m.OldPrincipalName(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldUserType:
		return m.OldUserType(ctx)
	case user.FieldCreationType:
		return m.OldCreationType(ctx)
	case user.FieldRegisterIP:
		return m.OldRegisterIP(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldPrincipalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrincipalName(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldUserType:
		v, ok := value.(user.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case user.FieldCreationType:
		v, ok := value.(user.CreationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationType(v)
		return nil
	case user.FieldRegisterIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterIP(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUpdatedBy) {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldMobile) {
		fields = append(fields, user.FieldMobile)
	}
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldComments) {
		fields = append(fields, user.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldMobile:
		m.ClearMobile()
		return nil
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldPrincipalName:
		m.ResetPrincipalName()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldUserType:
		m.ResetUserType()
		return nil
	case user.FieldCreationType:
		m.ResetCreationType()
		return nil
	case user.FieldRegisterIP:
		m.ResetRegisterIP()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.identities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.login_profile != nil {
		edges = append(edges, user.EdgeLoginProfile)
	}
	if m.passwords != nil {
		edges = append(edges, user.EdgePasswords)
	}
	if m.devices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.organizations != nil {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.permissions != nil {
		edges = append(edges, user.EdgePermissions)
	}
	if m.organization_user != nil {
		edges = append(edges, user.EdgeOrganizationUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.identities))
		for id := range m.identities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginProfile:
		if id := m.login_profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.passwords))
		for id := range m.passwords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationUser:
		ids := make([]ent.Value, 0, len(m.organization_user))
		for id := range m.organization_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedidentities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.removedpasswords != nil {
		edges = append(edges, user.EdgePasswords)
	}
	if m.removeddevices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.removedorganizations != nil {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.removedpermissions != nil {
		edges = append(edges, user.EdgePermissions)
	}
	if m.removedorganization_user != nil {
		edges = append(edges, user.EdgeOrganizationUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removedidentities))
		for id := range m.removedidentities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.removedpasswords))
		for id := range m.removedpasswords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrganizationUser:
		ids := make([]ent.Value, 0, len(m.removedorganization_user))
		for id := range m.removedorganization_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedidentities {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.clearedlogin_profile {
		edges = append(edges, user.EdgeLoginProfile)
	}
	if m.clearedpasswords {
		edges = append(edges, user.EdgePasswords)
	}
	if m.cleareddevices {
		edges = append(edges, user.EdgeDevices)
	}
	if m.clearedorganizations {
		edges = append(edges, user.EdgeOrganizations)
	}
	if m.clearedpermissions {
		edges = append(edges, user.EdgePermissions)
	}
	if m.clearedorganization_user {
		edges = append(edges, user.EdgeOrganizationUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeIdentities:
		return m.clearedidentities
	case user.EdgeLoginProfile:
		return m.clearedlogin_profile
	case user.EdgePasswords:
		return m.clearedpasswords
	case user.EdgeDevices:
		return m.cleareddevices
	case user.EdgeOrganizations:
		return m.clearedorganizations
	case user.EdgePermissions:
		return m.clearedpermissions
	case user.EdgeOrganizationUser:
		return m.clearedorganization_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeLoginProfile:
		m.ClearLoginProfile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case user.EdgeLoginProfile:
		m.ResetLoginProfile()
		return nil
	case user.EdgePasswords:
		m.ResetPasswords()
		return nil
	case user.EdgeDevices:
		m.ResetDevices()
		return nil
	case user.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	case user.EdgePermissions:
		m.ResetPermissions()
		return nil
	case user.EdgeOrganizationUser:
		m.ResetOrganizationUser()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserDeviceMutation represents an operation that mutates the UserDevice nodes in the graph.
type UserDeviceMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_by     *int
	addcreated_by  *int
	created_at     *time.Time
	updated_by     *int
	addupdated_by  *int
	updated_at     *time.Time
	device_uid     *string
	device_name    *string
	system_name    *string
	system_version *string
	app_version    *string
	device_model   *string
	status         *typex.SimpleStatus
	comments       *string
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserDevice, error)
	predicates     []predicate.UserDevice
}

var _ ent.Mutation = (*UserDeviceMutation)(nil)

// userdeviceOption allows management of the mutation configuration using functional options.
type userdeviceOption func(*UserDeviceMutation)

// newUserDeviceMutation creates new mutation for the UserDevice entity.
func newUserDeviceMutation(c config, op Op, opts ...userdeviceOption) *UserDeviceMutation {
	m := &UserDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDeviceID sets the ID field of the mutation.
func withUserDeviceID(id int) userdeviceOption {
	return func(m *UserDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDevice
		)
		m.oldValue = func(ctx context.Context) (*UserDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDevice sets the old UserDevice of the mutation.
func withUserDevice(node *UserDevice) userdeviceOption {
	return func(m *UserDeviceMutation) {
		m.oldValue = func(context.Context) (*UserDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserDevice entities.
func (m *UserDeviceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserDeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserDeviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserDeviceMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserDeviceMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserDeviceMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserDeviceMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserDeviceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserDeviceMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserDeviceMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserDeviceMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserDeviceMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserDeviceMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userdevice.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserDeviceMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserDeviceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userdevice.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserDeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserDeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserDeviceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userdevice.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserDeviceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserDeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userdevice.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserDeviceMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserDeviceMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserDeviceMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userdevice.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserDeviceMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserDeviceMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userdevice.FieldUserID)
}

// SetDeviceUID sets the "device_uid" field.
func (m *UserDeviceMutation) SetDeviceUID(s string) {
	m.device_uid = &s
}

// DeviceUID returns the value of the "device_uid" field in the mutation.
func (m *UserDeviceMutation) DeviceUID() (r string, exists bool) {
	v := m.device_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceUID returns the old "device_uid" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceUID: %w", err)
	}
	return oldValue.DeviceUID, nil
}

// ResetDeviceUID resets all changes to the "device_uid" field.
func (m *UserDeviceMutation) ResetDeviceUID() {
	m.device_uid = nil
}

// SetDeviceName sets the "device_name" field.
func (m *UserDeviceMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *UserDeviceMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ClearDeviceName clears the value of the "device_name" field.
func (m *UserDeviceMutation) ClearDeviceName() {
	m.device_name = nil
	m.clearedFields[userdevice.FieldDeviceName] = struct{}{}
}

// DeviceNameCleared returns if the "device_name" field was cleared in this mutation.
func (m *UserDeviceMutation) DeviceNameCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldDeviceName]
	return ok
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *UserDeviceMutation) ResetDeviceName() {
	m.device_name = nil
	delete(m.clearedFields, userdevice.FieldDeviceName)
}

// SetSystemName sets the "system_name" field.
func (m *UserDeviceMutation) SetSystemName(s string) {
	m.system_name = &s
}

// SystemName returns the value of the "system_name" field in the mutation.
func (m *UserDeviceMutation) SystemName() (r string, exists bool) {
	v := m.system_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemName returns the old "system_name" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldSystemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemName: %w", err)
	}
	return oldValue.SystemName, nil
}

// ClearSystemName clears the value of the "system_name" field.
func (m *UserDeviceMutation) ClearSystemName() {
	m.system_name = nil
	m.clearedFields[userdevice.FieldSystemName] = struct{}{}
}

// SystemNameCleared returns if the "system_name" field was cleared in this mutation.
func (m *UserDeviceMutation) SystemNameCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldSystemName]
	return ok
}

// ResetSystemName resets all changes to the "system_name" field.
func (m *UserDeviceMutation) ResetSystemName() {
	m.system_name = nil
	delete(m.clearedFields, userdevice.FieldSystemName)
}

// SetSystemVersion sets the "system_version" field.
func (m *UserDeviceMutation) SetSystemVersion(s string) {
	m.system_version = &s
}

// SystemVersion returns the value of the "system_version" field in the mutation.
func (m *UserDeviceMutation) SystemVersion() (r string, exists bool) {
	v := m.system_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemVersion returns the old "system_version" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldSystemVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemVersion: %w", err)
	}
	return oldValue.SystemVersion, nil
}

// ClearSystemVersion clears the value of the "system_version" field.
func (m *UserDeviceMutation) ClearSystemVersion() {
	m.system_version = nil
	m.clearedFields[userdevice.FieldSystemVersion] = struct{}{}
}

// SystemVersionCleared returns if the "system_version" field was cleared in this mutation.
func (m *UserDeviceMutation) SystemVersionCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldSystemVersion]
	return ok
}

// ResetSystemVersion resets all changes to the "system_version" field.
func (m *UserDeviceMutation) ResetSystemVersion() {
	m.system_version = nil
	delete(m.clearedFields, userdevice.FieldSystemVersion)
}

// SetAppVersion sets the "app_version" field.
func (m *UserDeviceMutation) SetAppVersion(s string) {
	m.app_version = &s
}

// AppVersion returns the value of the "app_version" field in the mutation.
func (m *UserDeviceMutation) AppVersion() (r string, exists bool) {
	v := m.app_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAppVersion returns the old "app_version" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldAppVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppVersion: %w", err)
	}
	return oldValue.AppVersion, nil
}

// ClearAppVersion clears the value of the "app_version" field.
func (m *UserDeviceMutation) ClearAppVersion() {
	m.app_version = nil
	m.clearedFields[userdevice.FieldAppVersion] = struct{}{}
}

// AppVersionCleared returns if the "app_version" field was cleared in this mutation.
func (m *UserDeviceMutation) AppVersionCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldAppVersion]
	return ok
}

// ResetAppVersion resets all changes to the "app_version" field.
func (m *UserDeviceMutation) ResetAppVersion() {
	m.app_version = nil
	delete(m.clearedFields, userdevice.FieldAppVersion)
}

// SetDeviceModel sets the "device_model" field.
func (m *UserDeviceMutation) SetDeviceModel(s string) {
	m.device_model = &s
}

// DeviceModel returns the value of the "device_model" field in the mutation.
func (m *UserDeviceMutation) DeviceModel() (r string, exists bool) {
	v := m.device_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceModel returns the old "device_model" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceModel: %w", err)
	}
	return oldValue.DeviceModel, nil
}

// ClearDeviceModel clears the value of the "device_model" field.
func (m *UserDeviceMutation) ClearDeviceModel() {
	m.device_model = nil
	m.clearedFields[userdevice.FieldDeviceModel] = struct{}{}
}

// DeviceModelCleared returns if the "device_model" field was cleared in this mutation.
func (m *UserDeviceMutation) DeviceModelCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldDeviceModel]
	return ok
}

// ResetDeviceModel resets all changes to the "device_model" field.
func (m *UserDeviceMutation) ResetDeviceModel() {
	m.device_model = nil
	delete(m.clearedFields, userdevice.FieldDeviceModel)
}

// SetStatus sets the "status" field.
func (m *UserDeviceMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *UserDeviceMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserDeviceMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[userdevice.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserDeviceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserDeviceMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, userdevice.FieldStatus)
}

// SetComments sets the "comments" field.
func (m *UserDeviceMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *UserDeviceMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *UserDeviceMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[userdevice.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *UserDeviceMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *UserDeviceMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, userdevice.FieldComments)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserDeviceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserDeviceMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserDeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserDeviceMutation builder.
func (m *UserDeviceMutation) Where(ps ...predicate.UserDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserDevice).
func (m *UserDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserDeviceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userdevice.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userdevice.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.device_uid != nil {
		fields = append(fields, userdevice.FieldDeviceUID)
	}
	if m.device_name != nil {
		fields = append(fields, userdevice.FieldDeviceName)
	}
	if m.system_name != nil {
		fields = append(fields, userdevice.FieldSystemName)
	}
	if m.system_version != nil {
		fields = append(fields, userdevice.FieldSystemVersion)
	}
	if m.app_version != nil {
		fields = append(fields, userdevice.FieldAppVersion)
	}
	if m.device_model != nil {
		fields = append(fields, userdevice.FieldDeviceModel)
	}
	if m.status != nil {
		fields = append(fields, userdevice.FieldStatus)
	}
	if m.comments != nil {
		fields = append(fields, userdevice.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.CreatedBy()
	case userdevice.FieldCreatedAt:
		return m.CreatedAt()
	case userdevice.FieldUpdatedBy:
		return m.UpdatedBy()
	case userdevice.FieldUpdatedAt:
		return m.UpdatedAt()
	case userdevice.FieldUserID:
		return m.UserID()
	case userdevice.FieldDeviceUID:
		return m.DeviceUID()
	case userdevice.FieldDeviceName:
		return m.DeviceName()
	case userdevice.FieldSystemName:
		return m.SystemName()
	case userdevice.FieldSystemVersion:
		return m.SystemVersion()
	case userdevice.FieldAppVersion:
		return m.AppVersion()
	case userdevice.FieldDeviceModel:
		return m.DeviceModel()
	case userdevice.FieldStatus:
		return m.Status()
	case userdevice.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userdevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userdevice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userdevice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userdevice.FieldUserID:
		return m.OldUserID(ctx)
	case userdevice.FieldDeviceUID:
		return m.OldDeviceUID(ctx)
	case userdevice.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case userdevice.FieldSystemName:
		return m.OldSystemName(ctx)
	case userdevice.FieldSystemVersion:
		return m.OldSystemVersion(ctx)
	case userdevice.FieldAppVersion:
		return m.OldAppVersion(ctx)
	case userdevice.FieldDeviceModel:
		return m.OldDeviceModel(ctx)
	case userdevice.FieldStatus:
		return m.OldStatus(ctx)
	case userdevice.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown UserDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userdevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userdevice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userdevice.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userdevice.FieldDeviceUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceUID(v)
		return nil
	case userdevice.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case userdevice.FieldSystemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemName(v)
		return nil
	case userdevice.FieldSystemVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemVersion(v)
		return nil
	case userdevice.FieldAppVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppVersion(v)
		return nil
	case userdevice.FieldDeviceModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceModel(v)
		return nil
	case userdevice.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case userdevice.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserDeviceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserDeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userdevice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserDeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userdevice.FieldUpdatedBy) {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	if m.FieldCleared(userdevice.FieldUpdatedAt) {
		fields = append(fields, userdevice.FieldUpdatedAt)
	}
	if m.FieldCleared(userdevice.FieldUserID) {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.FieldCleared(userdevice.FieldDeviceName) {
		fields = append(fields, userdevice.FieldDeviceName)
	}
	if m.FieldCleared(userdevice.FieldSystemName) {
		fields = append(fields, userdevice.FieldSystemName)
	}
	if m.FieldCleared(userdevice.FieldSystemVersion) {
		fields = append(fields, userdevice.FieldSystemVersion)
	}
	if m.FieldCleared(userdevice.FieldAppVersion) {
		fields = append(fields, userdevice.FieldAppVersion)
	}
	if m.FieldCleared(userdevice.FieldDeviceModel) {
		fields = append(fields, userdevice.FieldDeviceModel)
	}
	if m.FieldCleared(userdevice.FieldStatus) {
		fields = append(fields, userdevice.FieldStatus)
	}
	if m.FieldCleared(userdevice.FieldComments) {
		fields = append(fields, userdevice.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDeviceMutation) ClearField(name string) error {
	switch name {
	case userdevice.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userdevice.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userdevice.FieldUserID:
		m.ClearUserID()
		return nil
	case userdevice.FieldDeviceName:
		m.ClearDeviceName()
		return nil
	case userdevice.FieldSystemName:
		m.ClearSystemName()
		return nil
	case userdevice.FieldSystemVersion:
		m.ClearSystemVersion()
		return nil
	case userdevice.FieldAppVersion:
		m.ClearAppVersion()
		return nil
	case userdevice.FieldDeviceModel:
		m.ClearDeviceModel()
		return nil
	case userdevice.FieldStatus:
		m.ClearStatus()
		return nil
	case userdevice.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown UserDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserDeviceMutation) ResetField(name string) error {
	switch name {
	case userdevice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userdevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userdevice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userdevice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userdevice.FieldUserID:
		m.ResetUserID()
		return nil
	case userdevice.FieldDeviceUID:
		m.ResetDeviceUID()
		return nil
	case userdevice.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case userdevice.FieldSystemName:
		m.ResetSystemName()
		return nil
	case userdevice.FieldSystemVersion:
		m.ResetSystemVersion()
		return nil
	case userdevice.FieldAppVersion:
		m.ResetAppVersion()
		return nil
	case userdevice.FieldDeviceModel:
		m.ResetDeviceModel()
		return nil
	case userdevice.FieldStatus:
		m.ResetStatus()
		return nil
	case userdevice.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userdevice.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userdevice.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserDeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userdevice.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case userdevice.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserDeviceMutation) ClearEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserDeviceMutation) ResetEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserDevice edge %s", name)
}

// UserIdentityMutation represents an operation that mutates the UserIdentity nodes in the graph.
type UserIdentityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	kind          *useridentity.Kind
	code          *string
	code_extend   *string
	status        *typex.SimpleStatus
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserIdentity, error)
	predicates    []predicate.UserIdentity
}

var _ ent.Mutation = (*UserIdentityMutation)(nil)

// useridentityOption allows management of the mutation configuration using functional options.
type useridentityOption func(*UserIdentityMutation)

// newUserIdentityMutation creates new mutation for the UserIdentity entity.
func newUserIdentityMutation(c config, op Op, opts ...useridentityOption) *UserIdentityMutation {
	m := &UserIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserIdentityID sets the ID field of the mutation.
func withUserIdentityID(id int) useridentityOption {
	return func(m *UserIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserIdentity
		)
		m.oldValue = func(ctx context.Context) (*UserIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserIdentity sets the old UserIdentity of the mutation.
func withUserIdentity(node *UserIdentity) useridentityOption {
	return func(m *UserIdentityMutation) {
		m.oldValue = func(context.Context) (*UserIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserIdentity entities.
func (m *UserIdentityMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserIdentityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserIdentityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserIdentityMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserIdentityMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserIdentityMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserIdentityMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserIdentityMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserIdentityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserIdentityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserIdentityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserIdentityMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserIdentityMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserIdentityMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserIdentityMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserIdentityMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[useridentity.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserIdentityMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserIdentityMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, useridentity.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserIdentityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserIdentityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserIdentityMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[useridentity.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserIdentityMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserIdentityMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, useridentity.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserIdentityMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserIdentityMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserIdentityMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[useridentity.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserIdentityMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserIdentityMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, useridentity.FieldUserID)
}

// SetKind sets the "kind" field.
func (m *UserIdentityMutation) SetKind(u useridentity.Kind) {
	m.kind = &u
}

// Kind returns the value of the "kind" field in the mutation.
func (m *UserIdentityMutation) Kind() (r useridentity.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldKind(ctx context.Context) (v useridentity.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *UserIdentityMutation) ResetKind() {
	m.kind = nil
}

// SetCode sets the "code" field.
func (m *UserIdentityMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *UserIdentityMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *UserIdentityMutation) ClearCode() {
	m.code = nil
	m.clearedFields[useridentity.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *UserIdentityMutation) CodeCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *UserIdentityMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, useridentity.FieldCode)
}

// SetCodeExtend sets the "code_extend" field.
func (m *UserIdentityMutation) SetCodeExtend(s string) {
	m.code_extend = &s
}

// CodeExtend returns the value of the "code_extend" field in the mutation.
func (m *UserIdentityMutation) CodeExtend() (r string, exists bool) {
	v := m.code_extend
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeExtend returns the old "code_extend" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCodeExtend(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeExtend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeExtend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeExtend: %w", err)
	}
	return oldValue.CodeExtend, nil
}

// ClearCodeExtend clears the value of the "code_extend" field.
func (m *UserIdentityMutation) ClearCodeExtend() {
	m.code_extend = nil
	m.clearedFields[useridentity.FieldCodeExtend] = struct{}{}
}

// CodeExtendCleared returns if the "code_extend" field was cleared in this mutation.
func (m *UserIdentityMutation) CodeExtendCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldCodeExtend]
	return ok
}

// ResetCodeExtend resets all changes to the "code_extend" field.
func (m *UserIdentityMutation) ResetCodeExtend() {
	m.code_extend = nil
	delete(m.clearedFields, useridentity.FieldCodeExtend)
}

// SetStatus sets the "status" field.
func (m *UserIdentityMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *UserIdentityMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserIdentityMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[useridentity.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserIdentityMutation) StatusCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserIdentityMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, useridentity.FieldStatus)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserIdentityMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserIdentityMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserIdentityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserIdentityMutation builder.
func (m *UserIdentityMutation) Where(ps ...predicate.UserIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserIdentity).
func (m *UserIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserIdentityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, useridentity.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, useridentity.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, useridentity.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, useridentity.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.kind != nil {
		fields = append(fields, useridentity.FieldKind)
	}
	if m.code != nil {
		fields = append(fields, useridentity.FieldCode)
	}
	if m.code_extend != nil {
		fields = append(fields, useridentity.FieldCodeExtend)
	}
	if m.status != nil {
		fields = append(fields, useridentity.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useridentity.FieldCreatedBy:
		return m.CreatedBy()
	case useridentity.FieldCreatedAt:
		return m.CreatedAt()
	case useridentity.FieldUpdatedBy:
		return m.UpdatedBy()
	case useridentity.FieldUpdatedAt:
		return m.UpdatedAt()
	case useridentity.FieldUserID:
		return m.UserID()
	case useridentity.FieldKind:
		return m.Kind()
	case useridentity.FieldCode:
		return m.Code()
	case useridentity.FieldCodeExtend:
		return m.CodeExtend()
	case useridentity.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useridentity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case useridentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case useridentity.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case useridentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case useridentity.FieldUserID:
		return m.OldUserID(ctx)
	case useridentity.FieldKind:
		return m.OldKind(ctx)
	case useridentity.FieldCode:
		return m.OldCode(ctx)
	case useridentity.FieldCodeExtend:
		return m.OldCodeExtend(ctx)
	case useridentity.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useridentity.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case useridentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useridentity.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case useridentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case useridentity.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useridentity.FieldKind:
		v, ok := value.(useridentity.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case useridentity.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case useridentity.FieldCodeExtend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeExtend(v)
		return nil
	case useridentity.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserIdentityMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, useridentity.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, useridentity.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserIdentityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case useridentity.FieldCreatedBy:
		return m.AddedCreatedBy()
	case useridentity.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case useridentity.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case useridentity.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserIdentityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useridentity.FieldUpdatedBy) {
		fields = append(fields, useridentity.FieldUpdatedBy)
	}
	if m.FieldCleared(useridentity.FieldUpdatedAt) {
		fields = append(fields, useridentity.FieldUpdatedAt)
	}
	if m.FieldCleared(useridentity.FieldUserID) {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.FieldCleared(useridentity.FieldCode) {
		fields = append(fields, useridentity.FieldCode)
	}
	if m.FieldCleared(useridentity.FieldCodeExtend) {
		fields = append(fields, useridentity.FieldCodeExtend)
	}
	if m.FieldCleared(useridentity.FieldStatus) {
		fields = append(fields, useridentity.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserIdentityMutation) ClearField(name string) error {
	switch name {
	case useridentity.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case useridentity.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case useridentity.FieldUserID:
		m.ClearUserID()
		return nil
	case useridentity.FieldCode:
		m.ClearCode()
		return nil
	case useridentity.FieldCodeExtend:
		m.ClearCodeExtend()
		return nil
	case useridentity.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserIdentityMutation) ResetField(name string) error {
	switch name {
	case useridentity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case useridentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useridentity.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case useridentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case useridentity.FieldUserID:
		m.ResetUserID()
		return nil
	case useridentity.FieldKind:
		m.ResetKind()
		return nil
	case useridentity.FieldCode:
		m.ResetCode()
		return nil
	case useridentity.FieldCodeExtend:
		m.ResetCodeExtend()
		return nil
	case useridentity.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useridentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserIdentityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case useridentity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserIdentityMutation) ClearEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserIdentityMutation) ResetEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity edge %s", name)
}

// UserLoginProfileMutation represents an operation that mutates the UserLoginProfile nodes in the graph.
type UserLoginProfileMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_by     *int
	addcreated_by  *int
	created_at     *time.Time
	updated_by     *int
	addupdated_by  *int
	updated_at     *time.Time
	last_login_ip  *string
	last_login_at  *time.Time
	can_login      *bool
	set_kind       *userloginprofile.SetKind
	password_reset *bool
	verify_device  *bool
	mfa_enabled    *bool
	mfa_secret     *string
	mfa_status     *typex.SimpleStatus
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserLoginProfile, error)
	predicates     []predicate.UserLoginProfile
}

var _ ent.Mutation = (*UserLoginProfileMutation)(nil)

// userloginprofileOption allows management of the mutation configuration using functional options.
type userloginprofileOption func(*UserLoginProfileMutation)

// newUserLoginProfileMutation creates new mutation for the UserLoginProfile entity.
func newUserLoginProfileMutation(c config, op Op, opts ...userloginprofileOption) *UserLoginProfileMutation {
	m := &UserLoginProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLoginProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginProfileID sets the ID field of the mutation.
func withUserLoginProfileID(id int) userloginprofileOption {
	return func(m *UserLoginProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLoginProfile
		)
		m.oldValue = func(ctx context.Context) (*UserLoginProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLoginProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLoginProfile sets the old UserLoginProfile of the mutation.
func withUserLoginProfile(node *UserLoginProfile) userloginprofileOption {
	return func(m *UserLoginProfileMutation) {
		m.oldValue = func(context.Context) (*UserLoginProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserLoginProfile entities.
func (m *UserLoginProfileMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLoginProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLoginProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLoginProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserLoginProfileMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserLoginProfileMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserLoginProfileMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserLoginProfileMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserLoginProfileMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLoginProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLoginProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLoginProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserLoginProfileMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserLoginProfileMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserLoginProfileMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserLoginProfileMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserLoginProfileMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userloginprofile.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserLoginProfileMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserLoginProfileMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userloginprofile.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserLoginProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserLoginProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserLoginProfileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userloginprofile.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserLoginProfileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserLoginProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userloginprofile.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserLoginProfileMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserLoginProfileMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserLoginProfileMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userloginprofile.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserLoginProfileMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserLoginProfileMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userloginprofile.FieldUserID)
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *UserLoginProfileMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *UserLoginProfileMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldLastLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *UserLoginProfileMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[userloginprofile.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *UserLoginProfileMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *UserLoginProfileMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, userloginprofile.FieldLastLoginIP)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserLoginProfileMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserLoginProfileMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserLoginProfileMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[userloginprofile.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserLoginProfileMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserLoginProfileMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, userloginprofile.FieldLastLoginAt)
}

// SetCanLogin sets the "can_login" field.
func (m *UserLoginProfileMutation) SetCanLogin(b bool) {
	m.can_login = &b
}

// CanLogin returns the value of the "can_login" field in the mutation.
func (m *UserLoginProfileMutation) CanLogin() (r bool, exists bool) {
	v := m.can_login
	if v == nil {
		return
	}
	return *v, true
}

// OldCanLogin returns the old "can_login" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldCanLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanLogin: %w", err)
	}
	return oldValue.CanLogin, nil
}

// ClearCanLogin clears the value of the "can_login" field.
func (m *UserLoginProfileMutation) ClearCanLogin() {
	m.can_login = nil
	m.clearedFields[userloginprofile.FieldCanLogin] = struct{}{}
}

// CanLoginCleared returns if the "can_login" field was cleared in this mutation.
func (m *UserLoginProfileMutation) CanLoginCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldCanLogin]
	return ok
}

// ResetCanLogin resets all changes to the "can_login" field.
func (m *UserLoginProfileMutation) ResetCanLogin() {
	m.can_login = nil
	delete(m.clearedFields, userloginprofile.FieldCanLogin)
}

// SetSetKind sets the "set_kind" field.
func (m *UserLoginProfileMutation) SetSetKind(uk userloginprofile.SetKind) {
	m.set_kind = &uk
}

// SetKind returns the value of the "set_kind" field in the mutation.
func (m *UserLoginProfileMutation) SetKind() (r userloginprofile.SetKind, exists bool) {
	v := m.set_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldSetKind returns the old "set_kind" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldSetKind(ctx context.Context) (v userloginprofile.SetKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetKind: %w", err)
	}
	return oldValue.SetKind, nil
}

// ResetSetKind resets all changes to the "set_kind" field.
func (m *UserLoginProfileMutation) ResetSetKind() {
	m.set_kind = nil
}

// SetPasswordReset sets the "password_reset" field.
func (m *UserLoginProfileMutation) SetPasswordReset(b bool) {
	m.password_reset = &b
}

// PasswordReset returns the value of the "password_reset" field in the mutation.
func (m *UserLoginProfileMutation) PasswordReset() (r bool, exists bool) {
	v := m.password_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordReset returns the old "password_reset" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldPasswordReset(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordReset: %w", err)
	}
	return oldValue.PasswordReset, nil
}

// ClearPasswordReset clears the value of the "password_reset" field.
func (m *UserLoginProfileMutation) ClearPasswordReset() {
	m.password_reset = nil
	m.clearedFields[userloginprofile.FieldPasswordReset] = struct{}{}
}

// PasswordResetCleared returns if the "password_reset" field was cleared in this mutation.
func (m *UserLoginProfileMutation) PasswordResetCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldPasswordReset]
	return ok
}

// ResetPasswordReset resets all changes to the "password_reset" field.
func (m *UserLoginProfileMutation) ResetPasswordReset() {
	m.password_reset = nil
	delete(m.clearedFields, userloginprofile.FieldPasswordReset)
}

// SetVerifyDevice sets the "verify_device" field.
func (m *UserLoginProfileMutation) SetVerifyDevice(b bool) {
	m.verify_device = &b
}

// VerifyDevice returns the value of the "verify_device" field in the mutation.
func (m *UserLoginProfileMutation) VerifyDevice() (r bool, exists bool) {
	v := m.verify_device
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyDevice returns the old "verify_device" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldVerifyDevice(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifyDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifyDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyDevice: %w", err)
	}
	return oldValue.VerifyDevice, nil
}

// ResetVerifyDevice resets all changes to the "verify_device" field.
func (m *UserLoginProfileMutation) ResetVerifyDevice() {
	m.verify_device = nil
}

// SetMfaEnabled sets the "mfa_enabled" field.
func (m *UserLoginProfileMutation) SetMfaEnabled(b bool) {
	m.mfa_enabled = &b
}

// MfaEnabled returns the value of the "mfa_enabled" field in the mutation.
func (m *UserLoginProfileMutation) MfaEnabled() (r bool, exists bool) {
	v := m.mfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaEnabled returns the old "mfa_enabled" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldMfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaEnabled: %w", err)
	}
	return oldValue.MfaEnabled, nil
}

// ClearMfaEnabled clears the value of the "mfa_enabled" field.
func (m *UserLoginProfileMutation) ClearMfaEnabled() {
	m.mfa_enabled = nil
	m.clearedFields[userloginprofile.FieldMfaEnabled] = struct{}{}
}

// MfaEnabledCleared returns if the "mfa_enabled" field was cleared in this mutation.
func (m *UserLoginProfileMutation) MfaEnabledCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldMfaEnabled]
	return ok
}

// ResetMfaEnabled resets all changes to the "mfa_enabled" field.
func (m *UserLoginProfileMutation) ResetMfaEnabled() {
	m.mfa_enabled = nil
	delete(m.clearedFields, userloginprofile.FieldMfaEnabled)
}

// SetMfaSecret sets the "mfa_secret" field.
func (m *UserLoginProfileMutation) SetMfaSecret(s string) {
	m.mfa_secret = &s
}

// MfaSecret returns the value of the "mfa_secret" field in the mutation.
func (m *UserLoginProfileMutation) MfaSecret() (r string, exists bool) {
	v := m.mfa_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaSecret returns the old "mfa_secret" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldMfaSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaSecret: %w", err)
	}
	return oldValue.MfaSecret, nil
}

// ClearMfaSecret clears the value of the "mfa_secret" field.
func (m *UserLoginProfileMutation) ClearMfaSecret() {
	m.mfa_secret = nil
	m.clearedFields[userloginprofile.FieldMfaSecret] = struct{}{}
}

// MfaSecretCleared returns if the "mfa_secret" field was cleared in this mutation.
func (m *UserLoginProfileMutation) MfaSecretCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldMfaSecret]
	return ok
}

// ResetMfaSecret resets all changes to the "mfa_secret" field.
func (m *UserLoginProfileMutation) ResetMfaSecret() {
	m.mfa_secret = nil
	delete(m.clearedFields, userloginprofile.FieldMfaSecret)
}

// SetMfaStatus sets the "mfa_status" field.
func (m *UserLoginProfileMutation) SetMfaStatus(ts typex.SimpleStatus) {
	m.mfa_status = &ts
}

// MfaStatus returns the value of the "mfa_status" field in the mutation.
func (m *UserLoginProfileMutation) MfaStatus() (r typex.SimpleStatus, exists bool) {
	v := m.mfa_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaStatus returns the old "mfa_status" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldMfaStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaStatus: %w", err)
	}
	return oldValue.MfaStatus, nil
}

// ClearMfaStatus clears the value of the "mfa_status" field.
func (m *UserLoginProfileMutation) ClearMfaStatus() {
	m.mfa_status = nil
	m.clearedFields[userloginprofile.FieldMfaStatus] = struct{}{}
}

// MfaStatusCleared returns if the "mfa_status" field was cleared in this mutation.
func (m *UserLoginProfileMutation) MfaStatusCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldMfaStatus]
	return ok
}

// ResetMfaStatus resets all changes to the "mfa_status" field.
func (m *UserLoginProfileMutation) ResetMfaStatus() {
	m.mfa_status = nil
	delete(m.clearedFields, userloginprofile.FieldMfaStatus)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserLoginProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserLoginProfileMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserLoginProfileMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserLoginProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserLoginProfileMutation builder.
func (m *UserLoginProfileMutation) Where(ps ...predicate.UserLoginProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLoginProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLoginProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLoginProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLoginProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLoginProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLoginProfile).
func (m *UserLoginProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginProfileMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, userloginprofile.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userloginprofile.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userloginprofile.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userloginprofile.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userloginprofile.FieldUserID)
	}
	if m.last_login_ip != nil {
		fields = append(fields, userloginprofile.FieldLastLoginIP)
	}
	if m.last_login_at != nil {
		fields = append(fields, userloginprofile.FieldLastLoginAt)
	}
	if m.can_login != nil {
		fields = append(fields, userloginprofile.FieldCanLogin)
	}
	if m.set_kind != nil {
		fields = append(fields, userloginprofile.FieldSetKind)
	}
	if m.password_reset != nil {
		fields = append(fields, userloginprofile.FieldPasswordReset)
	}
	if m.verify_device != nil {
		fields = append(fields, userloginprofile.FieldVerifyDevice)
	}
	if m.mfa_enabled != nil {
		fields = append(fields, userloginprofile.FieldMfaEnabled)
	}
	if m.mfa_secret != nil {
		fields = append(fields, userloginprofile.FieldMfaSecret)
	}
	if m.mfa_status != nil {
		fields = append(fields, userloginprofile.FieldMfaStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userloginprofile.FieldCreatedBy:
		return m.CreatedBy()
	case userloginprofile.FieldCreatedAt:
		return m.CreatedAt()
	case userloginprofile.FieldUpdatedBy:
		return m.UpdatedBy()
	case userloginprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case userloginprofile.FieldUserID:
		return m.UserID()
	case userloginprofile.FieldLastLoginIP:
		return m.LastLoginIP()
	case userloginprofile.FieldLastLoginAt:
		return m.LastLoginAt()
	case userloginprofile.FieldCanLogin:
		return m.CanLogin()
	case userloginprofile.FieldSetKind:
		return m.SetKind()
	case userloginprofile.FieldPasswordReset:
		return m.PasswordReset()
	case userloginprofile.FieldVerifyDevice:
		return m.VerifyDevice()
	case userloginprofile.FieldMfaEnabled:
		return m.MfaEnabled()
	case userloginprofile.FieldMfaSecret:
		return m.MfaSecret()
	case userloginprofile.FieldMfaStatus:
		return m.MfaStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userloginprofile.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userloginprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userloginprofile.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userloginprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userloginprofile.FieldUserID:
		return m.OldUserID(ctx)
	case userloginprofile.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case userloginprofile.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case userloginprofile.FieldCanLogin:
		return m.OldCanLogin(ctx)
	case userloginprofile.FieldSetKind:
		return m.OldSetKind(ctx)
	case userloginprofile.FieldPasswordReset:
		return m.OldPasswordReset(ctx)
	case userloginprofile.FieldVerifyDevice:
		return m.OldVerifyDevice(ctx)
	case userloginprofile.FieldMfaEnabled:
		return m.OldMfaEnabled(ctx)
	case userloginprofile.FieldMfaSecret:
		return m.OldMfaSecret(ctx)
	case userloginprofile.FieldMfaStatus:
		return m.OldMfaStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserLoginProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userloginprofile.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userloginprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userloginprofile.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userloginprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userloginprofile.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userloginprofile.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case userloginprofile.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case userloginprofile.FieldCanLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanLogin(v)
		return nil
	case userloginprofile.FieldSetKind:
		v, ok := value.(userloginprofile.SetKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetKind(v)
		return nil
	case userloginprofile.FieldPasswordReset:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordReset(v)
		return nil
	case userloginprofile.FieldVerifyDevice:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyDevice(v)
		return nil
	case userloginprofile.FieldMfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaEnabled(v)
		return nil
	case userloginprofile.FieldMfaSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaSecret(v)
		return nil
	case userloginprofile.FieldMfaStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginProfileMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userloginprofile.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userloginprofile.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userloginprofile.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userloginprofile.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userloginprofile.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userloginprofile.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userloginprofile.FieldUpdatedBy) {
		fields = append(fields, userloginprofile.FieldUpdatedBy)
	}
	if m.FieldCleared(userloginprofile.FieldUpdatedAt) {
		fields = append(fields, userloginprofile.FieldUpdatedAt)
	}
	if m.FieldCleared(userloginprofile.FieldUserID) {
		fields = append(fields, userloginprofile.FieldUserID)
	}
	if m.FieldCleared(userloginprofile.FieldLastLoginIP) {
		fields = append(fields, userloginprofile.FieldLastLoginIP)
	}
	if m.FieldCleared(userloginprofile.FieldLastLoginAt) {
		fields = append(fields, userloginprofile.FieldLastLoginAt)
	}
	if m.FieldCleared(userloginprofile.FieldCanLogin) {
		fields = append(fields, userloginprofile.FieldCanLogin)
	}
	if m.FieldCleared(userloginprofile.FieldPasswordReset) {
		fields = append(fields, userloginprofile.FieldPasswordReset)
	}
	if m.FieldCleared(userloginprofile.FieldMfaEnabled) {
		fields = append(fields, userloginprofile.FieldMfaEnabled)
	}
	if m.FieldCleared(userloginprofile.FieldMfaSecret) {
		fields = append(fields, userloginprofile.FieldMfaSecret)
	}
	if m.FieldCleared(userloginprofile.FieldMfaStatus) {
		fields = append(fields, userloginprofile.FieldMfaStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginProfileMutation) ClearField(name string) error {
	switch name {
	case userloginprofile.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userloginprofile.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userloginprofile.FieldUserID:
		m.ClearUserID()
		return nil
	case userloginprofile.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	case userloginprofile.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case userloginprofile.FieldCanLogin:
		m.ClearCanLogin()
		return nil
	case userloginprofile.FieldPasswordReset:
		m.ClearPasswordReset()
		return nil
	case userloginprofile.FieldMfaEnabled:
		m.ClearMfaEnabled()
		return nil
	case userloginprofile.FieldMfaSecret:
		m.ClearMfaSecret()
		return nil
	case userloginprofile.FieldMfaStatus:
		m.ClearMfaStatus()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginProfileMutation) ResetField(name string) error {
	switch name {
	case userloginprofile.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userloginprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userloginprofile.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userloginprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userloginprofile.FieldUserID:
		m.ResetUserID()
		return nil
	case userloginprofile.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case userloginprofile.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case userloginprofile.FieldCanLogin:
		m.ResetCanLogin()
		return nil
	case userloginprofile.FieldSetKind:
		m.ResetSetKind()
		return nil
	case userloginprofile.FieldPasswordReset:
		m.ResetPasswordReset()
		return nil
	case userloginprofile.FieldVerifyDevice:
		m.ResetVerifyDevice()
		return nil
	case userloginprofile.FieldMfaEnabled:
		m.ResetMfaEnabled()
		return nil
	case userloginprofile.FieldMfaSecret:
		m.ResetMfaSecret()
		return nil
	case userloginprofile.FieldMfaStatus:
		m.ResetMfaStatus()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userloginprofile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userloginprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userloginprofile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userloginprofile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginProfileMutation) ClearEdge(name string) error {
	switch name {
	case userloginprofile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginProfileMutation) ResetEdge(name string) error {
	switch name {
	case userloginprofile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile edge %s", name)
}

// UserPasswordMutation represents an operation that mutates the UserPassword nodes in the graph.
type UserPasswordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	scene         *userpassword.Scene
	password      *string
	salt          *string
	status        *typex.SimpleStatus
	memo          *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserPassword, error)
	predicates    []predicate.UserPassword
}

var _ ent.Mutation = (*UserPasswordMutation)(nil)

// userpasswordOption allows management of the mutation configuration using functional options.
type userpasswordOption func(*UserPasswordMutation)

// newUserPasswordMutation creates new mutation for the UserPassword entity.
func newUserPasswordMutation(c config, op Op, opts ...userpasswordOption) *UserPasswordMutation {
	m := &UserPasswordMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPassword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPasswordID sets the ID field of the mutation.
func withUserPasswordID(id int) userpasswordOption {
	return func(m *UserPasswordMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPassword
		)
		m.oldValue = func(ctx context.Context) (*UserPassword, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPassword.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPassword sets the old UserPassword of the mutation.
func withUserPassword(node *UserPassword) userpasswordOption {
	return func(m *UserPasswordMutation) {
		m.oldValue = func(context.Context) (*UserPassword, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPasswordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPasswordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPassword entities.
func (m *UserPasswordMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPasswordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPasswordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPassword.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserPasswordMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserPasswordMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserPasswordMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserPasswordMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserPasswordMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserPasswordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserPasswordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserPasswordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserPasswordMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserPasswordMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserPasswordMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserPasswordMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserPasswordMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userpassword.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserPasswordMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserPasswordMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userpassword.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserPasswordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserPasswordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserPasswordMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userpassword.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserPasswordMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserPasswordMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userpassword.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserPasswordMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPasswordMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserPasswordMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userpassword.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserPasswordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPasswordMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userpassword.FieldUserID)
}

// SetScene sets the "scene" field.
func (m *UserPasswordMutation) SetScene(u userpassword.Scene) {
	m.scene = &u
}

// Scene returns the value of the "scene" field in the mutation.
func (m *UserPasswordMutation) Scene() (r userpassword.Scene, exists bool) {
	v := m.scene
	if v == nil {
		return
	}
	return *v, true
}

// OldScene returns the old "scene" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldScene(ctx context.Context) (v userpassword.Scene, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScene is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScene requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScene: %w", err)
	}
	return oldValue.Scene, nil
}

// ClearScene clears the value of the "scene" field.
func (m *UserPasswordMutation) ClearScene() {
	m.scene = nil
	m.clearedFields[userpassword.FieldScene] = struct{}{}
}

// SceneCleared returns if the "scene" field was cleared in this mutation.
func (m *UserPasswordMutation) SceneCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldScene]
	return ok
}

// ResetScene resets all changes to the "scene" field.
func (m *UserPasswordMutation) ResetScene() {
	m.scene = nil
	delete(m.clearedFields, userpassword.FieldScene)
}

// SetPassword sets the "password" field.
func (m *UserPasswordMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserPasswordMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserPasswordMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[userpassword.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserPasswordMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserPasswordMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, userpassword.FieldPassword)
}

// SetSalt sets the "salt" field.
func (m *UserPasswordMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *UserPasswordMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *UserPasswordMutation) ResetSalt() {
	m.salt = nil
}

// SetStatus sets the "status" field.
func (m *UserPasswordMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *UserPasswordMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserPasswordMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[userpassword.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserPasswordMutation) StatusCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserPasswordMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, userpassword.FieldStatus)
}

// SetMemo sets the "memo" field.
func (m *UserPasswordMutation) SetMemo(s string) {
	m.memo = &s
}

// Memo returns the value of the "memo" field in the mutation.
func (m *UserPasswordMutation) Memo() (r string, exists bool) {
	v := m.memo
	if v == nil {
		return
	}
	return *v, true
}

// OldMemo returns the old "memo" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldMemo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemo: %w", err)
	}
	return oldValue.Memo, nil
}

// ClearMemo clears the value of the "memo" field.
func (m *UserPasswordMutation) ClearMemo() {
	m.memo = nil
	m.clearedFields[userpassword.FieldMemo] = struct{}{}
}

// MemoCleared returns if the "memo" field was cleared in this mutation.
func (m *UserPasswordMutation) MemoCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldMemo]
	return ok
}

// ResetMemo resets all changes to the "memo" field.
func (m *UserPasswordMutation) ResetMemo() {
	m.memo = nil
	delete(m.clearedFields, userpassword.FieldMemo)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserPasswordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserPasswordMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserPasswordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserPasswordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserPasswordMutation builder.
func (m *UserPasswordMutation) Where(ps ...predicate.UserPassword) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPasswordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPasswordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPassword, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPasswordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPasswordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPassword).
func (m *UserPasswordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPasswordMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, userpassword.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userpassword.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userpassword.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userpassword.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userpassword.FieldUserID)
	}
	if m.scene != nil {
		fields = append(fields, userpassword.FieldScene)
	}
	if m.password != nil {
		fields = append(fields, userpassword.FieldPassword)
	}
	if m.salt != nil {
		fields = append(fields, userpassword.FieldSalt)
	}
	if m.status != nil {
		fields = append(fields, userpassword.FieldStatus)
	}
	if m.memo != nil {
		fields = append(fields, userpassword.FieldMemo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPasswordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpassword.FieldCreatedBy:
		return m.CreatedBy()
	case userpassword.FieldCreatedAt:
		return m.CreatedAt()
	case userpassword.FieldUpdatedBy:
		return m.UpdatedBy()
	case userpassword.FieldUpdatedAt:
		return m.UpdatedAt()
	case userpassword.FieldUserID:
		return m.UserID()
	case userpassword.FieldScene:
		return m.Scene()
	case userpassword.FieldPassword:
		return m.Password()
	case userpassword.FieldSalt:
		return m.Salt()
	case userpassword.FieldStatus:
		return m.Status()
	case userpassword.FieldMemo:
		return m.Memo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpassword.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userpassword.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userpassword.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userpassword.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userpassword.FieldUserID:
		return m.OldUserID(ctx)
	case userpassword.FieldScene:
		return m.OldScene(ctx)
	case userpassword.FieldPassword:
		return m.OldPassword(ctx)
	case userpassword.FieldSalt:
		return m.OldSalt(ctx)
	case userpassword.FieldStatus:
		return m.OldStatus(ctx)
	case userpassword.FieldMemo:
		return m.OldMemo(ctx)
	}
	return nil, fmt.Errorf("unknown UserPassword field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPasswordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpassword.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userpassword.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userpassword.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userpassword.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userpassword.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userpassword.FieldScene:
		v, ok := value.(userpassword.Scene)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScene(v)
		return nil
	case userpassword.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case userpassword.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case userpassword.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case userpassword.FieldMemo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemo(v)
		return nil
	}
	return fmt.Errorf("unknown UserPassword field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPasswordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userpassword.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userpassword.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPasswordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userpassword.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userpassword.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPasswordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userpassword.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userpassword.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserPassword numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPasswordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userpassword.FieldUpdatedBy) {
		fields = append(fields, userpassword.FieldUpdatedBy)
	}
	if m.FieldCleared(userpassword.FieldUpdatedAt) {
		fields = append(fields, userpassword.FieldUpdatedAt)
	}
	if m.FieldCleared(userpassword.FieldUserID) {
		fields = append(fields, userpassword.FieldUserID)
	}
	if m.FieldCleared(userpassword.FieldScene) {
		fields = append(fields, userpassword.FieldScene)
	}
	if m.FieldCleared(userpassword.FieldPassword) {
		fields = append(fields, userpassword.FieldPassword)
	}
	if m.FieldCleared(userpassword.FieldStatus) {
		fields = append(fields, userpassword.FieldStatus)
	}
	if m.FieldCleared(userpassword.FieldMemo) {
		fields = append(fields, userpassword.FieldMemo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPasswordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPasswordMutation) ClearField(name string) error {
	switch name {
	case userpassword.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userpassword.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userpassword.FieldUserID:
		m.ClearUserID()
		return nil
	case userpassword.FieldScene:
		m.ClearScene()
		return nil
	case userpassword.FieldPassword:
		m.ClearPassword()
		return nil
	case userpassword.FieldStatus:
		m.ClearStatus()
		return nil
	case userpassword.FieldMemo:
		m.ClearMemo()
		return nil
	}
	return fmt.Errorf("unknown UserPassword nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPasswordMutation) ResetField(name string) error {
	switch name {
	case userpassword.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userpassword.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userpassword.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userpassword.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userpassword.FieldUserID:
		m.ResetUserID()
		return nil
	case userpassword.FieldScene:
		m.ResetScene()
		return nil
	case userpassword.FieldPassword:
		m.ResetPassword()
		return nil
	case userpassword.FieldSalt:
		m.ResetSalt()
		return nil
	case userpassword.FieldStatus:
		m.ResetStatus()
		return nil
	case userpassword.FieldMemo:
		m.ResetMemo()
		return nil
	}
	return fmt.Errorf("unknown UserPassword field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPasswordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userpassword.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPasswordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userpassword.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPasswordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPasswordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPasswordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userpassword.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPasswordMutation) EdgeCleared(name string) bool {
	switch name {
	case userpassword.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPasswordMutation) ClearEdge(name string) error {
	switch name {
	case userpassword.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserPassword unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPasswordMutation) ResetEdge(name string) error {
	switch name {
	case userpassword.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserPassword edge %s", name)
}
