// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/woocoos/entco/schemax/typex"
	"github.com/woocoos/knockout/codegen/entgen/types"
	"github.com/woocoos/knockout/ent/app"
	"github.com/woocoos/knockout/ent/appaction"
	"github.com/woocoos/knockout/ent/appmenu"
	"github.com/woocoos/knockout/ent/apppolicy"
	"github.com/woocoos/knockout/ent/appres"
	"github.com/woocoos/knockout/ent/approle"
	"github.com/woocoos/knockout/ent/approlepolicy"
	"github.com/woocoos/knockout/ent/file"
	"github.com/woocoos/knockout/ent/filesource"
	"github.com/woocoos/knockout/ent/oauthclient"
	"github.com/woocoos/knockout/ent/org"
	"github.com/woocoos/knockout/ent/orgapp"
	"github.com/woocoos/knockout/ent/orgpolicy"
	"github.com/woocoos/knockout/ent/orgrole"
	"github.com/woocoos/knockout/ent/orgroleuser"
	"github.com/woocoos/knockout/ent/orguser"
	"github.com/woocoos/knockout/ent/orguserpreference"
	"github.com/woocoos/knockout/ent/permission"
	"github.com/woocoos/knockout/ent/predicate"
	"github.com/woocoos/knockout/ent/user"
	"github.com/woocoos/knockout/ent/userdevice"
	"github.com/woocoos/knockout/ent/useridentity"
	"github.com/woocoos/knockout/ent/userloginprofile"
	"github.com/woocoos/knockout/ent/userpassword"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp               = "App"
	TypeAppAction         = "AppAction"
	TypeAppMenu           = "AppMenu"
	TypeAppPolicy         = "AppPolicy"
	TypeAppRes            = "AppRes"
	TypeAppRole           = "AppRole"
	TypeAppRolePolicy     = "AppRolePolicy"
	TypeFile              = "File"
	TypeFileSource        = "FileSource"
	TypeOauthClient       = "OauthClient"
	TypeOrg               = "Org"
	TypeOrgApp            = "OrgApp"
	TypeOrgPolicy         = "OrgPolicy"
	TypeOrgRole           = "OrgRole"
	TypeOrgRoleUser       = "OrgRoleUser"
	TypeOrgUser           = "OrgUser"
	TypeOrgUserPreference = "OrgUserPreference"
	TypePermission        = "Permission"
	TypeUser              = "User"
	TypeUserDevice        = "UserDevice"
	TypeUserIdentity      = "UserIdentity"
	TypeUserLoginProfile  = "UserLoginProfile"
	TypeUserPassword      = "UserPassword"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	created_by                *int
	addcreated_by             *int
	created_at                *time.Time
	updated_by                *int
	addupdated_by             *int
	updated_at                *time.Time
	name                      *string
	code                      *string
	kind                      *app.Kind
	redirect_uri              *string
	app_key                   *string
	app_secret                *string
	scopes                    *string
	token_validity            *int32
	addtoken_validity         *int32
	refresh_token_validity    *int32
	addrefresh_token_validity *int32
	logo_file_id              *int
	addlogo_file_id           *int
	comments                  *string
	status                    *typex.SimpleStatus
	private                   *bool
	owner_org_id              *int
	addowner_org_id           *int
	clearedFields             map[string]struct{}
	menus                     map[int]struct{}
	removedmenus              map[int]struct{}
	clearedmenus              bool
	actions                   map[int]struct{}
	removedactions            map[int]struct{}
	clearedactions            bool
	resources                 map[int]struct{}
	removedresources          map[int]struct{}
	clearedresources          bool
	roles                     map[int]struct{}
	removedroles              map[int]struct{}
	clearedroles              bool
	policies                  map[int]struct{}
	removedpolicies           map[int]struct{}
	clearedpolicies           bool
	orgs                      map[int]struct{}
	removedorgs               map[int]struct{}
	clearedorgs               bool
	org_app                   map[int]struct{}
	removedorg_app            map[int]struct{}
	clearedorg_app            bool
	done                      bool
	oldValue                  func(context.Context) (*App, error)
	predicates                []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id int) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[app.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[app.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, app.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[app.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[app.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, app.FieldUpdatedAt)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *AppMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AppMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *AppMutation) ResetCode() {
	m.code = nil
}

// SetKind sets the "kind" field.
func (m *AppMutation) SetKind(a app.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AppMutation) Kind() (r app.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldKind(ctx context.Context) (v app.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AppMutation) ResetKind() {
	m.kind = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *AppMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *AppMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ClearRedirectURI clears the value of the "redirect_uri" field.
func (m *AppMutation) ClearRedirectURI() {
	m.redirect_uri = nil
	m.clearedFields[app.FieldRedirectURI] = struct{}{}
}

// RedirectURICleared returns if the "redirect_uri" field was cleared in this mutation.
func (m *AppMutation) RedirectURICleared() bool {
	_, ok := m.clearedFields[app.FieldRedirectURI]
	return ok
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *AppMutation) ResetRedirectURI() {
	m.redirect_uri = nil
	delete(m.clearedFields, app.FieldRedirectURI)
}

// SetAppKey sets the "app_key" field.
func (m *AppMutation) SetAppKey(s string) {
	m.app_key = &s
}

// AppKey returns the value of the "app_key" field in the mutation.
func (m *AppMutation) AppKey() (r string, exists bool) {
	v := m.app_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAppKey returns the old "app_key" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAppKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppKey: %w", err)
	}
	return oldValue.AppKey, nil
}

// ClearAppKey clears the value of the "app_key" field.
func (m *AppMutation) ClearAppKey() {
	m.app_key = nil
	m.clearedFields[app.FieldAppKey] = struct{}{}
}

// AppKeyCleared returns if the "app_key" field was cleared in this mutation.
func (m *AppMutation) AppKeyCleared() bool {
	_, ok := m.clearedFields[app.FieldAppKey]
	return ok
}

// ResetAppKey resets all changes to the "app_key" field.
func (m *AppMutation) ResetAppKey() {
	m.app_key = nil
	delete(m.clearedFields, app.FieldAppKey)
}

// SetAppSecret sets the "app_secret" field.
func (m *AppMutation) SetAppSecret(s string) {
	m.app_secret = &s
}

// AppSecret returns the value of the "app_secret" field in the mutation.
func (m *AppMutation) AppSecret() (r string, exists bool) {
	v := m.app_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSecret returns the old "app_secret" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAppSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSecret: %w", err)
	}
	return oldValue.AppSecret, nil
}

// ClearAppSecret clears the value of the "app_secret" field.
func (m *AppMutation) ClearAppSecret() {
	m.app_secret = nil
	m.clearedFields[app.FieldAppSecret] = struct{}{}
}

// AppSecretCleared returns if the "app_secret" field was cleared in this mutation.
func (m *AppMutation) AppSecretCleared() bool {
	_, ok := m.clearedFields[app.FieldAppSecret]
	return ok
}

// ResetAppSecret resets all changes to the "app_secret" field.
func (m *AppMutation) ResetAppSecret() {
	m.app_secret = nil
	delete(m.clearedFields, app.FieldAppSecret)
}

// SetScopes sets the "scopes" field.
func (m *AppMutation) SetScopes(s string) {
	m.scopes = &s
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *AppMutation) Scopes() (r string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// ClearScopes clears the value of the "scopes" field.
func (m *AppMutation) ClearScopes() {
	m.scopes = nil
	m.clearedFields[app.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *AppMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[app.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *AppMutation) ResetScopes() {
	m.scopes = nil
	delete(m.clearedFields, app.FieldScopes)
}

// SetTokenValidity sets the "token_validity" field.
func (m *AppMutation) SetTokenValidity(i int32) {
	m.token_validity = &i
	m.addtoken_validity = nil
}

// TokenValidity returns the value of the "token_validity" field in the mutation.
func (m *AppMutation) TokenValidity() (r int32, exists bool) {
	v := m.token_validity
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenValidity returns the old "token_validity" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldTokenValidity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenValidity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenValidity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenValidity: %w", err)
	}
	return oldValue.TokenValidity, nil
}

// AddTokenValidity adds i to the "token_validity" field.
func (m *AppMutation) AddTokenValidity(i int32) {
	if m.addtoken_validity != nil {
		*m.addtoken_validity += i
	} else {
		m.addtoken_validity = &i
	}
}

// AddedTokenValidity returns the value that was added to the "token_validity" field in this mutation.
func (m *AppMutation) AddedTokenValidity() (r int32, exists bool) {
	v := m.addtoken_validity
	if v == nil {
		return
	}
	return *v, true
}

// ClearTokenValidity clears the value of the "token_validity" field.
func (m *AppMutation) ClearTokenValidity() {
	m.token_validity = nil
	m.addtoken_validity = nil
	m.clearedFields[app.FieldTokenValidity] = struct{}{}
}

// TokenValidityCleared returns if the "token_validity" field was cleared in this mutation.
func (m *AppMutation) TokenValidityCleared() bool {
	_, ok := m.clearedFields[app.FieldTokenValidity]
	return ok
}

// ResetTokenValidity resets all changes to the "token_validity" field.
func (m *AppMutation) ResetTokenValidity() {
	m.token_validity = nil
	m.addtoken_validity = nil
	delete(m.clearedFields, app.FieldTokenValidity)
}

// SetRefreshTokenValidity sets the "refresh_token_validity" field.
func (m *AppMutation) SetRefreshTokenValidity(i int32) {
	m.refresh_token_validity = &i
	m.addrefresh_token_validity = nil
}

// RefreshTokenValidity returns the value of the "refresh_token_validity" field in the mutation.
func (m *AppMutation) RefreshTokenValidity() (r int32, exists bool) {
	v := m.refresh_token_validity
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenValidity returns the old "refresh_token_validity" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRefreshTokenValidity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenValidity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenValidity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenValidity: %w", err)
	}
	return oldValue.RefreshTokenValidity, nil
}

// AddRefreshTokenValidity adds i to the "refresh_token_validity" field.
func (m *AppMutation) AddRefreshTokenValidity(i int32) {
	if m.addrefresh_token_validity != nil {
		*m.addrefresh_token_validity += i
	} else {
		m.addrefresh_token_validity = &i
	}
}

// AddedRefreshTokenValidity returns the value that was added to the "refresh_token_validity" field in this mutation.
func (m *AppMutation) AddedRefreshTokenValidity() (r int32, exists bool) {
	v := m.addrefresh_token_validity
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefreshTokenValidity clears the value of the "refresh_token_validity" field.
func (m *AppMutation) ClearRefreshTokenValidity() {
	m.refresh_token_validity = nil
	m.addrefresh_token_validity = nil
	m.clearedFields[app.FieldRefreshTokenValidity] = struct{}{}
}

// RefreshTokenValidityCleared returns if the "refresh_token_validity" field was cleared in this mutation.
func (m *AppMutation) RefreshTokenValidityCleared() bool {
	_, ok := m.clearedFields[app.FieldRefreshTokenValidity]
	return ok
}

// ResetRefreshTokenValidity resets all changes to the "refresh_token_validity" field.
func (m *AppMutation) ResetRefreshTokenValidity() {
	m.refresh_token_validity = nil
	m.addrefresh_token_validity = nil
	delete(m.clearedFields, app.FieldRefreshTokenValidity)
}

// SetLogoFileID sets the "logo_file_id" field.
func (m *AppMutation) SetLogoFileID(i int) {
	m.logo_file_id = &i
	m.addlogo_file_id = nil
}

// LogoFileID returns the value of the "logo_file_id" field in the mutation.
func (m *AppMutation) LogoFileID() (r int, exists bool) {
	v := m.logo_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoFileID returns the old "logo_file_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLogoFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoFileID: %w", err)
	}
	return oldValue.LogoFileID, nil
}

// AddLogoFileID adds i to the "logo_file_id" field.
func (m *AppMutation) AddLogoFileID(i int) {
	if m.addlogo_file_id != nil {
		*m.addlogo_file_id += i
	} else {
		m.addlogo_file_id = &i
	}
}

// AddedLogoFileID returns the value that was added to the "logo_file_id" field in this mutation.
func (m *AppMutation) AddedLogoFileID() (r int, exists bool) {
	v := m.addlogo_file_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearLogoFileID clears the value of the "logo_file_id" field.
func (m *AppMutation) ClearLogoFileID() {
	m.logo_file_id = nil
	m.addlogo_file_id = nil
	m.clearedFields[app.FieldLogoFileID] = struct{}{}
}

// LogoFileIDCleared returns if the "logo_file_id" field was cleared in this mutation.
func (m *AppMutation) LogoFileIDCleared() bool {
	_, ok := m.clearedFields[app.FieldLogoFileID]
	return ok
}

// ResetLogoFileID resets all changes to the "logo_file_id" field.
func (m *AppMutation) ResetLogoFileID() {
	m.logo_file_id = nil
	m.addlogo_file_id = nil
	delete(m.clearedFields, app.FieldLogoFileID)
}

// SetComments sets the "comments" field.
func (m *AppMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[app.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[app.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, app.FieldComments)
}

// SetStatus sets the "status" field.
func (m *AppMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *AppMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *AppMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[app.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AppMutation) StatusCleared() bool {
	_, ok := m.clearedFields[app.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AppMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, app.FieldStatus)
}

// SetPrivate sets the "private" field.
func (m *AppMutation) SetPrivate(b bool) {
	m.private = &b
}

// Private returns the value of the "private" field in the mutation.
func (m *AppMutation) Private() (r bool, exists bool) {
	v := m.private
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivate returns the old "private" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivate: %w", err)
	}
	return oldValue.Private, nil
}

// ClearPrivate clears the value of the "private" field.
func (m *AppMutation) ClearPrivate() {
	m.private = nil
	m.clearedFields[app.FieldPrivate] = struct{}{}
}

// PrivateCleared returns if the "private" field was cleared in this mutation.
func (m *AppMutation) PrivateCleared() bool {
	_, ok := m.clearedFields[app.FieldPrivate]
	return ok
}

// ResetPrivate resets all changes to the "private" field.
func (m *AppMutation) ResetPrivate() {
	m.private = nil
	delete(m.clearedFields, app.FieldPrivate)
}

// SetOwnerOrgID sets the "owner_org_id" field.
func (m *AppMutation) SetOwnerOrgID(i int) {
	m.owner_org_id = &i
	m.addowner_org_id = nil
}

// OwnerOrgID returns the value of the "owner_org_id" field in the mutation.
func (m *AppMutation) OwnerOrgID() (r int, exists bool) {
	v := m.owner_org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerOrgID returns the old "owner_org_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldOwnerOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerOrgID: %w", err)
	}
	return oldValue.OwnerOrgID, nil
}

// AddOwnerOrgID adds i to the "owner_org_id" field.
func (m *AppMutation) AddOwnerOrgID(i int) {
	if m.addowner_org_id != nil {
		*m.addowner_org_id += i
	} else {
		m.addowner_org_id = &i
	}
}

// AddedOwnerOrgID returns the value that was added to the "owner_org_id" field in this mutation.
func (m *AppMutation) AddedOwnerOrgID() (r int, exists bool) {
	v := m.addowner_org_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerOrgID clears the value of the "owner_org_id" field.
func (m *AppMutation) ClearOwnerOrgID() {
	m.owner_org_id = nil
	m.addowner_org_id = nil
	m.clearedFields[app.FieldOwnerOrgID] = struct{}{}
}

// OwnerOrgIDCleared returns if the "owner_org_id" field was cleared in this mutation.
func (m *AppMutation) OwnerOrgIDCleared() bool {
	_, ok := m.clearedFields[app.FieldOwnerOrgID]
	return ok
}

// ResetOwnerOrgID resets all changes to the "owner_org_id" field.
func (m *AppMutation) ResetOwnerOrgID() {
	m.owner_org_id = nil
	m.addowner_org_id = nil
	delete(m.clearedFields, app.FieldOwnerOrgID)
}

// AddMenuIDs adds the "menus" edge to the AppMenu entity by ids.
func (m *AppMutation) AddMenuIDs(ids ...int) {
	if m.menus == nil {
		m.menus = make(map[int]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the AppMenu entity.
func (m *AppMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the AppMenu entity was cleared.
func (m *AppMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the AppMenu entity by IDs.
func (m *AppMutation) RemoveMenuIDs(ids ...int) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the AppMenu entity.
func (m *AppMutation) RemovedMenusIDs() (ids []int) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *AppMutation) MenusIDs() (ids []int) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *AppMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddActionIDs adds the "actions" edge to the AppAction entity by ids.
func (m *AppMutation) AddActionIDs(ids ...int) {
	if m.actions == nil {
		m.actions = make(map[int]struct{})
	}
	for i := range ids {
		m.actions[ids[i]] = struct{}{}
	}
}

// ClearActions clears the "actions" edge to the AppAction entity.
func (m *AppMutation) ClearActions() {
	m.clearedactions = true
}

// ActionsCleared reports if the "actions" edge to the AppAction entity was cleared.
func (m *AppMutation) ActionsCleared() bool {
	return m.clearedactions
}

// RemoveActionIDs removes the "actions" edge to the AppAction entity by IDs.
func (m *AppMutation) RemoveActionIDs(ids ...int) {
	if m.removedactions == nil {
		m.removedactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.actions, ids[i])
		m.removedactions[ids[i]] = struct{}{}
	}
}

// RemovedActions returns the removed IDs of the "actions" edge to the AppAction entity.
func (m *AppMutation) RemovedActionsIDs() (ids []int) {
	for id := range m.removedactions {
		ids = append(ids, id)
	}
	return
}

// ActionsIDs returns the "actions" edge IDs in the mutation.
func (m *AppMutation) ActionsIDs() (ids []int) {
	for id := range m.actions {
		ids = append(ids, id)
	}
	return
}

// ResetActions resets all changes to the "actions" edge.
func (m *AppMutation) ResetActions() {
	m.actions = nil
	m.clearedactions = false
	m.removedactions = nil
}

// AddResourceIDs adds the "resources" edge to the AppRes entity by ids.
func (m *AppMutation) AddResourceIDs(ids ...int) {
	if m.resources == nil {
		m.resources = make(map[int]struct{})
	}
	for i := range ids {
		m.resources[ids[i]] = struct{}{}
	}
}

// ClearResources clears the "resources" edge to the AppRes entity.
func (m *AppMutation) ClearResources() {
	m.clearedresources = true
}

// ResourcesCleared reports if the "resources" edge to the AppRes entity was cleared.
func (m *AppMutation) ResourcesCleared() bool {
	return m.clearedresources
}

// RemoveResourceIDs removes the "resources" edge to the AppRes entity by IDs.
func (m *AppMutation) RemoveResourceIDs(ids ...int) {
	if m.removedresources == nil {
		m.removedresources = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.resources, ids[i])
		m.removedresources[ids[i]] = struct{}{}
	}
}

// RemovedResources returns the removed IDs of the "resources" edge to the AppRes entity.
func (m *AppMutation) RemovedResourcesIDs() (ids []int) {
	for id := range m.removedresources {
		ids = append(ids, id)
	}
	return
}

// ResourcesIDs returns the "resources" edge IDs in the mutation.
func (m *AppMutation) ResourcesIDs() (ids []int) {
	for id := range m.resources {
		ids = append(ids, id)
	}
	return
}

// ResetResources resets all changes to the "resources" edge.
func (m *AppMutation) ResetResources() {
	m.resources = nil
	m.clearedresources = false
	m.removedresources = nil
}

// AddRoleIDs adds the "roles" edge to the AppRole entity by ids.
func (m *AppMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the AppRole entity.
func (m *AppMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AppRole entity was cleared.
func (m *AppMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the AppRole entity by IDs.
func (m *AppMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the AppRole entity.
func (m *AppMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AppMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AppMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddPolicyIDs adds the "policies" edge to the AppPolicy entity by ids.
func (m *AppMutation) AddPolicyIDs(ids ...int) {
	if m.policies == nil {
		m.policies = make(map[int]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the "policies" edge to the AppPolicy entity.
func (m *AppMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared reports if the "policies" edge to the AppPolicy entity was cleared.
func (m *AppMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the "policies" edge to the AppPolicy entity by IDs.
func (m *AppMutation) RemovePolicyIDs(ids ...int) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.policies, ids[i])
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed IDs of the "policies" edge to the AppPolicy entity.
func (m *AppMutation) RemovedPoliciesIDs() (ids []int) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the "policies" edge IDs in the mutation.
func (m *AppMutation) PoliciesIDs() (ids []int) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies resets all changes to the "policies" edge.
func (m *AppMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// AddOrgIDs adds the "orgs" edge to the Org entity by ids.
func (m *AppMutation) AddOrgIDs(ids ...int) {
	if m.orgs == nil {
		m.orgs = make(map[int]struct{})
	}
	for i := range ids {
		m.orgs[ids[i]] = struct{}{}
	}
}

// ClearOrgs clears the "orgs" edge to the Org entity.
func (m *AppMutation) ClearOrgs() {
	m.clearedorgs = true
}

// OrgsCleared reports if the "orgs" edge to the Org entity was cleared.
func (m *AppMutation) OrgsCleared() bool {
	return m.clearedorgs
}

// RemoveOrgIDs removes the "orgs" edge to the Org entity by IDs.
func (m *AppMutation) RemoveOrgIDs(ids ...int) {
	if m.removedorgs == nil {
		m.removedorgs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orgs, ids[i])
		m.removedorgs[ids[i]] = struct{}{}
	}
}

// RemovedOrgs returns the removed IDs of the "orgs" edge to the Org entity.
func (m *AppMutation) RemovedOrgsIDs() (ids []int) {
	for id := range m.removedorgs {
		ids = append(ids, id)
	}
	return
}

// OrgsIDs returns the "orgs" edge IDs in the mutation.
func (m *AppMutation) OrgsIDs() (ids []int) {
	for id := range m.orgs {
		ids = append(ids, id)
	}
	return
}

// ResetOrgs resets all changes to the "orgs" edge.
func (m *AppMutation) ResetOrgs() {
	m.orgs = nil
	m.clearedorgs = false
	m.removedorgs = nil
}

// AddOrgAppIDs adds the "org_app" edge to the OrgApp entity by ids.
func (m *AppMutation) AddOrgAppIDs(ids ...int) {
	if m.org_app == nil {
		m.org_app = make(map[int]struct{})
	}
	for i := range ids {
		m.org_app[ids[i]] = struct{}{}
	}
}

// ClearOrgApp clears the "org_app" edge to the OrgApp entity.
func (m *AppMutation) ClearOrgApp() {
	m.clearedorg_app = true
}

// OrgAppCleared reports if the "org_app" edge to the OrgApp entity was cleared.
func (m *AppMutation) OrgAppCleared() bool {
	return m.clearedorg_app
}

// RemoveOrgAppIDs removes the "org_app" edge to the OrgApp entity by IDs.
func (m *AppMutation) RemoveOrgAppIDs(ids ...int) {
	if m.removedorg_app == nil {
		m.removedorg_app = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_app, ids[i])
		m.removedorg_app[ids[i]] = struct{}{}
	}
}

// RemovedOrgApp returns the removed IDs of the "org_app" edge to the OrgApp entity.
func (m *AppMutation) RemovedOrgAppIDs() (ids []int) {
	for id := range m.removedorg_app {
		ids = append(ids, id)
	}
	return
}

// OrgAppIDs returns the "org_app" edge IDs in the mutation.
func (m *AppMutation) OrgAppIDs() (ids []int) {
	for id := range m.org_app {
		ids = append(ids, id)
	}
	return
}

// ResetOrgApp resets all changes to the "org_app" edge.
func (m *AppMutation) ResetOrgApp() {
	m.org_app = nil
	m.clearedorg_app = false
	m.removedorg_app = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_by != nil {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, app.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.code != nil {
		fields = append(fields, app.FieldCode)
	}
	if m.kind != nil {
		fields = append(fields, app.FieldKind)
	}
	if m.redirect_uri != nil {
		fields = append(fields, app.FieldRedirectURI)
	}
	if m.app_key != nil {
		fields = append(fields, app.FieldAppKey)
	}
	if m.app_secret != nil {
		fields = append(fields, app.FieldAppSecret)
	}
	if m.scopes != nil {
		fields = append(fields, app.FieldScopes)
	}
	if m.token_validity != nil {
		fields = append(fields, app.FieldTokenValidity)
	}
	if m.refresh_token_validity != nil {
		fields = append(fields, app.FieldRefreshTokenValidity)
	}
	if m.logo_file_id != nil {
		fields = append(fields, app.FieldLogoFileID)
	}
	if m.comments != nil {
		fields = append(fields, app.FieldComments)
	}
	if m.status != nil {
		fields = append(fields, app.FieldStatus)
	}
	if m.private != nil {
		fields = append(fields, app.FieldPrivate)
	}
	if m.owner_org_id != nil {
		fields = append(fields, app.FieldOwnerOrgID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedBy:
		return m.CreatedBy()
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedBy:
		return m.UpdatedBy()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldName:
		return m.Name()
	case app.FieldCode:
		return m.Code()
	case app.FieldKind:
		return m.Kind()
	case app.FieldRedirectURI:
		return m.RedirectURI()
	case app.FieldAppKey:
		return m.AppKey()
	case app.FieldAppSecret:
		return m.AppSecret()
	case app.FieldScopes:
		return m.Scopes()
	case app.FieldTokenValidity:
		return m.TokenValidity()
	case app.FieldRefreshTokenValidity:
		return m.RefreshTokenValidity()
	case app.FieldLogoFileID:
		return m.LogoFileID()
	case app.FieldComments:
		return m.Comments()
	case app.FieldStatus:
		return m.Status()
	case app.FieldPrivate:
		return m.Private()
	case app.FieldOwnerOrgID:
		return m.OwnerOrgID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldCode:
		return m.OldCode(ctx)
	case app.FieldKind:
		return m.OldKind(ctx)
	case app.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case app.FieldAppKey:
		return m.OldAppKey(ctx)
	case app.FieldAppSecret:
		return m.OldAppSecret(ctx)
	case app.FieldScopes:
		return m.OldScopes(ctx)
	case app.FieldTokenValidity:
		return m.OldTokenValidity(ctx)
	case app.FieldRefreshTokenValidity:
		return m.OldRefreshTokenValidity(ctx)
	case app.FieldLogoFileID:
		return m.OldLogoFileID(ctx)
	case app.FieldComments:
		return m.OldComments(ctx)
	case app.FieldStatus:
		return m.OldStatus(ctx)
	case app.FieldPrivate:
		return m.OldPrivate(ctx)
	case app.FieldOwnerOrgID:
		return m.OldOwnerOrgID(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case app.FieldKind:
		v, ok := value.(app.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case app.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case app.FieldAppKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppKey(v)
		return nil
	case app.FieldAppSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSecret(v)
		return nil
	case app.FieldScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case app.FieldTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenValidity(v)
		return nil
	case app.FieldRefreshTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenValidity(v)
		return nil
	case app.FieldLogoFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoFileID(v)
		return nil
	case app.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case app.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case app.FieldPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivate(v)
		return nil
	case app.FieldOwnerOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerOrgID(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, app.FieldUpdatedBy)
	}
	if m.addtoken_validity != nil {
		fields = append(fields, app.FieldTokenValidity)
	}
	if m.addrefresh_token_validity != nil {
		fields = append(fields, app.FieldRefreshTokenValidity)
	}
	if m.addlogo_file_id != nil {
		fields = append(fields, app.FieldLogoFileID)
	}
	if m.addowner_org_id != nil {
		fields = append(fields, app.FieldOwnerOrgID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedBy:
		return m.AddedCreatedBy()
	case app.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case app.FieldTokenValidity:
		return m.AddedTokenValidity()
	case app.FieldRefreshTokenValidity:
		return m.AddedRefreshTokenValidity()
	case app.FieldLogoFileID:
		return m.AddedLogoFileID()
	case app.FieldOwnerOrgID:
		return m.AddedOwnerOrgID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case app.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case app.FieldTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenValidity(v)
		return nil
	case app.FieldRefreshTokenValidity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefreshTokenValidity(v)
		return nil
	case app.FieldLogoFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLogoFileID(v)
		return nil
	case app.FieldOwnerOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerOrgID(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldUpdatedBy) {
		fields = append(fields, app.FieldUpdatedBy)
	}
	if m.FieldCleared(app.FieldUpdatedAt) {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.FieldCleared(app.FieldRedirectURI) {
		fields = append(fields, app.FieldRedirectURI)
	}
	if m.FieldCleared(app.FieldAppKey) {
		fields = append(fields, app.FieldAppKey)
	}
	if m.FieldCleared(app.FieldAppSecret) {
		fields = append(fields, app.FieldAppSecret)
	}
	if m.FieldCleared(app.FieldScopes) {
		fields = append(fields, app.FieldScopes)
	}
	if m.FieldCleared(app.FieldTokenValidity) {
		fields = append(fields, app.FieldTokenValidity)
	}
	if m.FieldCleared(app.FieldRefreshTokenValidity) {
		fields = append(fields, app.FieldRefreshTokenValidity)
	}
	if m.FieldCleared(app.FieldLogoFileID) {
		fields = append(fields, app.FieldLogoFileID)
	}
	if m.FieldCleared(app.FieldComments) {
		fields = append(fields, app.FieldComments)
	}
	if m.FieldCleared(app.FieldStatus) {
		fields = append(fields, app.FieldStatus)
	}
	if m.FieldCleared(app.FieldPrivate) {
		fields = append(fields, app.FieldPrivate)
	}
	if m.FieldCleared(app.FieldOwnerOrgID) {
		fields = append(fields, app.FieldOwnerOrgID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case app.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case app.FieldRedirectURI:
		m.ClearRedirectURI()
		return nil
	case app.FieldAppKey:
		m.ClearAppKey()
		return nil
	case app.FieldAppSecret:
		m.ClearAppSecret()
		return nil
	case app.FieldScopes:
		m.ClearScopes()
		return nil
	case app.FieldTokenValidity:
		m.ClearTokenValidity()
		return nil
	case app.FieldRefreshTokenValidity:
		m.ClearRefreshTokenValidity()
		return nil
	case app.FieldLogoFileID:
		m.ClearLogoFileID()
		return nil
	case app.FieldComments:
		m.ClearComments()
		return nil
	case app.FieldStatus:
		m.ClearStatus()
		return nil
	case app.FieldPrivate:
		m.ClearPrivate()
		return nil
	case app.FieldOwnerOrgID:
		m.ClearOwnerOrgID()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldCode:
		m.ResetCode()
		return nil
	case app.FieldKind:
		m.ResetKind()
		return nil
	case app.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case app.FieldAppKey:
		m.ResetAppKey()
		return nil
	case app.FieldAppSecret:
		m.ResetAppSecret()
		return nil
	case app.FieldScopes:
		m.ResetScopes()
		return nil
	case app.FieldTokenValidity:
		m.ResetTokenValidity()
		return nil
	case app.FieldRefreshTokenValidity:
		m.ResetRefreshTokenValidity()
		return nil
	case app.FieldLogoFileID:
		m.ResetLogoFileID()
		return nil
	case app.FieldComments:
		m.ResetComments()
		return nil
	case app.FieldStatus:
		m.ResetStatus()
		return nil
	case app.FieldPrivate:
		m.ResetPrivate()
		return nil
	case app.FieldOwnerOrgID:
		m.ResetOwnerOrgID()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.menus != nil {
		edges = append(edges, app.EdgeMenus)
	}
	if m.actions != nil {
		edges = append(edges, app.EdgeActions)
	}
	if m.resources != nil {
		edges = append(edges, app.EdgeResources)
	}
	if m.roles != nil {
		edges = append(edges, app.EdgeRoles)
	}
	if m.policies != nil {
		edges = append(edges, app.EdgePolicies)
	}
	if m.orgs != nil {
		edges = append(edges, app.EdgeOrgs)
	}
	if m.org_app != nil {
		edges = append(edges, app.EdgeOrgApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeActions:
		ids := make([]ent.Value, 0, len(m.actions))
		for id := range m.actions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeResources:
		ids := make([]ent.Value, 0, len(m.resources))
		for id := range m.resources {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeOrgs:
		ids := make([]ent.Value, 0, len(m.orgs))
		for id := range m.orgs {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeOrgApp:
		ids := make([]ent.Value, 0, len(m.org_app))
		for id := range m.org_app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedmenus != nil {
		edges = append(edges, app.EdgeMenus)
	}
	if m.removedactions != nil {
		edges = append(edges, app.EdgeActions)
	}
	if m.removedresources != nil {
		edges = append(edges, app.EdgeResources)
	}
	if m.removedroles != nil {
		edges = append(edges, app.EdgeRoles)
	}
	if m.removedpolicies != nil {
		edges = append(edges, app.EdgePolicies)
	}
	if m.removedorgs != nil {
		edges = append(edges, app.EdgeOrgs)
	}
	if m.removedorg_app != nil {
		edges = append(edges, app.EdgeOrgApp)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeActions:
		ids := make([]ent.Value, 0, len(m.removedactions))
		for id := range m.removedactions {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeResources:
		ids := make([]ent.Value, 0, len(m.removedresources))
		for id := range m.removedresources {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case app.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeOrgs:
		ids := make([]ent.Value, 0, len(m.removedorgs))
		for id := range m.removedorgs {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeOrgApp:
		ids := make([]ent.Value, 0, len(m.removedorg_app))
		for id := range m.removedorg_app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedmenus {
		edges = append(edges, app.EdgeMenus)
	}
	if m.clearedactions {
		edges = append(edges, app.EdgeActions)
	}
	if m.clearedresources {
		edges = append(edges, app.EdgeResources)
	}
	if m.clearedroles {
		edges = append(edges, app.EdgeRoles)
	}
	if m.clearedpolicies {
		edges = append(edges, app.EdgePolicies)
	}
	if m.clearedorgs {
		edges = append(edges, app.EdgeOrgs)
	}
	if m.clearedorg_app {
		edges = append(edges, app.EdgeOrgApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeMenus:
		return m.clearedmenus
	case app.EdgeActions:
		return m.clearedactions
	case app.EdgeResources:
		return m.clearedresources
	case app.EdgeRoles:
		return m.clearedroles
	case app.EdgePolicies:
		return m.clearedpolicies
	case app.EdgeOrgs:
		return m.clearedorgs
	case app.EdgeOrgApp:
		return m.clearedorg_app
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeMenus:
		m.ResetMenus()
		return nil
	case app.EdgeActions:
		m.ResetActions()
		return nil
	case app.EdgeResources:
		m.ResetResources()
		return nil
	case app.EdgeRoles:
		m.ResetRoles()
		return nil
	case app.EdgePolicies:
		m.ResetPolicies()
		return nil
	case app.EdgeOrgs:
		m.ResetOrgs()
		return nil
	case app.EdgeOrgApp:
		m.ResetOrgApp()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppActionMutation represents an operation that mutates the AppAction nodes in the graph.
type AppActionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	name          *string
	kind          *appaction.Kind
	method        *appaction.Method
	comments      *string
	clearedFields map[string]struct{}
	app           *int
	clearedapp    bool
	menus         map[int]struct{}
	removedmenus  map[int]struct{}
	clearedmenus  bool
	done          bool
	oldValue      func(context.Context) (*AppAction, error)
	predicates    []predicate.AppAction
}

var _ ent.Mutation = (*AppActionMutation)(nil)

// appactionOption allows management of the mutation configuration using functional options.
type appactionOption func(*AppActionMutation)

// newAppActionMutation creates new mutation for the AppAction entity.
func newAppActionMutation(c config, op Op, opts ...appactionOption) *AppActionMutation {
	m := &AppActionMutation{
		config:        c,
		op:            op,
		typ:           TypeAppAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppActionID sets the ID field of the mutation.
func withAppActionID(id int) appactionOption {
	return func(m *AppActionMutation) {
		var (
			err   error
			once  sync.Once
			value *AppAction
		)
		m.oldValue = func(ctx context.Context) (*AppAction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppAction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppAction sets the old AppAction of the mutation.
func withAppAction(node *AppAction) appactionOption {
	return func(m *AppActionMutation) {
		m.oldValue = func(context.Context) (*AppAction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppAction entities.
func (m *AppActionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppActionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppAction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppActionMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppActionMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppActionMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppActionMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppActionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppActionMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppActionMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppActionMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppActionMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppActionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[appaction.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppActionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[appaction.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppActionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, appaction.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppActionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppActionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppActionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appaction.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppActionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appaction.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppActionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appaction.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppActionMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppActionMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppActionMutation) ClearAppID() {
	m.app = nil
	m.clearedFields[appaction.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppActionMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appaction.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppActionMutation) ResetAppID() {
	m.app = nil
	delete(m.clearedFields, appaction.FieldAppID)
}

// SetName sets the "name" field.
func (m *AppActionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppActionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppActionMutation) ResetName() {
	m.name = nil
}

// SetKind sets the "kind" field.
func (m *AppActionMutation) SetKind(a appaction.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AppActionMutation) Kind() (r appaction.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldKind(ctx context.Context) (v appaction.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AppActionMutation) ResetKind() {
	m.kind = nil
}

// SetMethod sets the "method" field.
func (m *AppActionMutation) SetMethod(a appaction.Method) {
	m.method = &a
}

// Method returns the value of the "method" field in the mutation.
func (m *AppActionMutation) Method() (r appaction.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldMethod(ctx context.Context) (v appaction.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AppActionMutation) ResetMethod() {
	m.method = nil
}

// SetComments sets the "comments" field.
func (m *AppActionMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppActionMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the AppAction entity.
// If the AppAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppActionMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppActionMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[appaction.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppActionMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[appaction.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppActionMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, appaction.FieldComments)
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppActionMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppActionMutation) AppCleared() bool {
	return m.AppIDCleared() || m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppActionMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppActionMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddMenuIDs adds the "menus" edge to the AppMenu entity by ids.
func (m *AppActionMutation) AddMenuIDs(ids ...int) {
	if m.menus == nil {
		m.menus = make(map[int]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the AppMenu entity.
func (m *AppActionMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the AppMenu entity was cleared.
func (m *AppActionMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the AppMenu entity by IDs.
func (m *AppActionMutation) RemoveMenuIDs(ids ...int) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the AppMenu entity.
func (m *AppActionMutation) RemovedMenusIDs() (ids []int) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *AppActionMutation) MenusIDs() (ids []int) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *AppActionMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// Where appends a list predicates to the AppActionMutation builder.
func (m *AppActionMutation) Where(ps ...predicate.AppAction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppAction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppAction).
func (m *AppActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppActionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, appaction.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, appaction.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, appaction.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, appaction.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, appaction.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, appaction.FieldName)
	}
	if m.kind != nil {
		fields = append(fields, appaction.FieldKind)
	}
	if m.method != nil {
		fields = append(fields, appaction.FieldMethod)
	}
	if m.comments != nil {
		fields = append(fields, appaction.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appaction.FieldCreatedBy:
		return m.CreatedBy()
	case appaction.FieldCreatedAt:
		return m.CreatedAt()
	case appaction.FieldUpdatedBy:
		return m.UpdatedBy()
	case appaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case appaction.FieldAppID:
		return m.AppID()
	case appaction.FieldName:
		return m.Name()
	case appaction.FieldKind:
		return m.Kind()
	case appaction.FieldMethod:
		return m.Method()
	case appaction.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appaction.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case appaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appaction.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case appaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appaction.FieldAppID:
		return m.OldAppID(ctx)
	case appaction.FieldName:
		return m.OldName(ctx)
	case appaction.FieldKind:
		return m.OldKind(ctx)
	case appaction.FieldMethod:
		return m.OldMethod(ctx)
	case appaction.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown AppAction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appaction.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case appaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appaction.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case appaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appaction.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appaction.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appaction.FieldKind:
		v, ok := value.(appaction.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case appaction.FieldMethod:
		v, ok := value.(appaction.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case appaction.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown AppAction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppActionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, appaction.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, appaction.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appaction.FieldCreatedBy:
		return m.AddedCreatedBy()
	case appaction.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appaction.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case appaction.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AppAction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppActionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appaction.FieldUpdatedBy) {
		fields = append(fields, appaction.FieldUpdatedBy)
	}
	if m.FieldCleared(appaction.FieldUpdatedAt) {
		fields = append(fields, appaction.FieldUpdatedAt)
	}
	if m.FieldCleared(appaction.FieldAppID) {
		fields = append(fields, appaction.FieldAppID)
	}
	if m.FieldCleared(appaction.FieldComments) {
		fields = append(fields, appaction.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppActionMutation) ClearField(name string) error {
	switch name {
	case appaction.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case appaction.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case appaction.FieldAppID:
		m.ClearAppID()
		return nil
	case appaction.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown AppAction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppActionMutation) ResetField(name string) error {
	switch name {
	case appaction.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case appaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appaction.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case appaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appaction.FieldAppID:
		m.ResetAppID()
		return nil
	case appaction.FieldName:
		m.ResetName()
		return nil
	case appaction.FieldKind:
		m.ResetKind()
		return nil
	case appaction.FieldMethod:
		m.ResetMethod()
		return nil
	case appaction.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown AppAction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, appaction.EdgeApp)
	}
	if m.menus != nil {
		edges = append(edges, appaction.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appaction.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appaction.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmenus != nil {
		edges = append(edges, appaction.EdgeMenus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppActionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case appaction.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, appaction.EdgeApp)
	}
	if m.clearedmenus {
		edges = append(edges, appaction.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppActionMutation) EdgeCleared(name string) bool {
	switch name {
	case appaction.EdgeApp:
		return m.clearedapp
	case appaction.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppActionMutation) ClearEdge(name string) error {
	switch name {
	case appaction.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppAction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppActionMutation) ResetEdge(name string) error {
	switch name {
	case appaction.EdgeApp:
		m.ResetApp()
		return nil
	case appaction.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown AppAction edge %s", name)
}

// AppMenuMutation represents an operation that mutates the AppMenu nodes in the graph.
type AppMenuMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_by      *int
	addcreated_by   *int
	created_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_at      *time.Time
	parent_id       *int
	addparent_id    *int
	kind            *appmenu.Kind
	name            *string
	icon            *string
	route           *string
	comments        *string
	display_sort    *int32
	adddisplay_sort *int32
	clearedFields   map[string]struct{}
	app             *int
	clearedapp      bool
	action          *int
	clearedaction   bool
	done            bool
	oldValue        func(context.Context) (*AppMenu, error)
	predicates      []predicate.AppMenu
}

var _ ent.Mutation = (*AppMenuMutation)(nil)

// appmenuOption allows management of the mutation configuration using functional options.
type appmenuOption func(*AppMenuMutation)

// newAppMenuMutation creates new mutation for the AppMenu entity.
func newAppMenuMutation(c config, op Op, opts ...appmenuOption) *AppMenuMutation {
	m := &AppMenuMutation{
		config:        c,
		op:            op,
		typ:           TypeAppMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppMenuID sets the ID field of the mutation.
func withAppMenuID(id int) appmenuOption {
	return func(m *AppMenuMutation) {
		var (
			err   error
			once  sync.Once
			value *AppMenu
		)
		m.oldValue = func(ctx context.Context) (*AppMenu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppMenu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppMenu sets the old AppMenu of the mutation.
func withAppMenu(node *AppMenu) appmenuOption {
	return func(m *AppMenuMutation) {
		m.oldValue = func(context.Context) (*AppMenu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppMenu entities.
func (m *AppMenuMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMenuMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMenuMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppMenu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppMenuMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppMenuMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppMenuMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppMenuMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppMenuMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMenuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppMenuMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppMenuMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppMenuMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppMenuMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppMenuMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[appmenu.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppMenuMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppMenuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, appmenu.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppMenuMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appmenu.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppMenuMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appmenu.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppMenuMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppMenuMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppMenuMutation) ClearAppID() {
	m.app = nil
	m.clearedFields[appmenu.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppMenuMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppMenuMutation) ResetAppID() {
	m.app = nil
	delete(m.clearedFields, appmenu.FieldAppID)
}

// SetParentID sets the "parent_id" field.
func (m *AppMenuMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *AppMenuMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *AppMenuMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *AppMenuMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *AppMenuMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
}

// SetKind sets the "kind" field.
func (m *AppMenuMutation) SetKind(a appmenu.Kind) {
	m.kind = &a
}

// Kind returns the value of the "kind" field in the mutation.
func (m *AppMenuMutation) Kind() (r appmenu.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldKind(ctx context.Context) (v appmenu.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *AppMenuMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *AppMenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMenuMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *AppMenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AppMenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *AppMenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[appmenu.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *AppMenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *AppMenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, appmenu.FieldIcon)
}

// SetRoute sets the "route" field.
func (m *AppMenuMutation) SetRoute(s string) {
	m.route = &s
}

// Route returns the value of the "route" field in the mutation.
func (m *AppMenuMutation) Route() (r string, exists bool) {
	v := m.route
	if v == nil {
		return
	}
	return *v, true
}

// OldRoute returns the old "route" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldRoute(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoute: %w", err)
	}
	return oldValue.Route, nil
}

// ClearRoute clears the value of the "route" field.
func (m *AppMenuMutation) ClearRoute() {
	m.route = nil
	m.clearedFields[appmenu.FieldRoute] = struct{}{}
}

// RouteCleared returns if the "route" field was cleared in this mutation.
func (m *AppMenuMutation) RouteCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldRoute]
	return ok
}

// ResetRoute resets all changes to the "route" field.
func (m *AppMenuMutation) ResetRoute() {
	m.route = nil
	delete(m.clearedFields, appmenu.FieldRoute)
}

// SetActionID sets the "action_id" field.
func (m *AppMenuMutation) SetActionID(i int) {
	m.action = &i
}

// ActionID returns the value of the "action_id" field in the mutation.
func (m *AppMenuMutation) ActionID() (r int, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldActionID returns the old "action_id" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldActionID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionID: %w", err)
	}
	return oldValue.ActionID, nil
}

// ClearActionID clears the value of the "action_id" field.
func (m *AppMenuMutation) ClearActionID() {
	m.action = nil
	m.clearedFields[appmenu.FieldActionID] = struct{}{}
}

// ActionIDCleared returns if the "action_id" field was cleared in this mutation.
func (m *AppMenuMutation) ActionIDCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldActionID]
	return ok
}

// ResetActionID resets all changes to the "action_id" field.
func (m *AppMenuMutation) ResetActionID() {
	m.action = nil
	delete(m.clearedFields, appmenu.FieldActionID)
}

// SetComments sets the "comments" field.
func (m *AppMenuMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppMenuMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppMenuMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[appmenu.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppMenuMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppMenuMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, appmenu.FieldComments)
}

// SetDisplaySort sets the "display_sort" field.
func (m *AppMenuMutation) SetDisplaySort(i int32) {
	m.display_sort = &i
	m.adddisplay_sort = nil
}

// DisplaySort returns the value of the "display_sort" field in the mutation.
func (m *AppMenuMutation) DisplaySort() (r int32, exists bool) {
	v := m.display_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplaySort returns the old "display_sort" field's value of the AppMenu entity.
// If the AppMenu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMenuMutation) OldDisplaySort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplaySort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplaySort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplaySort: %w", err)
	}
	return oldValue.DisplaySort, nil
}

// AddDisplaySort adds i to the "display_sort" field.
func (m *AppMenuMutation) AddDisplaySort(i int32) {
	if m.adddisplay_sort != nil {
		*m.adddisplay_sort += i
	} else {
		m.adddisplay_sort = &i
	}
}

// AddedDisplaySort returns the value that was added to the "display_sort" field in this mutation.
func (m *AppMenuMutation) AddedDisplaySort() (r int32, exists bool) {
	v := m.adddisplay_sort
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplaySort clears the value of the "display_sort" field.
func (m *AppMenuMutation) ClearDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	m.clearedFields[appmenu.FieldDisplaySort] = struct{}{}
}

// DisplaySortCleared returns if the "display_sort" field was cleared in this mutation.
func (m *AppMenuMutation) DisplaySortCleared() bool {
	_, ok := m.clearedFields[appmenu.FieldDisplaySort]
	return ok
}

// ResetDisplaySort resets all changes to the "display_sort" field.
func (m *AppMenuMutation) ResetDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	delete(m.clearedFields, appmenu.FieldDisplaySort)
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppMenuMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppMenuMutation) AppCleared() bool {
	return m.AppIDCleared() || m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppMenuMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppMenuMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// ClearAction clears the "action" edge to the AppAction entity.
func (m *AppMenuMutation) ClearAction() {
	m.clearedaction = true
}

// ActionCleared reports if the "action" edge to the AppAction entity was cleared.
func (m *AppMenuMutation) ActionCleared() bool {
	return m.ActionIDCleared() || m.clearedaction
}

// ActionIDs returns the "action" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActionID instead. It exists only for internal usage by the builders.
func (m *AppMenuMutation) ActionIDs() (ids []int) {
	if id := m.action; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAction resets all changes to the "action" edge.
func (m *AppMenuMutation) ResetAction() {
	m.action = nil
	m.clearedaction = false
}

// Where appends a list predicates to the AppMenuMutation builder.
func (m *AppMenuMutation) Where(ps ...predicate.AppMenu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppMenu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppMenu).
func (m *AppMenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMenuMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, appmenu.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, appmenu.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, appmenu.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, appmenu.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, appmenu.FieldAppID)
	}
	if m.parent_id != nil {
		fields = append(fields, appmenu.FieldParentID)
	}
	if m.kind != nil {
		fields = append(fields, appmenu.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, appmenu.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, appmenu.FieldIcon)
	}
	if m.route != nil {
		fields = append(fields, appmenu.FieldRoute)
	}
	if m.action != nil {
		fields = append(fields, appmenu.FieldActionID)
	}
	if m.comments != nil {
		fields = append(fields, appmenu.FieldComments)
	}
	if m.display_sort != nil {
		fields = append(fields, appmenu.FieldDisplaySort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appmenu.FieldCreatedBy:
		return m.CreatedBy()
	case appmenu.FieldCreatedAt:
		return m.CreatedAt()
	case appmenu.FieldUpdatedBy:
		return m.UpdatedBy()
	case appmenu.FieldUpdatedAt:
		return m.UpdatedAt()
	case appmenu.FieldAppID:
		return m.AppID()
	case appmenu.FieldParentID:
		return m.ParentID()
	case appmenu.FieldKind:
		return m.Kind()
	case appmenu.FieldName:
		return m.Name()
	case appmenu.FieldIcon:
		return m.Icon()
	case appmenu.FieldRoute:
		return m.Route()
	case appmenu.FieldActionID:
		return m.ActionID()
	case appmenu.FieldComments:
		return m.Comments()
	case appmenu.FieldDisplaySort:
		return m.DisplaySort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appmenu.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case appmenu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appmenu.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case appmenu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appmenu.FieldAppID:
		return m.OldAppID(ctx)
	case appmenu.FieldParentID:
		return m.OldParentID(ctx)
	case appmenu.FieldKind:
		return m.OldKind(ctx)
	case appmenu.FieldName:
		return m.OldName(ctx)
	case appmenu.FieldIcon:
		return m.OldIcon(ctx)
	case appmenu.FieldRoute:
		return m.OldRoute(ctx)
	case appmenu.FieldActionID:
		return m.OldActionID(ctx)
	case appmenu.FieldComments:
		return m.OldComments(ctx)
	case appmenu.FieldDisplaySort:
		return m.OldDisplaySort(ctx)
	}
	return nil, fmt.Errorf("unknown AppMenu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appmenu.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case appmenu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appmenu.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case appmenu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appmenu.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appmenu.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case appmenu.FieldKind:
		v, ok := value.(appmenu.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case appmenu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appmenu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case appmenu.FieldRoute:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoute(v)
		return nil
	case appmenu.FieldActionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionID(v)
		return nil
	case appmenu.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case appmenu.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplaySort(v)
		return nil
	}
	return fmt.Errorf("unknown AppMenu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMenuMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, appmenu.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, appmenu.FieldUpdatedBy)
	}
	if m.addparent_id != nil {
		fields = append(fields, appmenu.FieldParentID)
	}
	if m.adddisplay_sort != nil {
		fields = append(fields, appmenu.FieldDisplaySort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appmenu.FieldCreatedBy:
		return m.AddedCreatedBy()
	case appmenu.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case appmenu.FieldParentID:
		return m.AddedParentID()
	case appmenu.FieldDisplaySort:
		return m.AddedDisplaySort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appmenu.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case appmenu.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case appmenu.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case appmenu.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplaySort(v)
		return nil
	}
	return fmt.Errorf("unknown AppMenu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appmenu.FieldUpdatedBy) {
		fields = append(fields, appmenu.FieldUpdatedBy)
	}
	if m.FieldCleared(appmenu.FieldUpdatedAt) {
		fields = append(fields, appmenu.FieldUpdatedAt)
	}
	if m.FieldCleared(appmenu.FieldAppID) {
		fields = append(fields, appmenu.FieldAppID)
	}
	if m.FieldCleared(appmenu.FieldIcon) {
		fields = append(fields, appmenu.FieldIcon)
	}
	if m.FieldCleared(appmenu.FieldRoute) {
		fields = append(fields, appmenu.FieldRoute)
	}
	if m.FieldCleared(appmenu.FieldActionID) {
		fields = append(fields, appmenu.FieldActionID)
	}
	if m.FieldCleared(appmenu.FieldComments) {
		fields = append(fields, appmenu.FieldComments)
	}
	if m.FieldCleared(appmenu.FieldDisplaySort) {
		fields = append(fields, appmenu.FieldDisplaySort)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMenuMutation) ClearField(name string) error {
	switch name {
	case appmenu.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case appmenu.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case appmenu.FieldAppID:
		m.ClearAppID()
		return nil
	case appmenu.FieldIcon:
		m.ClearIcon()
		return nil
	case appmenu.FieldRoute:
		m.ClearRoute()
		return nil
	case appmenu.FieldActionID:
		m.ClearActionID()
		return nil
	case appmenu.FieldComments:
		m.ClearComments()
		return nil
	case appmenu.FieldDisplaySort:
		m.ClearDisplaySort()
		return nil
	}
	return fmt.Errorf("unknown AppMenu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMenuMutation) ResetField(name string) error {
	switch name {
	case appmenu.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case appmenu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appmenu.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case appmenu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appmenu.FieldAppID:
		m.ResetAppID()
		return nil
	case appmenu.FieldParentID:
		m.ResetParentID()
		return nil
	case appmenu.FieldKind:
		m.ResetKind()
		return nil
	case appmenu.FieldName:
		m.ResetName()
		return nil
	case appmenu.FieldIcon:
		m.ResetIcon()
		return nil
	case appmenu.FieldRoute:
		m.ResetRoute()
		return nil
	case appmenu.FieldActionID:
		m.ResetActionID()
		return nil
	case appmenu.FieldComments:
		m.ResetComments()
		return nil
	case appmenu.FieldDisplaySort:
		m.ResetDisplaySort()
		return nil
	}
	return fmt.Errorf("unknown AppMenu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, appmenu.EdgeApp)
	}
	if m.action != nil {
		edges = append(edges, appmenu.EdgeAction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appmenu.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appmenu.EdgeAction:
		if id := m.action; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMenuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, appmenu.EdgeApp)
	}
	if m.clearedaction {
		edges = append(edges, appmenu.EdgeAction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMenuMutation) EdgeCleared(name string) bool {
	switch name {
	case appmenu.EdgeApp:
		return m.clearedapp
	case appmenu.EdgeAction:
		return m.clearedaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMenuMutation) ClearEdge(name string) error {
	switch name {
	case appmenu.EdgeApp:
		m.ClearApp()
		return nil
	case appmenu.EdgeAction:
		m.ClearAction()
		return nil
	}
	return fmt.Errorf("unknown AppMenu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMenuMutation) ResetEdge(name string) error {
	switch name {
	case appmenu.EdgeApp:
		m.ResetApp()
		return nil
	case appmenu.EdgeAction:
		m.ResetAction()
		return nil
	}
	return fmt.Errorf("unknown AppMenu edge %s", name)
}

// AppPolicyMutation represents an operation that mutates the AppPolicy nodes in the graph.
type AppPolicyMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_by             *int
	addcreated_by          *int
	created_at             *time.Time
	updated_by             *int
	addupdated_by          *int
	updated_at             *time.Time
	name                   *string
	comments               *string
	rules                  *[]*types.PolicyRule
	appendrules            []*types.PolicyRule
	version                *string
	auto_grant             *bool
	status                 *typex.SimpleStatus
	clearedFields          map[string]struct{}
	app                    *int
	clearedapp             bool
	roles                  map[int]struct{}
	removedroles           map[int]struct{}
	clearedroles           bool
	app_role_policy        map[int]struct{}
	removedapp_role_policy map[int]struct{}
	clearedapp_role_policy bool
	done                   bool
	oldValue               func(context.Context) (*AppPolicy, error)
	predicates             []predicate.AppPolicy
}

var _ ent.Mutation = (*AppPolicyMutation)(nil)

// apppolicyOption allows management of the mutation configuration using functional options.
type apppolicyOption func(*AppPolicyMutation)

// newAppPolicyMutation creates new mutation for the AppPolicy entity.
func newAppPolicyMutation(c config, op Op, opts ...apppolicyOption) *AppPolicyMutation {
	m := &AppPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeAppPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppPolicyID sets the ID field of the mutation.
func withAppPolicyID(id int) apppolicyOption {
	return func(m *AppPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *AppPolicy
		)
		m.oldValue = func(ctx context.Context) (*AppPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppPolicy sets the old AppPolicy of the mutation.
func withAppPolicy(node *AppPolicy) apppolicyOption {
	return func(m *AppPolicyMutation) {
		m.oldValue = func(context.Context) (*AppPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppPolicy entities.
func (m *AppPolicyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppPolicyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppPolicyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppPolicyMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppPolicyMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppPolicyMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppPolicyMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppPolicyMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppPolicyMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppPolicyMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppPolicyMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppPolicyMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppPolicyMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[apppolicy.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppPolicyMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[apppolicy.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppPolicyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, apppolicy.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppPolicyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[apppolicy.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppPolicyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[apppolicy.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, apppolicy.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppPolicyMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppPolicyMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppPolicyMutation) ClearAppID() {
	m.app = nil
	m.clearedFields[apppolicy.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppPolicyMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[apppolicy.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppPolicyMutation) ResetAppID() {
	m.app = nil
	delete(m.clearedFields, apppolicy.FieldAppID)
}

// SetName sets the "name" field.
func (m *AppPolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppPolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppPolicyMutation) ResetName() {
	m.name = nil
}

// SetComments sets the "comments" field.
func (m *AppPolicyMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppPolicyMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppPolicyMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[apppolicy.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppPolicyMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[apppolicy.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppPolicyMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, apppolicy.FieldComments)
}

// SetRules sets the "rules" field.
func (m *AppPolicyMutation) SetRules(tr []*types.PolicyRule) {
	m.rules = &tr
	m.appendrules = nil
}

// Rules returns the value of the "rules" field in the mutation.
func (m *AppPolicyMutation) Rules() (r []*types.PolicyRule, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRules returns the old "rules" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldRules(ctx context.Context) (v []*types.PolicyRule, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRules: %w", err)
	}
	return oldValue.Rules, nil
}

// AppendRules adds tr to the "rules" field.
func (m *AppPolicyMutation) AppendRules(tr []*types.PolicyRule) {
	m.appendrules = append(m.appendrules, tr...)
}

// AppendedRules returns the list of values that were appended to the "rules" field in this mutation.
func (m *AppPolicyMutation) AppendedRules() ([]*types.PolicyRule, bool) {
	if len(m.appendrules) == 0 {
		return nil, false
	}
	return m.appendrules, true
}

// ResetRules resets all changes to the "rules" field.
func (m *AppPolicyMutation) ResetRules() {
	m.rules = nil
	m.appendrules = nil
}

// SetVersion sets the "version" field.
func (m *AppPolicyMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AppPolicyMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *AppPolicyMutation) ResetVersion() {
	m.version = nil
}

// SetAutoGrant sets the "auto_grant" field.
func (m *AppPolicyMutation) SetAutoGrant(b bool) {
	m.auto_grant = &b
}

// AutoGrant returns the value of the "auto_grant" field in the mutation.
func (m *AppPolicyMutation) AutoGrant() (r bool, exists bool) {
	v := m.auto_grant
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoGrant returns the old "auto_grant" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldAutoGrant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoGrant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoGrant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoGrant: %w", err)
	}
	return oldValue.AutoGrant, nil
}

// ResetAutoGrant resets all changes to the "auto_grant" field.
func (m *AppPolicyMutation) ResetAutoGrant() {
	m.auto_grant = nil
}

// SetStatus sets the "status" field.
func (m *AppPolicyMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *AppPolicyMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AppPolicy entity.
// If the AppPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPolicyMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *AppPolicyMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[apppolicy.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AppPolicyMutation) StatusCleared() bool {
	_, ok := m.clearedFields[apppolicy.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AppPolicyMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, apppolicy.FieldStatus)
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppPolicyMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppPolicyMutation) AppCleared() bool {
	return m.AppIDCleared() || m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppPolicyMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppPolicyMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddRoleIDs adds the "roles" edge to the AppRole entity by ids.
func (m *AppPolicyMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the AppRole entity.
func (m *AppPolicyMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the AppRole entity was cleared.
func (m *AppPolicyMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the AppRole entity by IDs.
func (m *AppPolicyMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the AppRole entity.
func (m *AppPolicyMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AppPolicyMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AppPolicyMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddAppRolePolicyIDs adds the "app_role_policy" edge to the AppRolePolicy entity by ids.
func (m *AppPolicyMutation) AddAppRolePolicyIDs(ids ...int) {
	if m.app_role_policy == nil {
		m.app_role_policy = make(map[int]struct{})
	}
	for i := range ids {
		m.app_role_policy[ids[i]] = struct{}{}
	}
}

// ClearAppRolePolicy clears the "app_role_policy" edge to the AppRolePolicy entity.
func (m *AppPolicyMutation) ClearAppRolePolicy() {
	m.clearedapp_role_policy = true
}

// AppRolePolicyCleared reports if the "app_role_policy" edge to the AppRolePolicy entity was cleared.
func (m *AppPolicyMutation) AppRolePolicyCleared() bool {
	return m.clearedapp_role_policy
}

// RemoveAppRolePolicyIDs removes the "app_role_policy" edge to the AppRolePolicy entity by IDs.
func (m *AppPolicyMutation) RemoveAppRolePolicyIDs(ids ...int) {
	if m.removedapp_role_policy == nil {
		m.removedapp_role_policy = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.app_role_policy, ids[i])
		m.removedapp_role_policy[ids[i]] = struct{}{}
	}
}

// RemovedAppRolePolicy returns the removed IDs of the "app_role_policy" edge to the AppRolePolicy entity.
func (m *AppPolicyMutation) RemovedAppRolePolicyIDs() (ids []int) {
	for id := range m.removedapp_role_policy {
		ids = append(ids, id)
	}
	return
}

// AppRolePolicyIDs returns the "app_role_policy" edge IDs in the mutation.
func (m *AppPolicyMutation) AppRolePolicyIDs() (ids []int) {
	for id := range m.app_role_policy {
		ids = append(ids, id)
	}
	return
}

// ResetAppRolePolicy resets all changes to the "app_role_policy" edge.
func (m *AppPolicyMutation) ResetAppRolePolicy() {
	m.app_role_policy = nil
	m.clearedapp_role_policy = false
	m.removedapp_role_policy = nil
}

// Where appends a list predicates to the AppPolicyMutation builder.
func (m *AppPolicyMutation) Where(ps ...predicate.AppPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppPolicy).
func (m *AppPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppPolicyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, apppolicy.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, apppolicy.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, apppolicy.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, apppolicy.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, apppolicy.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, apppolicy.FieldName)
	}
	if m.comments != nil {
		fields = append(fields, apppolicy.FieldComments)
	}
	if m.rules != nil {
		fields = append(fields, apppolicy.FieldRules)
	}
	if m.version != nil {
		fields = append(fields, apppolicy.FieldVersion)
	}
	if m.auto_grant != nil {
		fields = append(fields, apppolicy.FieldAutoGrant)
	}
	if m.status != nil {
		fields = append(fields, apppolicy.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apppolicy.FieldCreatedBy:
		return m.CreatedBy()
	case apppolicy.FieldCreatedAt:
		return m.CreatedAt()
	case apppolicy.FieldUpdatedBy:
		return m.UpdatedBy()
	case apppolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case apppolicy.FieldAppID:
		return m.AppID()
	case apppolicy.FieldName:
		return m.Name()
	case apppolicy.FieldComments:
		return m.Comments()
	case apppolicy.FieldRules:
		return m.Rules()
	case apppolicy.FieldVersion:
		return m.Version()
	case apppolicy.FieldAutoGrant:
		return m.AutoGrant()
	case apppolicy.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apppolicy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case apppolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apppolicy.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case apppolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apppolicy.FieldAppID:
		return m.OldAppID(ctx)
	case apppolicy.FieldName:
		return m.OldName(ctx)
	case apppolicy.FieldComments:
		return m.OldComments(ctx)
	case apppolicy.FieldRules:
		return m.OldRules(ctx)
	case apppolicy.FieldVersion:
		return m.OldVersion(ctx)
	case apppolicy.FieldAutoGrant:
		return m.OldAutoGrant(ctx)
	case apppolicy.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown AppPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apppolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case apppolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apppolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case apppolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apppolicy.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case apppolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apppolicy.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case apppolicy.FieldRules:
		v, ok := value.([]*types.PolicyRule)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRules(v)
		return nil
	case apppolicy.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case apppolicy.FieldAutoGrant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoGrant(v)
		return nil
	case apppolicy.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AppPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppPolicyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, apppolicy.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, apppolicy.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppPolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apppolicy.FieldCreatedBy:
		return m.AddedCreatedBy()
	case apppolicy.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apppolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case apppolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AppPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apppolicy.FieldUpdatedBy) {
		fields = append(fields, apppolicy.FieldUpdatedBy)
	}
	if m.FieldCleared(apppolicy.FieldUpdatedAt) {
		fields = append(fields, apppolicy.FieldUpdatedAt)
	}
	if m.FieldCleared(apppolicy.FieldAppID) {
		fields = append(fields, apppolicy.FieldAppID)
	}
	if m.FieldCleared(apppolicy.FieldComments) {
		fields = append(fields, apppolicy.FieldComments)
	}
	if m.FieldCleared(apppolicy.FieldStatus) {
		fields = append(fields, apppolicy.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppPolicyMutation) ClearField(name string) error {
	switch name {
	case apppolicy.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case apppolicy.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case apppolicy.FieldAppID:
		m.ClearAppID()
		return nil
	case apppolicy.FieldComments:
		m.ClearComments()
		return nil
	case apppolicy.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown AppPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppPolicyMutation) ResetField(name string) error {
	switch name {
	case apppolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case apppolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apppolicy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case apppolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apppolicy.FieldAppID:
		m.ResetAppID()
		return nil
	case apppolicy.FieldName:
		m.ResetName()
		return nil
	case apppolicy.FieldComments:
		m.ResetComments()
		return nil
	case apppolicy.FieldRules:
		m.ResetRules()
		return nil
	case apppolicy.FieldVersion:
		m.ResetVersion()
		return nil
	case apppolicy.FieldAutoGrant:
		m.ResetAutoGrant()
		return nil
	case apppolicy.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown AppPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, apppolicy.EdgeApp)
	}
	if m.roles != nil {
		edges = append(edges, apppolicy.EdgeRoles)
	}
	if m.app_role_policy != nil {
		edges = append(edges, apppolicy.EdgeAppRolePolicy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppPolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apppolicy.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case apppolicy.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case apppolicy.EdgeAppRolePolicy:
		ids := make([]ent.Value, 0, len(m.app_role_policy))
		for id := range m.app_role_policy {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedroles != nil {
		edges = append(edges, apppolicy.EdgeRoles)
	}
	if m.removedapp_role_policy != nil {
		edges = append(edges, apppolicy.EdgeAppRolePolicy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppPolicyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apppolicy.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case apppolicy.EdgeAppRolePolicy:
		ids := make([]ent.Value, 0, len(m.removedapp_role_policy))
		for id := range m.removedapp_role_policy {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, apppolicy.EdgeApp)
	}
	if m.clearedroles {
		edges = append(edges, apppolicy.EdgeRoles)
	}
	if m.clearedapp_role_policy {
		edges = append(edges, apppolicy.EdgeAppRolePolicy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppPolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case apppolicy.EdgeApp:
		return m.clearedapp
	case apppolicy.EdgeRoles:
		return m.clearedroles
	case apppolicy.EdgeAppRolePolicy:
		return m.clearedapp_role_policy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppPolicyMutation) ClearEdge(name string) error {
	switch name {
	case apppolicy.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppPolicyMutation) ResetEdge(name string) error {
	switch name {
	case apppolicy.EdgeApp:
		m.ResetApp()
		return nil
	case apppolicy.EdgeRoles:
		m.ResetRoles()
		return nil
	case apppolicy.EdgeAppRolePolicy:
		m.ResetAppRolePolicy()
		return nil
	}
	return fmt.Errorf("unknown AppPolicy edge %s", name)
}

// AppResMutation represents an operation that mutates the AppRes nodes in the graph.
type AppResMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	name          *string
	type_name     *string
	arn_pattern   *string
	clearedFields map[string]struct{}
	app           *int
	clearedapp    bool
	done          bool
	oldValue      func(context.Context) (*AppRes, error)
	predicates    []predicate.AppRes
}

var _ ent.Mutation = (*AppResMutation)(nil)

// appresOption allows management of the mutation configuration using functional options.
type appresOption func(*AppResMutation)

// newAppResMutation creates new mutation for the AppRes entity.
func newAppResMutation(c config, op Op, opts ...appresOption) *AppResMutation {
	m := &AppResMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppResID sets the ID field of the mutation.
func withAppResID(id int) appresOption {
	return func(m *AppResMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRes
		)
		m.oldValue = func(ctx context.Context) (*AppRes, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRes sets the old AppRes of the mutation.
func withAppRes(node *AppRes) appresOption {
	return func(m *AppResMutation) {
		m.oldValue = func(context.Context) (*AppRes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppResMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppResMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRes entities.
func (m *AppResMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppResMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppResMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRes.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppResMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppResMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppResMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppResMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppResMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppResMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppResMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppResMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppResMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppResMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppResMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppResMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppResMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[appres.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppResMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[appres.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppResMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, appres.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppResMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppResMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppResMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appres.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppResMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appres.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppResMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appres.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppResMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppResMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppResMutation) ClearAppID() {
	m.app = nil
	m.clearedFields[appres.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppResMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appres.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppResMutation) ResetAppID() {
	m.app = nil
	delete(m.clearedFields, appres.FieldAppID)
}

// SetName sets the "name" field.
func (m *AppResMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppResMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppResMutation) ResetName() {
	m.name = nil
}

// SetTypeName sets the "type_name" field.
func (m *AppResMutation) SetTypeName(s string) {
	m.type_name = &s
}

// TypeName returns the value of the "type_name" field in the mutation.
func (m *AppResMutation) TypeName() (r string, exists bool) {
	v := m.type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "type_name" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName resets all changes to the "type_name" field.
func (m *AppResMutation) ResetTypeName() {
	m.type_name = nil
}

// SetArnPattern sets the "arn_pattern" field.
func (m *AppResMutation) SetArnPattern(s string) {
	m.arn_pattern = &s
}

// ArnPattern returns the value of the "arn_pattern" field in the mutation.
func (m *AppResMutation) ArnPattern() (r string, exists bool) {
	v := m.arn_pattern
	if v == nil {
		return
	}
	return *v, true
}

// OldArnPattern returns the old "arn_pattern" field's value of the AppRes entity.
// If the AppRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppResMutation) OldArnPattern(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArnPattern is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArnPattern requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArnPattern: %w", err)
	}
	return oldValue.ArnPattern, nil
}

// ResetArnPattern resets all changes to the "arn_pattern" field.
func (m *AppResMutation) ResetArnPattern() {
	m.arn_pattern = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppResMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppResMutation) AppCleared() bool {
	return m.AppIDCleared() || m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppResMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppResMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the AppResMutation builder.
func (m *AppResMutation) Where(ps ...predicate.AppRes) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppResMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppResMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRes, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppResMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppResMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRes).
func (m *AppResMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppResMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, appres.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, appres.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, appres.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, appres.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, appres.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, appres.FieldName)
	}
	if m.type_name != nil {
		fields = append(fields, appres.FieldTypeName)
	}
	if m.arn_pattern != nil {
		fields = append(fields, appres.FieldArnPattern)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppResMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appres.FieldCreatedBy:
		return m.CreatedBy()
	case appres.FieldCreatedAt:
		return m.CreatedAt()
	case appres.FieldUpdatedBy:
		return m.UpdatedBy()
	case appres.FieldUpdatedAt:
		return m.UpdatedAt()
	case appres.FieldAppID:
		return m.AppID()
	case appres.FieldName:
		return m.Name()
	case appres.FieldTypeName:
		return m.TypeName()
	case appres.FieldArnPattern:
		return m.ArnPattern()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppResMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appres.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case appres.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appres.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case appres.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appres.FieldAppID:
		return m.OldAppID(ctx)
	case appres.FieldName:
		return m.OldName(ctx)
	case appres.FieldTypeName:
		return m.OldTypeName(ctx)
	case appres.FieldArnPattern:
		return m.OldArnPattern(ctx)
	}
	return nil, fmt.Errorf("unknown AppRes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppResMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appres.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case appres.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appres.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case appres.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appres.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appres.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appres.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case appres.FieldArnPattern:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArnPattern(v)
		return nil
	}
	return fmt.Errorf("unknown AppRes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppResMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, appres.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, appres.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppResMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appres.FieldCreatedBy:
		return m.AddedCreatedBy()
	case appres.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppResMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appres.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case appres.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AppRes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppResMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appres.FieldUpdatedBy) {
		fields = append(fields, appres.FieldUpdatedBy)
	}
	if m.FieldCleared(appres.FieldUpdatedAt) {
		fields = append(fields, appres.FieldUpdatedAt)
	}
	if m.FieldCleared(appres.FieldAppID) {
		fields = append(fields, appres.FieldAppID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppResMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppResMutation) ClearField(name string) error {
	switch name {
	case appres.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case appres.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case appres.FieldAppID:
		m.ClearAppID()
		return nil
	}
	return fmt.Errorf("unknown AppRes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppResMutation) ResetField(name string) error {
	switch name {
	case appres.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case appres.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appres.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case appres.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appres.FieldAppID:
		m.ResetAppID()
		return nil
	case appres.FieldName:
		m.ResetName()
		return nil
	case appres.FieldTypeName:
		m.ResetTypeName()
		return nil
	case appres.FieldArnPattern:
		m.ResetArnPattern()
		return nil
	}
	return fmt.Errorf("unknown AppRes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppResMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.app != nil {
		edges = append(edges, appres.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppResMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appres.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppResMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppResMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppResMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapp {
		edges = append(edges, appres.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppResMutation) EdgeCleared(name string) bool {
	switch name {
	case appres.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppResMutation) ClearEdge(name string) error {
	switch name {
	case appres.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppRes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppResMutation) ResetEdge(name string) error {
	switch name {
	case appres.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AppRes edge %s", name)
}

// AppRoleMutation represents an operation that mutates the AppRole nodes in the graph.
type AppRoleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_by             *int
	addcreated_by          *int
	created_at             *time.Time
	updated_by             *int
	addupdated_by          *int
	updated_at             *time.Time
	name                   *string
	comments               *string
	auto_grant             *bool
	editable               *bool
	clearedFields          map[string]struct{}
	app                    *int
	clearedapp             bool
	policies               map[int]struct{}
	removedpolicies        map[int]struct{}
	clearedpolicies        bool
	app_role_policy        map[int]struct{}
	removedapp_role_policy map[int]struct{}
	clearedapp_role_policy bool
	done                   bool
	oldValue               func(context.Context) (*AppRole, error)
	predicates             []predicate.AppRole
}

var _ ent.Mutation = (*AppRoleMutation)(nil)

// approleOption allows management of the mutation configuration using functional options.
type approleOption func(*AppRoleMutation)

// newAppRoleMutation creates new mutation for the AppRole entity.
func newAppRoleMutation(c config, op Op, opts ...approleOption) *AppRoleMutation {
	m := &AppRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRoleID sets the ID field of the mutation.
func withAppRoleID(id int) approleOption {
	return func(m *AppRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRole
		)
		m.oldValue = func(ctx context.Context) (*AppRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRole sets the old AppRole of the mutation.
func withAppRole(node *AppRole) approleOption {
	return func(m *AppRoleMutation) {
		m.oldValue = func(context.Context) (*AppRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRole entities.
func (m *AppRoleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppRoleMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppRoleMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppRoleMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppRoleMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppRoleMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppRoleMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppRoleMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppRoleMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppRoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[approle.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[approle.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, approle.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[approle.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[approle.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, approle.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppRoleMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRoleMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppRoleMutation) ClearAppID() {
	m.app = nil
	m.clearedFields[approle.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppRoleMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[approle.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRoleMutation) ResetAppID() {
	m.app = nil
	delete(m.clearedFields, approle.FieldAppID)
}

// SetName sets the "name" field.
func (m *AppRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppRoleMutation) ResetName() {
	m.name = nil
}

// SetComments sets the "comments" field.
func (m *AppRoleMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *AppRoleMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *AppRoleMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[approle.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *AppRoleMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[approle.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *AppRoleMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, approle.FieldComments)
}

// SetAutoGrant sets the "auto_grant" field.
func (m *AppRoleMutation) SetAutoGrant(b bool) {
	m.auto_grant = &b
}

// AutoGrant returns the value of the "auto_grant" field in the mutation.
func (m *AppRoleMutation) AutoGrant() (r bool, exists bool) {
	v := m.auto_grant
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoGrant returns the old "auto_grant" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldAutoGrant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoGrant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoGrant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoGrant: %w", err)
	}
	return oldValue.AutoGrant, nil
}

// ResetAutoGrant resets all changes to the "auto_grant" field.
func (m *AppRoleMutation) ResetAutoGrant() {
	m.auto_grant = nil
}

// SetEditable sets the "editable" field.
func (m *AppRoleMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the value of the "editable" field in the mutation.
func (m *AppRoleMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old "editable" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldEditable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEditable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ResetEditable resets all changes to the "editable" field.
func (m *AppRoleMutation) ResetEditable() {
	m.editable = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppRoleMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppRoleMutation) AppCleared() bool {
	return m.AppIDCleared() || m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppRoleMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppRoleMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddPolicyIDs adds the "policies" edge to the AppPolicy entity by ids.
func (m *AppRoleMutation) AddPolicyIDs(ids ...int) {
	if m.policies == nil {
		m.policies = make(map[int]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the "policies" edge to the AppPolicy entity.
func (m *AppRoleMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared reports if the "policies" edge to the AppPolicy entity was cleared.
func (m *AppRoleMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the "policies" edge to the AppPolicy entity by IDs.
func (m *AppRoleMutation) RemovePolicyIDs(ids ...int) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.policies, ids[i])
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed IDs of the "policies" edge to the AppPolicy entity.
func (m *AppRoleMutation) RemovedPoliciesIDs() (ids []int) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the "policies" edge IDs in the mutation.
func (m *AppRoleMutation) PoliciesIDs() (ids []int) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies resets all changes to the "policies" edge.
func (m *AppRoleMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// AddAppRolePolicyIDs adds the "app_role_policy" edge to the AppRolePolicy entity by ids.
func (m *AppRoleMutation) AddAppRolePolicyIDs(ids ...int) {
	if m.app_role_policy == nil {
		m.app_role_policy = make(map[int]struct{})
	}
	for i := range ids {
		m.app_role_policy[ids[i]] = struct{}{}
	}
}

// ClearAppRolePolicy clears the "app_role_policy" edge to the AppRolePolicy entity.
func (m *AppRoleMutation) ClearAppRolePolicy() {
	m.clearedapp_role_policy = true
}

// AppRolePolicyCleared reports if the "app_role_policy" edge to the AppRolePolicy entity was cleared.
func (m *AppRoleMutation) AppRolePolicyCleared() bool {
	return m.clearedapp_role_policy
}

// RemoveAppRolePolicyIDs removes the "app_role_policy" edge to the AppRolePolicy entity by IDs.
func (m *AppRoleMutation) RemoveAppRolePolicyIDs(ids ...int) {
	if m.removedapp_role_policy == nil {
		m.removedapp_role_policy = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.app_role_policy, ids[i])
		m.removedapp_role_policy[ids[i]] = struct{}{}
	}
}

// RemovedAppRolePolicy returns the removed IDs of the "app_role_policy" edge to the AppRolePolicy entity.
func (m *AppRoleMutation) RemovedAppRolePolicyIDs() (ids []int) {
	for id := range m.removedapp_role_policy {
		ids = append(ids, id)
	}
	return
}

// AppRolePolicyIDs returns the "app_role_policy" edge IDs in the mutation.
func (m *AppRoleMutation) AppRolePolicyIDs() (ids []int) {
	for id := range m.app_role_policy {
		ids = append(ids, id)
	}
	return
}

// ResetAppRolePolicy resets all changes to the "app_role_policy" edge.
func (m *AppRoleMutation) ResetAppRolePolicy() {
	m.app_role_policy = nil
	m.clearedapp_role_policy = false
	m.removedapp_role_policy = nil
}

// Where appends a list predicates to the AppRoleMutation builder.
func (m *AppRoleMutation) Where(ps ...predicate.AppRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRole).
func (m *AppRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, approle.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, approle.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, approle.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, approle.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, approle.FieldName)
	}
	if m.comments != nil {
		fields = append(fields, approle.FieldComments)
	}
	if m.auto_grant != nil {
		fields = append(fields, approle.FieldAutoGrant)
	}
	if m.editable != nil {
		fields = append(fields, approle.FieldEditable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedBy:
		return m.CreatedBy()
	case approle.FieldCreatedAt:
		return m.CreatedAt()
	case approle.FieldUpdatedBy:
		return m.UpdatedBy()
	case approle.FieldUpdatedAt:
		return m.UpdatedAt()
	case approle.FieldAppID:
		return m.AppID()
	case approle.FieldName:
		return m.Name()
	case approle.FieldComments:
		return m.Comments()
	case approle.FieldAutoGrant:
		return m.AutoGrant()
	case approle.FieldEditable:
		return m.Editable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approle.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case approle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approle.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case approle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approle.FieldAppID:
		return m.OldAppID(ctx)
	case approle.FieldName:
		return m.OldName(ctx)
	case approle.FieldComments:
		return m.OldComments(ctx)
	case approle.FieldAutoGrant:
		return m.OldAutoGrant(ctx)
	case approle.FieldEditable:
		return m.OldEditable(ctx)
	}
	return nil, fmt.Errorf("unknown AppRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case approle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approle.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case approle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approle.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case approle.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case approle.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case approle.FieldAutoGrant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoGrant(v)
		return nil
	case approle.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, approle.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, approle.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedBy:
		return m.AddedCreatedBy()
	case approle.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case approle.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approle.FieldUpdatedBy) {
		fields = append(fields, approle.FieldUpdatedBy)
	}
	if m.FieldCleared(approle.FieldUpdatedAt) {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.FieldCleared(approle.FieldAppID) {
		fields = append(fields, approle.FieldAppID)
	}
	if m.FieldCleared(approle.FieldComments) {
		fields = append(fields, approle.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRoleMutation) ClearField(name string) error {
	switch name {
	case approle.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case approle.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case approle.FieldAppID:
		m.ClearAppID()
		return nil
	case approle.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown AppRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRoleMutation) ResetField(name string) error {
	switch name {
	case approle.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case approle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approle.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case approle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approle.FieldAppID:
		m.ResetAppID()
		return nil
	case approle.FieldName:
		m.ResetName()
		return nil
	case approle.FieldComments:
		m.ResetComments()
		return nil
	case approle.FieldAutoGrant:
		m.ResetAutoGrant()
		return nil
	case approle.FieldEditable:
		m.ResetEditable()
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, approle.EdgeApp)
	}
	if m.policies != nil {
		edges = append(edges, approle.EdgePolicies)
	}
	if m.app_role_policy != nil {
		edges = append(edges, approle.EdgeAppRolePolicy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case approle.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case approle.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	case approle.EdgeAppRolePolicy:
		ids := make([]ent.Value, 0, len(m.app_role_policy))
		for id := range m.app_role_policy {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpolicies != nil {
		edges = append(edges, approle.EdgePolicies)
	}
	if m.removedapp_role_policy != nil {
		edges = append(edges, approle.EdgeAppRolePolicy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case approle.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	case approle.EdgeAppRolePolicy:
		ids := make([]ent.Value, 0, len(m.removedapp_role_policy))
		for id := range m.removedapp_role_policy {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, approle.EdgeApp)
	}
	if m.clearedpolicies {
		edges = append(edges, approle.EdgePolicies)
	}
	if m.clearedapp_role_policy {
		edges = append(edges, approle.EdgeAppRolePolicy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case approle.EdgeApp:
		return m.clearedapp
	case approle.EdgePolicies:
		return m.clearedpolicies
	case approle.EdgeAppRolePolicy:
		return m.clearedapp_role_policy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRoleMutation) ClearEdge(name string) error {
	switch name {
	case approle.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRoleMutation) ResetEdge(name string) error {
	switch name {
	case approle.EdgeApp:
		m.ResetApp()
		return nil
	case approle.EdgePolicies:
		m.ResetPolicies()
		return nil
	case approle.EdgeAppRolePolicy:
		m.ResetAppRolePolicy()
		return nil
	}
	return fmt.Errorf("unknown AppRole edge %s", name)
}

// AppRolePolicyMutation represents an operation that mutates the AppRolePolicy nodes in the graph.
type AppRolePolicyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	app_id        *int
	addapp_id     *int
	clearedFields map[string]struct{}
	role          *int
	clearedrole   bool
	policy        *int
	clearedpolicy bool
	done          bool
	oldValue      func(context.Context) (*AppRolePolicy, error)
	predicates    []predicate.AppRolePolicy
}

var _ ent.Mutation = (*AppRolePolicyMutation)(nil)

// approlepolicyOption allows management of the mutation configuration using functional options.
type approlepolicyOption func(*AppRolePolicyMutation)

// newAppRolePolicyMutation creates new mutation for the AppRolePolicy entity.
func newAppRolePolicyMutation(c config, op Op, opts ...approlepolicyOption) *AppRolePolicyMutation {
	m := &AppRolePolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRolePolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRolePolicyID sets the ID field of the mutation.
func withAppRolePolicyID(id int) approlepolicyOption {
	return func(m *AppRolePolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRolePolicy
		)
		m.oldValue = func(ctx context.Context) (*AppRolePolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRolePolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRolePolicy sets the old AppRolePolicy of the mutation.
func withAppRolePolicy(node *AppRolePolicy) approlepolicyOption {
	return func(m *AppRolePolicyMutation) {
		m.oldValue = func(context.Context) (*AppRolePolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRolePolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRolePolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRolePolicy entities.
func (m *AppRolePolicyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRolePolicyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRolePolicyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRolePolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *AppRolePolicyMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppRolePolicyMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppRolePolicy entity.
// If the AppRolePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePolicyMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AppRolePolicyMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AppRolePolicyMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppRolePolicyMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRolePolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRolePolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRolePolicy entity.
// If the AppRolePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRolePolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AppRolePolicyMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AppRolePolicyMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AppRolePolicy entity.
// If the AppRolePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePolicyMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AppRolePolicyMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AppRolePolicyMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AppRolePolicyMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[approlepolicy.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AppRolePolicyMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[approlepolicy.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AppRolePolicyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, approlepolicy.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRolePolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRolePolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRolePolicy entity.
// If the AppRolePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppRolePolicyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[approlepolicy.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppRolePolicyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[approlepolicy.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRolePolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, approlepolicy.FieldUpdatedAt)
}

// SetAppRoleID sets the "app_role_id" field.
func (m *AppRolePolicyMutation) SetAppRoleID(i int) {
	m.role = &i
}

// AppRoleID returns the value of the "app_role_id" field in the mutation.
func (m *AppRolePolicyMutation) AppRoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldAppRoleID returns the old "app_role_id" field's value of the AppRolePolicy entity.
// If the AppRolePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePolicyMutation) OldAppRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppRoleID: %w", err)
	}
	return oldValue.AppRoleID, nil
}

// ResetAppRoleID resets all changes to the "app_role_id" field.
func (m *AppRolePolicyMutation) ResetAppRoleID() {
	m.role = nil
}

// SetAppPolicyID sets the "app_policy_id" field.
func (m *AppRolePolicyMutation) SetAppPolicyID(i int) {
	m.policy = &i
}

// AppPolicyID returns the value of the "app_policy_id" field in the mutation.
func (m *AppRolePolicyMutation) AppPolicyID() (r int, exists bool) {
	v := m.policy
	if v == nil {
		return
	}
	return *v, true
}

// OldAppPolicyID returns the old "app_policy_id" field's value of the AppRolePolicy entity.
// If the AppRolePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePolicyMutation) OldAppPolicyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppPolicyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppPolicyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppPolicyID: %w", err)
	}
	return oldValue.AppPolicyID, nil
}

// ResetAppPolicyID resets all changes to the "app_policy_id" field.
func (m *AppRolePolicyMutation) ResetAppPolicyID() {
	m.policy = nil
}

// SetAppID sets the "app_id" field.
func (m *AppRolePolicyMutation) SetAppID(i int) {
	m.app_id = &i
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRolePolicyMutation) AppID() (r int, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRolePolicy entity.
// If the AppRolePolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePolicyMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds i to the "app_id" field.
func (m *AppRolePolicyMutation) AddAppID(i int) {
	if m.addapp_id != nil {
		*m.addapp_id += i
	} else {
		m.addapp_id = &i
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *AppRolePolicyMutation) AddedAppID() (r int, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRolePolicyMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetRoleID sets the "role" edge to the AppRole entity by id.
func (m *AppRolePolicyMutation) SetRoleID(id int) {
	m.role = &id
}

// ClearRole clears the "role" edge to the AppRole entity.
func (m *AppRolePolicyMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the AppRole entity was cleared.
func (m *AppRolePolicyMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *AppRolePolicyMutation) RoleID() (id int, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *AppRolePolicyMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *AppRolePolicyMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// SetPolicyID sets the "policy" edge to the AppPolicy entity by id.
func (m *AppRolePolicyMutation) SetPolicyID(id int) {
	m.policy = &id
}

// ClearPolicy clears the "policy" edge to the AppPolicy entity.
func (m *AppRolePolicyMutation) ClearPolicy() {
	m.clearedpolicy = true
}

// PolicyCleared reports if the "policy" edge to the AppPolicy entity was cleared.
func (m *AppRolePolicyMutation) PolicyCleared() bool {
	return m.clearedpolicy
}

// PolicyID returns the "policy" edge ID in the mutation.
func (m *AppRolePolicyMutation) PolicyID() (id int, exists bool) {
	if m.policy != nil {
		return *m.policy, true
	}
	return
}

// PolicyIDs returns the "policy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PolicyID instead. It exists only for internal usage by the builders.
func (m *AppRolePolicyMutation) PolicyIDs() (ids []int) {
	if id := m.policy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPolicy resets all changes to the "policy" edge.
func (m *AppRolePolicyMutation) ResetPolicy() {
	m.policy = nil
	m.clearedpolicy = false
}

// Where appends a list predicates to the AppRolePolicyMutation builder.
func (m *AppRolePolicyMutation) Where(ps ...predicate.AppRolePolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppRolePolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppRolePolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRolePolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppRolePolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppRolePolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRolePolicy).
func (m *AppRolePolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRolePolicyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_by != nil {
		fields = append(fields, approlepolicy.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, approlepolicy.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, approlepolicy.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, approlepolicy.FieldUpdatedAt)
	}
	if m.role != nil {
		fields = append(fields, approlepolicy.FieldAppRoleID)
	}
	if m.policy != nil {
		fields = append(fields, approlepolicy.FieldAppPolicyID)
	}
	if m.app_id != nil {
		fields = append(fields, approlepolicy.FieldAppID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRolePolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approlepolicy.FieldCreatedBy:
		return m.CreatedBy()
	case approlepolicy.FieldCreatedAt:
		return m.CreatedAt()
	case approlepolicy.FieldUpdatedBy:
		return m.UpdatedBy()
	case approlepolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case approlepolicy.FieldAppRoleID:
		return m.AppRoleID()
	case approlepolicy.FieldAppPolicyID:
		return m.AppPolicyID()
	case approlepolicy.FieldAppID:
		return m.AppID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRolePolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approlepolicy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case approlepolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approlepolicy.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case approlepolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approlepolicy.FieldAppRoleID:
		return m.OldAppRoleID(ctx)
	case approlepolicy.FieldAppPolicyID:
		return m.OldAppPolicyID(ctx)
	case approlepolicy.FieldAppID:
		return m.OldAppID(ctx)
	}
	return nil, fmt.Errorf("unknown AppRolePolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRolePolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approlepolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case approlepolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approlepolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case approlepolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approlepolicy.FieldAppRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppRoleID(v)
		return nil
	case approlepolicy.FieldAppPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppPolicyID(v)
		return nil
	case approlepolicy.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRolePolicyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, approlepolicy.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, approlepolicy.FieldUpdatedBy)
	}
	if m.addapp_id != nil {
		fields = append(fields, approlepolicy.FieldAppID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRolePolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approlepolicy.FieldCreatedBy:
		return m.AddedCreatedBy()
	case approlepolicy.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case approlepolicy.FieldAppID:
		return m.AddedAppID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRolePolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approlepolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case approlepolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case approlepolicy.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRolePolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approlepolicy.FieldUpdatedBy) {
		fields = append(fields, approlepolicy.FieldUpdatedBy)
	}
	if m.FieldCleared(approlepolicy.FieldUpdatedAt) {
		fields = append(fields, approlepolicy.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRolePolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRolePolicyMutation) ClearField(name string) error {
	switch name {
	case approlepolicy.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case approlepolicy.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRolePolicyMutation) ResetField(name string) error {
	switch name {
	case approlepolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case approlepolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approlepolicy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case approlepolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approlepolicy.FieldAppRoleID:
		m.ResetAppRoleID()
		return nil
	case approlepolicy.FieldAppPolicyID:
		m.ResetAppPolicyID()
		return nil
	case approlepolicy.FieldAppID:
		m.ResetAppID()
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRolePolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.role != nil {
		edges = append(edges, approlepolicy.EdgeRole)
	}
	if m.policy != nil {
		edges = append(edges, approlepolicy.EdgePolicy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRolePolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case approlepolicy.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case approlepolicy.EdgePolicy:
		if id := m.policy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRolePolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRolePolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRolePolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrole {
		edges = append(edges, approlepolicy.EdgeRole)
	}
	if m.clearedpolicy {
		edges = append(edges, approlepolicy.EdgePolicy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRolePolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case approlepolicy.EdgeRole:
		return m.clearedrole
	case approlepolicy.EdgePolicy:
		return m.clearedpolicy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRolePolicyMutation) ClearEdge(name string) error {
	switch name {
	case approlepolicy.EdgeRole:
		m.ClearRole()
		return nil
	case approlepolicy.EdgePolicy:
		m.ClearPolicy()
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRolePolicyMutation) ResetEdge(name string) error {
	switch name {
	case approlepolicy.EdgeRole:
		m.ResetRole()
		return nil
	case approlepolicy.EdgePolicy:
		m.ResetPolicy()
		return nil
	}
	return fmt.Errorf("unknown AppRolePolicy edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	name          *string
	tenant_id     *int
	addtenant_id  *int
	ref_count     *int
	addref_count  *int
	_path         *string
	size          *int
	addsize       *int
	mine_type     *string
	md5           *string
	clearedFields map[string]struct{}
	source        *int
	clearedsource bool
	done          bool
	oldValue      func(context.Context) (*File, error)
	predicates    []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *FileMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FileMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FileMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FileMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FileMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FileMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FileMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FileMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FileMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FileMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[file.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FileMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[file.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FileMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, file.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[file.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, file.FieldUpdatedAt)
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetSourceID sets the "source_id" field.
func (m *FileMutation) SetSourceID(i int) {
	m.source = &i
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *FileMutation) SourceID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *FileMutation) ResetSourceID() {
	m.source = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *FileMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *FileMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *FileMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *FileMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *FileMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetRefCount sets the "ref_count" field.
func (m *FileMutation) SetRefCount(i int) {
	m.ref_count = &i
	m.addref_count = nil
}

// RefCount returns the value of the "ref_count" field in the mutation.
func (m *FileMutation) RefCount() (r int, exists bool) {
	v := m.ref_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRefCount returns the old "ref_count" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldRefCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefCount: %w", err)
	}
	return oldValue.RefCount, nil
}

// AddRefCount adds i to the "ref_count" field.
func (m *FileMutation) AddRefCount(i int) {
	if m.addref_count != nil {
		*m.addref_count += i
	} else {
		m.addref_count = &i
	}
}

// AddedRefCount returns the value that was added to the "ref_count" field in this mutation.
func (m *FileMutation) AddedRefCount() (r int, exists bool) {
	v := m.addref_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearRefCount clears the value of the "ref_count" field.
func (m *FileMutation) ClearRefCount() {
	m.ref_count = nil
	m.addref_count = nil
	m.clearedFields[file.FieldRefCount] = struct{}{}
}

// RefCountCleared returns if the "ref_count" field was cleared in this mutation.
func (m *FileMutation) RefCountCleared() bool {
	_, ok := m.clearedFields[file.FieldRefCount]
	return ok
}

// ResetRefCount resets all changes to the "ref_count" field.
func (m *FileMutation) ResetRefCount() {
	m.ref_count = nil
	m.addref_count = nil
	delete(m.clearedFields, file.FieldRefCount)
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *FileMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[file.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *FileMutation) SizeCleared() bool {
	_, ok := m.clearedFields[file.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, file.FieldSize)
}

// SetMineType sets the "mine_type" field.
func (m *FileMutation) SetMineType(s string) {
	m.mine_type = &s
}

// MineType returns the value of the "mine_type" field in the mutation.
func (m *FileMutation) MineType() (r string, exists bool) {
	v := m.mine_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMineType returns the old "mine_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldMineType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMineType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMineType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMineType: %w", err)
	}
	return oldValue.MineType, nil
}

// ClearMineType clears the value of the "mine_type" field.
func (m *FileMutation) ClearMineType() {
	m.mine_type = nil
	m.clearedFields[file.FieldMineType] = struct{}{}
}

// MineTypeCleared returns if the "mine_type" field was cleared in this mutation.
func (m *FileMutation) MineTypeCleared() bool {
	_, ok := m.clearedFields[file.FieldMineType]
	return ok
}

// ResetMineType resets all changes to the "mine_type" field.
func (m *FileMutation) ResetMineType() {
	m.mine_type = nil
	delete(m.clearedFields, file.FieldMineType)
}

// SetMd5 sets the "md5" field.
func (m *FileMutation) SetMd5(s string) {
	m.md5 = &s
}

// Md5 returns the value of the "md5" field in the mutation.
func (m *FileMutation) Md5() (r string, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old "md5" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// ClearMd5 clears the value of the "md5" field.
func (m *FileMutation) ClearMd5() {
	m.md5 = nil
	m.clearedFields[file.FieldMd5] = struct{}{}
}

// Md5Cleared returns if the "md5" field was cleared in this mutation.
func (m *FileMutation) Md5Cleared() bool {
	_, ok := m.clearedFields[file.FieldMd5]
	return ok
}

// ResetMd5 resets all changes to the "md5" field.
func (m *FileMutation) ResetMd5() {
	m.md5 = nil
	delete(m.clearedFields, file.FieldMd5)
}

// ClearSource clears the "source" edge to the FileSource entity.
func (m *FileMutation) ClearSource() {
	m.clearedsource = true
}

// SourceCleared reports if the "source" edge to the FileSource entity was cleared.
func (m *FileMutation) SourceCleared() bool {
	return m.clearedsource
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *FileMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *FileMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, file.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, file.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.source != nil {
		fields = append(fields, file.FieldSourceID)
	}
	if m.tenant_id != nil {
		fields = append(fields, file.FieldTenantID)
	}
	if m.ref_count != nil {
		fields = append(fields, file.FieldRefCount)
	}
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.mine_type != nil {
		fields = append(fields, file.FieldMineType)
	}
	if m.md5 != nil {
		fields = append(fields, file.FieldMd5)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedBy:
		return m.CreatedBy()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedBy:
		return m.UpdatedBy()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldName:
		return m.Name()
	case file.FieldSourceID:
		return m.SourceID()
	case file.FieldTenantID:
		return m.TenantID()
	case file.FieldRefCount:
		return m.RefCount()
	case file.FieldPath:
		return m.Path()
	case file.FieldSize:
		return m.Size()
	case file.FieldMineType:
		return m.MineType()
	case file.FieldMd5:
		return m.Md5()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldSourceID:
		return m.OldSourceID(ctx)
	case file.FieldTenantID:
		return m.OldTenantID(ctx)
	case file.FieldRefCount:
		return m.OldRefCount(ctx)
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldMineType:
		return m.OldMineType(ctx)
	case file.FieldMd5:
		return m.OldMd5(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case file.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case file.FieldRefCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefCount(v)
		return nil
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldMineType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMineType(v)
		return nil
	case file.FieldMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, file.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, file.FieldUpdatedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, file.FieldTenantID)
	}
	if m.addref_count != nil {
		fields = append(fields, file.FieldRefCount)
	}
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedBy:
		return m.AddedCreatedBy()
	case file.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case file.FieldTenantID:
		return m.AddedTenantID()
	case file.FieldRefCount:
		return m.AddedRefCount()
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case file.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case file.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case file.FieldRefCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefCount(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldUpdatedBy) {
		fields = append(fields, file.FieldUpdatedBy)
	}
	if m.FieldCleared(file.FieldUpdatedAt) {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.FieldCleared(file.FieldRefCount) {
		fields = append(fields, file.FieldRefCount)
	}
	if m.FieldCleared(file.FieldSize) {
		fields = append(fields, file.FieldSize)
	}
	if m.FieldCleared(file.FieldMineType) {
		fields = append(fields, file.FieldMineType)
	}
	if m.FieldCleared(file.FieldMd5) {
		fields = append(fields, file.FieldMd5)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case file.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case file.FieldRefCount:
		m.ClearRefCount()
		return nil
	case file.FieldSize:
		m.ClearSize()
		return nil
	case file.FieldMineType:
		m.ClearMineType()
		return nil
	case file.FieldMd5:
		m.ClearMd5()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldSourceID:
		m.ResetSourceID()
		return nil
	case file.FieldTenantID:
		m.ResetTenantID()
		return nil
	case file.FieldRefCount:
		m.ResetRefCount()
		return nil
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldMineType:
		m.ResetMineType()
		return nil
	case file.FieldMd5:
		m.ResetMd5()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.source != nil {
		edges = append(edges, file.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsource {
		edges = append(edges, file.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// FileSourceMutation represents an operation that mutates the FileSource nodes in the graph.
type FileSourceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	kind          *filesource.Kind
	comments      *string
	endpoint      *string
	region        *string
	bucket        *string
	clearedFields map[string]struct{}
	files         map[int]struct{}
	removedfiles  map[int]struct{}
	clearedfiles  bool
	done          bool
	oldValue      func(context.Context) (*FileSource, error)
	predicates    []predicate.FileSource
}

var _ ent.Mutation = (*FileSourceMutation)(nil)

// filesourceOption allows management of the mutation configuration using functional options.
type filesourceOption func(*FileSourceMutation)

// newFileSourceMutation creates new mutation for the FileSource entity.
func newFileSourceMutation(c config, op Op, opts ...filesourceOption) *FileSourceMutation {
	m := &FileSourceMutation{
		config:        c,
		op:            op,
		typ:           TypeFileSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileSourceID sets the ID field of the mutation.
func withFileSourceID(id int) filesourceOption {
	return func(m *FileSourceMutation) {
		var (
			err   error
			once  sync.Once
			value *FileSource
		)
		m.oldValue = func(ctx context.Context) (*FileSource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileSource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileSource sets the old FileSource of the mutation.
func withFileSource(node *FileSource) filesourceOption {
	return func(m *FileSourceMutation) {
		m.oldValue = func(context.Context) (*FileSource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileSourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileSourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileSource entities.
func (m *FileSourceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileSourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileSourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileSource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *FileSourceMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FileSourceMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FileSource entity.
// If the FileSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileSourceMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *FileSourceMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *FileSourceMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FileSourceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileSourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileSourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FileSource entity.
// If the FileSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileSourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileSourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FileSourceMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FileSourceMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the FileSource entity.
// If the FileSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileSourceMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *FileSourceMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *FileSourceMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FileSourceMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[filesource.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FileSourceMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[filesource.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FileSourceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, filesource.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileSourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileSourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FileSource entity.
// If the FileSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileSourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *FileSourceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[filesource.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *FileSourceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[filesource.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileSourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, filesource.FieldUpdatedAt)
}

// SetKind sets the "kind" field.
func (m *FileSourceMutation) SetKind(f filesource.Kind) {
	m.kind = &f
}

// Kind returns the value of the "kind" field in the mutation.
func (m *FileSourceMutation) Kind() (r filesource.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the FileSource entity.
// If the FileSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileSourceMutation) OldKind(ctx context.Context) (v filesource.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *FileSourceMutation) ResetKind() {
	m.kind = nil
}

// SetComments sets the "comments" field.
func (m *FileSourceMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *FileSourceMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the FileSource entity.
// If the FileSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileSourceMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *FileSourceMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[filesource.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *FileSourceMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[filesource.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *FileSourceMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, filesource.FieldComments)
}

// SetEndpoint sets the "endpoint" field.
func (m *FileSourceMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *FileSourceMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the FileSource entity.
// If the FileSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileSourceMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ClearEndpoint clears the value of the "endpoint" field.
func (m *FileSourceMutation) ClearEndpoint() {
	m.endpoint = nil
	m.clearedFields[filesource.FieldEndpoint] = struct{}{}
}

// EndpointCleared returns if the "endpoint" field was cleared in this mutation.
func (m *FileSourceMutation) EndpointCleared() bool {
	_, ok := m.clearedFields[filesource.FieldEndpoint]
	return ok
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *FileSourceMutation) ResetEndpoint() {
	m.endpoint = nil
	delete(m.clearedFields, filesource.FieldEndpoint)
}

// SetRegion sets the "region" field.
func (m *FileSourceMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *FileSourceMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the FileSource entity.
// If the FileSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileSourceMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ClearRegion clears the value of the "region" field.
func (m *FileSourceMutation) ClearRegion() {
	m.region = nil
	m.clearedFields[filesource.FieldRegion] = struct{}{}
}

// RegionCleared returns if the "region" field was cleared in this mutation.
func (m *FileSourceMutation) RegionCleared() bool {
	_, ok := m.clearedFields[filesource.FieldRegion]
	return ok
}

// ResetRegion resets all changes to the "region" field.
func (m *FileSourceMutation) ResetRegion() {
	m.region = nil
	delete(m.clearedFields, filesource.FieldRegion)
}

// SetBucket sets the "bucket" field.
func (m *FileSourceMutation) SetBucket(s string) {
	m.bucket = &s
}

// Bucket returns the value of the "bucket" field in the mutation.
func (m *FileSourceMutation) Bucket() (r string, exists bool) {
	v := m.bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldBucket returns the old "bucket" field's value of the FileSource entity.
// If the FileSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileSourceMutation) OldBucket(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucket: %w", err)
	}
	return oldValue.Bucket, nil
}

// ClearBucket clears the value of the "bucket" field.
func (m *FileSourceMutation) ClearBucket() {
	m.bucket = nil
	m.clearedFields[filesource.FieldBucket] = struct{}{}
}

// BucketCleared returns if the "bucket" field was cleared in this mutation.
func (m *FileSourceMutation) BucketCleared() bool {
	_, ok := m.clearedFields[filesource.FieldBucket]
	return ok
}

// ResetBucket resets all changes to the "bucket" field.
func (m *FileSourceMutation) ResetBucket() {
	m.bucket = nil
	delete(m.clearedFields, filesource.FieldBucket)
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *FileSourceMutation) AddFileIDs(ids ...int) {
	if m.files == nil {
		m.files = make(map[int]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *FileSourceMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *FileSourceMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *FileSourceMutation) RemoveFileIDs(ids ...int) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *FileSourceMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *FileSourceMutation) FilesIDs() (ids []int) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *FileSourceMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the FileSourceMutation builder.
func (m *FileSourceMutation) Where(ps ...predicate.FileSource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileSourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileSourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileSource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileSourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileSourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileSource).
func (m *FileSourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileSourceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, filesource.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, filesource.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, filesource.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, filesource.FieldUpdatedAt)
	}
	if m.kind != nil {
		fields = append(fields, filesource.FieldKind)
	}
	if m.comments != nil {
		fields = append(fields, filesource.FieldComments)
	}
	if m.endpoint != nil {
		fields = append(fields, filesource.FieldEndpoint)
	}
	if m.region != nil {
		fields = append(fields, filesource.FieldRegion)
	}
	if m.bucket != nil {
		fields = append(fields, filesource.FieldBucket)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileSourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filesource.FieldCreatedBy:
		return m.CreatedBy()
	case filesource.FieldCreatedAt:
		return m.CreatedAt()
	case filesource.FieldUpdatedBy:
		return m.UpdatedBy()
	case filesource.FieldUpdatedAt:
		return m.UpdatedAt()
	case filesource.FieldKind:
		return m.Kind()
	case filesource.FieldComments:
		return m.Comments()
	case filesource.FieldEndpoint:
		return m.Endpoint()
	case filesource.FieldRegion:
		return m.Region()
	case filesource.FieldBucket:
		return m.Bucket()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileSourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filesource.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case filesource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filesource.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case filesource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case filesource.FieldKind:
		return m.OldKind(ctx)
	case filesource.FieldComments:
		return m.OldComments(ctx)
	case filesource.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case filesource.FieldRegion:
		return m.OldRegion(ctx)
	case filesource.FieldBucket:
		return m.OldBucket(ctx)
	}
	return nil, fmt.Errorf("unknown FileSource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileSourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filesource.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case filesource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filesource.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case filesource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case filesource.FieldKind:
		v, ok := value.(filesource.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case filesource.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case filesource.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case filesource.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case filesource.FieldBucket:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucket(v)
		return nil
	}
	return fmt.Errorf("unknown FileSource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileSourceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, filesource.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, filesource.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileSourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filesource.FieldCreatedBy:
		return m.AddedCreatedBy()
	case filesource.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileSourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filesource.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case filesource.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown FileSource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileSourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(filesource.FieldUpdatedBy) {
		fields = append(fields, filesource.FieldUpdatedBy)
	}
	if m.FieldCleared(filesource.FieldUpdatedAt) {
		fields = append(fields, filesource.FieldUpdatedAt)
	}
	if m.FieldCleared(filesource.FieldComments) {
		fields = append(fields, filesource.FieldComments)
	}
	if m.FieldCleared(filesource.FieldEndpoint) {
		fields = append(fields, filesource.FieldEndpoint)
	}
	if m.FieldCleared(filesource.FieldRegion) {
		fields = append(fields, filesource.FieldRegion)
	}
	if m.FieldCleared(filesource.FieldBucket) {
		fields = append(fields, filesource.FieldBucket)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileSourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileSourceMutation) ClearField(name string) error {
	switch name {
	case filesource.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case filesource.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case filesource.FieldComments:
		m.ClearComments()
		return nil
	case filesource.FieldEndpoint:
		m.ClearEndpoint()
		return nil
	case filesource.FieldRegion:
		m.ClearRegion()
		return nil
	case filesource.FieldBucket:
		m.ClearBucket()
		return nil
	}
	return fmt.Errorf("unknown FileSource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileSourceMutation) ResetField(name string) error {
	switch name {
	case filesource.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case filesource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filesource.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case filesource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case filesource.FieldKind:
		m.ResetKind()
		return nil
	case filesource.FieldComments:
		m.ResetComments()
		return nil
	case filesource.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case filesource.FieldRegion:
		m.ResetRegion()
		return nil
	case filesource.FieldBucket:
		m.ResetBucket()
		return nil
	}
	return fmt.Errorf("unknown FileSource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileSourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.files != nil {
		edges = append(edges, filesource.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileSourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filesource.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileSourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfiles != nil {
		edges = append(edges, filesource.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileSourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case filesource.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileSourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfiles {
		edges = append(edges, filesource.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileSourceMutation) EdgeCleared(name string) bool {
	switch name {
	case filesource.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileSourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FileSource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileSourceMutation) ResetEdge(name string) error {
	switch name {
	case filesource.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown FileSource edge %s", name)
}

// OauthClientMutation represents an operation that mutates the OauthClient nodes in the graph.
type OauthClientMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	name          *string
	client_id     *string
	client_secret *string
	grant_types   *oauthclient.GrantTypes
	last_auth_at  *time.Time
	status        *typex.SimpleStatus
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*OauthClient, error)
	predicates    []predicate.OauthClient
}

var _ ent.Mutation = (*OauthClientMutation)(nil)

// oauthclientOption allows management of the mutation configuration using functional options.
type oauthclientOption func(*OauthClientMutation)

// newOauthClientMutation creates new mutation for the OauthClient entity.
func newOauthClientMutation(c config, op Op, opts ...oauthclientOption) *OauthClientMutation {
	m := &OauthClientMutation{
		config:        c,
		op:            op,
		typ:           TypeOauthClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauthClientID sets the ID field of the mutation.
func withOauthClientID(id int) oauthclientOption {
	return func(m *OauthClientMutation) {
		var (
			err   error
			once  sync.Once
			value *OauthClient
		)
		m.oldValue = func(ctx context.Context) (*OauthClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OauthClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauthClient sets the old OauthClient of the mutation.
func withOauthClient(node *OauthClient) oauthclientOption {
	return func(m *OauthClientMutation) {
		m.oldValue = func(context.Context) (*OauthClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OauthClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OauthClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OauthClient entities.
func (m *OauthClientMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OauthClientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OauthClientMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OauthClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OauthClientMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OauthClientMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OauthClientMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OauthClientMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OauthClientMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OauthClientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OauthClientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OauthClientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OauthClientMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OauthClientMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OauthClientMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OauthClientMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OauthClientMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[oauthclient.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OauthClientMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OauthClientMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, oauthclient.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OauthClientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OauthClientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OauthClientMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[oauthclient.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OauthClientMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OauthClientMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, oauthclient.FieldUpdatedAt)
}

// SetName sets the "name" field.
func (m *OauthClientMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OauthClientMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OauthClientMutation) ResetName() {
	m.name = nil
}

// SetClientID sets the "client_id" field.
func (m *OauthClientMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OauthClientMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OauthClientMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *OauthClientMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *OauthClientMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *OauthClientMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetGrantTypes sets the "grant_types" field.
func (m *OauthClientMutation) SetGrantTypes(ot oauthclient.GrantTypes) {
	m.grant_types = &ot
}

// GrantTypes returns the value of the "grant_types" field in the mutation.
func (m *OauthClientMutation) GrantTypes() (r oauthclient.GrantTypes, exists bool) {
	v := m.grant_types
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantTypes returns the old "grant_types" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldGrantTypes(ctx context.Context) (v oauthclient.GrantTypes, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantTypes: %w", err)
	}
	return oldValue.GrantTypes, nil
}

// ResetGrantTypes resets all changes to the "grant_types" field.
func (m *OauthClientMutation) ResetGrantTypes() {
	m.grant_types = nil
}

// SetUserID sets the "user_id" field.
func (m *OauthClientMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OauthClientMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OauthClientMutation) ResetUserID() {
	m.user = nil
}

// SetLastAuthAt sets the "last_auth_at" field.
func (m *OauthClientMutation) SetLastAuthAt(t time.Time) {
	m.last_auth_at = &t
}

// LastAuthAt returns the value of the "last_auth_at" field in the mutation.
func (m *OauthClientMutation) LastAuthAt() (r time.Time, exists bool) {
	v := m.last_auth_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastAuthAt returns the old "last_auth_at" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldLastAuthAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastAuthAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastAuthAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastAuthAt: %w", err)
	}
	return oldValue.LastAuthAt, nil
}

// ClearLastAuthAt clears the value of the "last_auth_at" field.
func (m *OauthClientMutation) ClearLastAuthAt() {
	m.last_auth_at = nil
	m.clearedFields[oauthclient.FieldLastAuthAt] = struct{}{}
}

// LastAuthAtCleared returns if the "last_auth_at" field was cleared in this mutation.
func (m *OauthClientMutation) LastAuthAtCleared() bool {
	_, ok := m.clearedFields[oauthclient.FieldLastAuthAt]
	return ok
}

// ResetLastAuthAt resets all changes to the "last_auth_at" field.
func (m *OauthClientMutation) ResetLastAuthAt() {
	m.last_auth_at = nil
	delete(m.clearedFields, oauthclient.FieldLastAuthAt)
}

// SetStatus sets the "status" field.
func (m *OauthClientMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *OauthClientMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OauthClient entity.
// If the OauthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthClientMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OauthClientMutation) ResetStatus() {
	m.status = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *OauthClientMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OauthClientMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OauthClientMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OauthClientMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OauthClientMutation builder.
func (m *OauthClientMutation) Where(ps ...predicate.OauthClient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OauthClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OauthClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OauthClient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OauthClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OauthClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OauthClient).
func (m *OauthClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OauthClientMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_by != nil {
		fields = append(fields, oauthclient.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, oauthclient.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, oauthclient.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthclient.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, oauthclient.FieldName)
	}
	if m.client_id != nil {
		fields = append(fields, oauthclient.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, oauthclient.FieldClientSecret)
	}
	if m.grant_types != nil {
		fields = append(fields, oauthclient.FieldGrantTypes)
	}
	if m.user != nil {
		fields = append(fields, oauthclient.FieldUserID)
	}
	if m.last_auth_at != nil {
		fields = append(fields, oauthclient.FieldLastAuthAt)
	}
	if m.status != nil {
		fields = append(fields, oauthclient.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OauthClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthclient.FieldCreatedBy:
		return m.CreatedBy()
	case oauthclient.FieldCreatedAt:
		return m.CreatedAt()
	case oauthclient.FieldUpdatedBy:
		return m.UpdatedBy()
	case oauthclient.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthclient.FieldName:
		return m.Name()
	case oauthclient.FieldClientID:
		return m.ClientID()
	case oauthclient.FieldClientSecret:
		return m.ClientSecret()
	case oauthclient.FieldGrantTypes:
		return m.GrantTypes()
	case oauthclient.FieldUserID:
		return m.UserID()
	case oauthclient.FieldLastAuthAt:
		return m.LastAuthAt()
	case oauthclient.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OauthClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthclient.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case oauthclient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthclient.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case oauthclient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthclient.FieldName:
		return m.OldName(ctx)
	case oauthclient.FieldClientID:
		return m.OldClientID(ctx)
	case oauthclient.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case oauthclient.FieldGrantTypes:
		return m.OldGrantTypes(ctx)
	case oauthclient.FieldUserID:
		return m.OldUserID(ctx)
	case oauthclient.FieldLastAuthAt:
		return m.OldLastAuthAt(ctx)
	case oauthclient.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown OauthClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthclient.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case oauthclient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthclient.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case oauthclient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthclient.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oauthclient.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthclient.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case oauthclient.FieldGrantTypes:
		v, ok := value.(oauthclient.GrantTypes)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantTypes(v)
		return nil
	case oauthclient.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case oauthclient.FieldLastAuthAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastAuthAt(v)
		return nil
	case oauthclient.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OauthClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OauthClientMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, oauthclient.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, oauthclient.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OauthClientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthclient.FieldCreatedBy:
		return m.AddedCreatedBy()
	case oauthclient.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthclient.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case oauthclient.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown OauthClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OauthClientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthclient.FieldUpdatedBy) {
		fields = append(fields, oauthclient.FieldUpdatedBy)
	}
	if m.FieldCleared(oauthclient.FieldUpdatedAt) {
		fields = append(fields, oauthclient.FieldUpdatedAt)
	}
	if m.FieldCleared(oauthclient.FieldLastAuthAt) {
		fields = append(fields, oauthclient.FieldLastAuthAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OauthClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OauthClientMutation) ClearField(name string) error {
	switch name {
	case oauthclient.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case oauthclient.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case oauthclient.FieldLastAuthAt:
		m.ClearLastAuthAt()
		return nil
	}
	return fmt.Errorf("unknown OauthClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OauthClientMutation) ResetField(name string) error {
	switch name {
	case oauthclient.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case oauthclient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthclient.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case oauthclient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthclient.FieldName:
		m.ResetName()
		return nil
	case oauthclient.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthclient.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case oauthclient.FieldGrantTypes:
		m.ResetGrantTypes()
		return nil
	case oauthclient.FieldUserID:
		m.ResetUserID()
		return nil
	case oauthclient.FieldLastAuthAt:
		m.ResetLastAuthAt()
		return nil
	case oauthclient.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown OauthClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OauthClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, oauthclient.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OauthClientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthclient.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OauthClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OauthClientMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OauthClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, oauthclient.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OauthClientMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthclient.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OauthClientMutation) ClearEdge(name string) error {
	switch name {
	case oauthclient.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OauthClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OauthClientMutation) ResetEdge(name string) error {
	switch name {
	case oauthclient.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OauthClient edge %s", name)
}

// OrgMutation represents an operation that mutates the Org nodes in the graph.
type OrgMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_by              *int
	addcreated_by           *int
	created_at              *time.Time
	updated_by              *int
	addupdated_by           *int
	updated_at              *time.Time
	deleted_at              *time.Time
	kind                    *org.Kind
	domain                  *string
	code                    *string
	name                    *string
	profile                 *string
	status                  *typex.SimpleStatus
	_path                   *string
	display_sort            *int32
	adddisplay_sort         *int32
	country_code            *string
	timezone                *string
	clearedFields           map[string]struct{}
	parent                  *int
	clearedparent           bool
	children                map[int]struct{}
	removedchildren         map[int]struct{}
	clearedchildren         bool
	owner                   *int
	clearedowner            bool
	users                   map[int]struct{}
	removedusers            map[int]struct{}
	clearedusers            bool
	roles_and_groups        map[int]struct{}
	removedroles_and_groups map[int]struct{}
	clearedroles_and_groups bool
	permissions             map[int]struct{}
	removedpermissions      map[int]struct{}
	clearedpermissions      bool
	policies                map[int]struct{}
	removedpolicies         map[int]struct{}
	clearedpolicies         bool
	apps                    map[int]struct{}
	removedapps             map[int]struct{}
	clearedapps             bool
	org_user                map[int]struct{}
	removedorg_user         map[int]struct{}
	clearedorg_user         bool
	org_app                 map[int]struct{}
	removedorg_app          map[int]struct{}
	clearedorg_app          bool
	done                    bool
	oldValue                func(context.Context) (*Org, error)
	predicates              []predicate.Org
}

var _ ent.Mutation = (*OrgMutation)(nil)

// orgOption allows management of the mutation configuration using functional options.
type orgOption func(*OrgMutation)

// newOrgMutation creates new mutation for the Org entity.
func newOrgMutation(c config, op Op, opts ...orgOption) *OrgMutation {
	m := &OrgMutation{
		config:        c,
		op:            op,
		typ:           TypeOrg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgID sets the ID field of the mutation.
func withOrgID(id int) orgOption {
	return func(m *OrgMutation) {
		var (
			err   error
			once  sync.Once
			value *Org
		)
		m.oldValue = func(ctx context.Context) (*Org, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Org.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrg sets the old Org of the mutation.
func withOrg(node *Org) orgOption {
	return func(m *OrgMutation) {
		m.oldValue = func(context.Context) (*Org, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Org entities.
func (m *OrgMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Org.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrgMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrgMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrgMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrgMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[org.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[org.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, org.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[org.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[org.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, org.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrgMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrgMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrgMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[org.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrgMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[org.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrgMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, org.FieldDeletedAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *OrgMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *OrgMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldOwnerID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *OrgMutation) ClearOwnerID() {
	m.owner = nil
	m.clearedFields[org.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *OrgMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[org.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *OrgMutation) ResetOwnerID() {
	m.owner = nil
	delete(m.clearedFields, org.FieldOwnerID)
}

// SetKind sets the "kind" field.
func (m *OrgMutation) SetKind(o org.Kind) {
	m.kind = &o
}

// Kind returns the value of the "kind" field in the mutation.
func (m *OrgMutation) Kind() (r org.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldKind(ctx context.Context) (v org.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *OrgMutation) ResetKind() {
	m.kind = nil
}

// SetParentID sets the "parent_id" field.
func (m *OrgMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *OrgMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *OrgMutation) ResetParentID() {
	m.parent = nil
}

// SetDomain sets the "domain" field.
func (m *OrgMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *OrgMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *OrgMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[org.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *OrgMutation) DomainCleared() bool {
	_, ok := m.clearedFields[org.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *OrgMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, org.FieldDomain)
}

// SetCode sets the "code" field.
func (m *OrgMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OrgMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *OrgMutation) ClearCode() {
	m.code = nil
	m.clearedFields[org.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *OrgMutation) CodeCleared() bool {
	_, ok := m.clearedFields[org.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *OrgMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, org.FieldCode)
}

// SetName sets the "name" field.
func (m *OrgMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrgMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrgMutation) ResetName() {
	m.name = nil
}

// SetProfile sets the "profile" field.
func (m *OrgMutation) SetProfile(s string) {
	m.profile = &s
}

// Profile returns the value of the "profile" field in the mutation.
func (m *OrgMutation) Profile() (r string, exists bool) {
	v := m.profile
	if v == nil {
		return
	}
	return *v, true
}

// OldProfile returns the old "profile" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldProfile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfile: %w", err)
	}
	return oldValue.Profile, nil
}

// ClearProfile clears the value of the "profile" field.
func (m *OrgMutation) ClearProfile() {
	m.profile = nil
	m.clearedFields[org.FieldProfile] = struct{}{}
}

// ProfileCleared returns if the "profile" field was cleared in this mutation.
func (m *OrgMutation) ProfileCleared() bool {
	_, ok := m.clearedFields[org.FieldProfile]
	return ok
}

// ResetProfile resets all changes to the "profile" field.
func (m *OrgMutation) ResetProfile() {
	m.profile = nil
	delete(m.clearedFields, org.FieldProfile)
}

// SetStatus sets the "status" field.
func (m *OrgMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *OrgMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *OrgMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[org.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrgMutation) StatusCleared() bool {
	_, ok := m.clearedFields[org.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrgMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, org.FieldStatus)
}

// SetPath sets the "path" field.
func (m *OrgMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *OrgMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *OrgMutation) ClearPath() {
	m._path = nil
	m.clearedFields[org.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *OrgMutation) PathCleared() bool {
	_, ok := m.clearedFields[org.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *OrgMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, org.FieldPath)
}

// SetDisplaySort sets the "display_sort" field.
func (m *OrgMutation) SetDisplaySort(i int32) {
	m.display_sort = &i
	m.adddisplay_sort = nil
}

// DisplaySort returns the value of the "display_sort" field in the mutation.
func (m *OrgMutation) DisplaySort() (r int32, exists bool) {
	v := m.display_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplaySort returns the old "display_sort" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldDisplaySort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplaySort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplaySort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplaySort: %w", err)
	}
	return oldValue.DisplaySort, nil
}

// AddDisplaySort adds i to the "display_sort" field.
func (m *OrgMutation) AddDisplaySort(i int32) {
	if m.adddisplay_sort != nil {
		*m.adddisplay_sort += i
	} else {
		m.adddisplay_sort = &i
	}
}

// AddedDisplaySort returns the value that was added to the "display_sort" field in this mutation.
func (m *OrgMutation) AddedDisplaySort() (r int32, exists bool) {
	v := m.adddisplay_sort
	if v == nil {
		return
	}
	return *v, true
}

// ClearDisplaySort clears the value of the "display_sort" field.
func (m *OrgMutation) ClearDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	m.clearedFields[org.FieldDisplaySort] = struct{}{}
}

// DisplaySortCleared returns if the "display_sort" field was cleared in this mutation.
func (m *OrgMutation) DisplaySortCleared() bool {
	_, ok := m.clearedFields[org.FieldDisplaySort]
	return ok
}

// ResetDisplaySort resets all changes to the "display_sort" field.
func (m *OrgMutation) ResetDisplaySort() {
	m.display_sort = nil
	m.adddisplay_sort = nil
	delete(m.clearedFields, org.FieldDisplaySort)
}

// SetCountryCode sets the "country_code" field.
func (m *OrgMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *OrgMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ClearCountryCode clears the value of the "country_code" field.
func (m *OrgMutation) ClearCountryCode() {
	m.country_code = nil
	m.clearedFields[org.FieldCountryCode] = struct{}{}
}

// CountryCodeCleared returns if the "country_code" field was cleared in this mutation.
func (m *OrgMutation) CountryCodeCleared() bool {
	_, ok := m.clearedFields[org.FieldCountryCode]
	return ok
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *OrgMutation) ResetCountryCode() {
	m.country_code = nil
	delete(m.clearedFields, org.FieldCountryCode)
}

// SetTimezone sets the "timezone" field.
func (m *OrgMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OrgMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Org entity.
// If the Org object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *OrgMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[org.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *OrgMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[org.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OrgMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, org.FieldTimezone)
}

// ClearParent clears the "parent" edge to the Org entity.
func (m *OrgMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Org entity was cleared.
func (m *OrgMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OrgMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OrgMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Org entity by ids.
func (m *OrgMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Org entity.
func (m *OrgMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Org entity was cleared.
func (m *OrgMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Org entity by IDs.
func (m *OrgMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Org entity.
func (m *OrgMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *OrgMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *OrgMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *OrgMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *OrgMutation) OwnerCleared() bool {
	return m.OwnerIDCleared() || m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *OrgMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *OrgMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *OrgMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OrgMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OrgMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *OrgMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *OrgMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *OrgMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OrgMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddRolesAndGroupIDs adds the "roles_and_groups" edge to the OrgRole entity by ids.
func (m *OrgMutation) AddRolesAndGroupIDs(ids ...int) {
	if m.roles_and_groups == nil {
		m.roles_and_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.roles_and_groups[ids[i]] = struct{}{}
	}
}

// ClearRolesAndGroups clears the "roles_and_groups" edge to the OrgRole entity.
func (m *OrgMutation) ClearRolesAndGroups() {
	m.clearedroles_and_groups = true
}

// RolesAndGroupsCleared reports if the "roles_and_groups" edge to the OrgRole entity was cleared.
func (m *OrgMutation) RolesAndGroupsCleared() bool {
	return m.clearedroles_and_groups
}

// RemoveRolesAndGroupIDs removes the "roles_and_groups" edge to the OrgRole entity by IDs.
func (m *OrgMutation) RemoveRolesAndGroupIDs(ids ...int) {
	if m.removedroles_and_groups == nil {
		m.removedroles_and_groups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles_and_groups, ids[i])
		m.removedroles_and_groups[ids[i]] = struct{}{}
	}
}

// RemovedRolesAndGroups returns the removed IDs of the "roles_and_groups" edge to the OrgRole entity.
func (m *OrgMutation) RemovedRolesAndGroupsIDs() (ids []int) {
	for id := range m.removedroles_and_groups {
		ids = append(ids, id)
	}
	return
}

// RolesAndGroupsIDs returns the "roles_and_groups" edge IDs in the mutation.
func (m *OrgMutation) RolesAndGroupsIDs() (ids []int) {
	for id := range m.roles_and_groups {
		ids = append(ids, id)
	}
	return
}

// ResetRolesAndGroups resets all changes to the "roles_and_groups" edge.
func (m *OrgMutation) ResetRolesAndGroups() {
	m.roles_and_groups = nil
	m.clearedroles_and_groups = false
	m.removedroles_and_groups = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *OrgMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *OrgMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *OrgMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *OrgMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *OrgMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *OrgMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *OrgMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddPolicyIDs adds the "policies" edge to the OrgPolicy entity by ids.
func (m *OrgMutation) AddPolicyIDs(ids ...int) {
	if m.policies == nil {
		m.policies = make(map[int]struct{})
	}
	for i := range ids {
		m.policies[ids[i]] = struct{}{}
	}
}

// ClearPolicies clears the "policies" edge to the OrgPolicy entity.
func (m *OrgMutation) ClearPolicies() {
	m.clearedpolicies = true
}

// PoliciesCleared reports if the "policies" edge to the OrgPolicy entity was cleared.
func (m *OrgMutation) PoliciesCleared() bool {
	return m.clearedpolicies
}

// RemovePolicyIDs removes the "policies" edge to the OrgPolicy entity by IDs.
func (m *OrgMutation) RemovePolicyIDs(ids ...int) {
	if m.removedpolicies == nil {
		m.removedpolicies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.policies, ids[i])
		m.removedpolicies[ids[i]] = struct{}{}
	}
}

// RemovedPolicies returns the removed IDs of the "policies" edge to the OrgPolicy entity.
func (m *OrgMutation) RemovedPoliciesIDs() (ids []int) {
	for id := range m.removedpolicies {
		ids = append(ids, id)
	}
	return
}

// PoliciesIDs returns the "policies" edge IDs in the mutation.
func (m *OrgMutation) PoliciesIDs() (ids []int) {
	for id := range m.policies {
		ids = append(ids, id)
	}
	return
}

// ResetPolicies resets all changes to the "policies" edge.
func (m *OrgMutation) ResetPolicies() {
	m.policies = nil
	m.clearedpolicies = false
	m.removedpolicies = nil
}

// AddAppIDs adds the "apps" edge to the App entity by ids.
func (m *OrgMutation) AddAppIDs(ids ...int) {
	if m.apps == nil {
		m.apps = make(map[int]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the App entity.
func (m *OrgMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the App entity was cleared.
func (m *OrgMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the App entity by IDs.
func (m *OrgMutation) RemoveAppIDs(ids ...int) {
	if m.removedapps == nil {
		m.removedapps = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the App entity.
func (m *OrgMutation) RemovedAppsIDs() (ids []int) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *OrgMutation) AppsIDs() (ids []int) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *OrgMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// AddOrgUserIDs adds the "org_user" edge to the OrgUser entity by ids.
func (m *OrgMutation) AddOrgUserIDs(ids ...int) {
	if m.org_user == nil {
		m.org_user = make(map[int]struct{})
	}
	for i := range ids {
		m.org_user[ids[i]] = struct{}{}
	}
}

// ClearOrgUser clears the "org_user" edge to the OrgUser entity.
func (m *OrgMutation) ClearOrgUser() {
	m.clearedorg_user = true
}

// OrgUserCleared reports if the "org_user" edge to the OrgUser entity was cleared.
func (m *OrgMutation) OrgUserCleared() bool {
	return m.clearedorg_user
}

// RemoveOrgUserIDs removes the "org_user" edge to the OrgUser entity by IDs.
func (m *OrgMutation) RemoveOrgUserIDs(ids ...int) {
	if m.removedorg_user == nil {
		m.removedorg_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_user, ids[i])
		m.removedorg_user[ids[i]] = struct{}{}
	}
}

// RemovedOrgUser returns the removed IDs of the "org_user" edge to the OrgUser entity.
func (m *OrgMutation) RemovedOrgUserIDs() (ids []int) {
	for id := range m.removedorg_user {
		ids = append(ids, id)
	}
	return
}

// OrgUserIDs returns the "org_user" edge IDs in the mutation.
func (m *OrgMutation) OrgUserIDs() (ids []int) {
	for id := range m.org_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrgUser resets all changes to the "org_user" edge.
func (m *OrgMutation) ResetOrgUser() {
	m.org_user = nil
	m.clearedorg_user = false
	m.removedorg_user = nil
}

// AddOrgAppIDs adds the "org_app" edge to the OrgApp entity by ids.
func (m *OrgMutation) AddOrgAppIDs(ids ...int) {
	if m.org_app == nil {
		m.org_app = make(map[int]struct{})
	}
	for i := range ids {
		m.org_app[ids[i]] = struct{}{}
	}
}

// ClearOrgApp clears the "org_app" edge to the OrgApp entity.
func (m *OrgMutation) ClearOrgApp() {
	m.clearedorg_app = true
}

// OrgAppCleared reports if the "org_app" edge to the OrgApp entity was cleared.
func (m *OrgMutation) OrgAppCleared() bool {
	return m.clearedorg_app
}

// RemoveOrgAppIDs removes the "org_app" edge to the OrgApp entity by IDs.
func (m *OrgMutation) RemoveOrgAppIDs(ids ...int) {
	if m.removedorg_app == nil {
		m.removedorg_app = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_app, ids[i])
		m.removedorg_app[ids[i]] = struct{}{}
	}
}

// RemovedOrgApp returns the removed IDs of the "org_app" edge to the OrgApp entity.
func (m *OrgMutation) RemovedOrgAppIDs() (ids []int) {
	for id := range m.removedorg_app {
		ids = append(ids, id)
	}
	return
}

// OrgAppIDs returns the "org_app" edge IDs in the mutation.
func (m *OrgMutation) OrgAppIDs() (ids []int) {
	for id := range m.org_app {
		ids = append(ids, id)
	}
	return
}

// ResetOrgApp resets all changes to the "org_app" edge.
func (m *OrgMutation) ResetOrgApp() {
	m.org_app = nil
	m.clearedorg_app = false
	m.removedorg_app = nil
}

// Where appends a list predicates to the OrgMutation builder.
func (m *OrgMutation) Where(ps ...predicate.Org) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Org, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Org).
func (m *OrgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_by != nil {
		fields = append(fields, org.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, org.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, org.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, org.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, org.FieldDeletedAt)
	}
	if m.owner != nil {
		fields = append(fields, org.FieldOwnerID)
	}
	if m.kind != nil {
		fields = append(fields, org.FieldKind)
	}
	if m.parent != nil {
		fields = append(fields, org.FieldParentID)
	}
	if m.domain != nil {
		fields = append(fields, org.FieldDomain)
	}
	if m.code != nil {
		fields = append(fields, org.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, org.FieldName)
	}
	if m.profile != nil {
		fields = append(fields, org.FieldProfile)
	}
	if m.status != nil {
		fields = append(fields, org.FieldStatus)
	}
	if m._path != nil {
		fields = append(fields, org.FieldPath)
	}
	if m.display_sort != nil {
		fields = append(fields, org.FieldDisplaySort)
	}
	if m.country_code != nil {
		fields = append(fields, org.FieldCountryCode)
	}
	if m.timezone != nil {
		fields = append(fields, org.FieldTimezone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case org.FieldCreatedBy:
		return m.CreatedBy()
	case org.FieldCreatedAt:
		return m.CreatedAt()
	case org.FieldUpdatedBy:
		return m.UpdatedBy()
	case org.FieldUpdatedAt:
		return m.UpdatedAt()
	case org.FieldDeletedAt:
		return m.DeletedAt()
	case org.FieldOwnerID:
		return m.OwnerID()
	case org.FieldKind:
		return m.Kind()
	case org.FieldParentID:
		return m.ParentID()
	case org.FieldDomain:
		return m.Domain()
	case org.FieldCode:
		return m.Code()
	case org.FieldName:
		return m.Name()
	case org.FieldProfile:
		return m.Profile()
	case org.FieldStatus:
		return m.Status()
	case org.FieldPath:
		return m.Path()
	case org.FieldDisplaySort:
		return m.DisplaySort()
	case org.FieldCountryCode:
		return m.CountryCode()
	case org.FieldTimezone:
		return m.Timezone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case org.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case org.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case org.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case org.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case org.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case org.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case org.FieldKind:
		return m.OldKind(ctx)
	case org.FieldParentID:
		return m.OldParentID(ctx)
	case org.FieldDomain:
		return m.OldDomain(ctx)
	case org.FieldCode:
		return m.OldCode(ctx)
	case org.FieldName:
		return m.OldName(ctx)
	case org.FieldProfile:
		return m.OldProfile(ctx)
	case org.FieldStatus:
		return m.OldStatus(ctx)
	case org.FieldPath:
		return m.OldPath(ctx)
	case org.FieldDisplaySort:
		return m.OldDisplaySort(ctx)
	case org.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case org.FieldTimezone:
		return m.OldTimezone(ctx)
	}
	return nil, fmt.Errorf("unknown Org field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case org.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case org.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case org.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case org.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case org.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case org.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case org.FieldKind:
		v, ok := value.(org.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case org.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case org.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case org.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case org.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case org.FieldProfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfile(v)
		return nil
	case org.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case org.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case org.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplaySort(v)
		return nil
	case org.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case org.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	}
	return fmt.Errorf("unknown Org field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, org.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, org.FieldUpdatedBy)
	}
	if m.adddisplay_sort != nil {
		fields = append(fields, org.FieldDisplaySort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case org.FieldCreatedBy:
		return m.AddedCreatedBy()
	case org.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case org.FieldDisplaySort:
		return m.AddedDisplaySort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgMutation) AddField(name string, value ent.Value) error {
	switch name {
	case org.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case org.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case org.FieldDisplaySort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplaySort(v)
		return nil
	}
	return fmt.Errorf("unknown Org numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(org.FieldUpdatedBy) {
		fields = append(fields, org.FieldUpdatedBy)
	}
	if m.FieldCleared(org.FieldUpdatedAt) {
		fields = append(fields, org.FieldUpdatedAt)
	}
	if m.FieldCleared(org.FieldDeletedAt) {
		fields = append(fields, org.FieldDeletedAt)
	}
	if m.FieldCleared(org.FieldOwnerID) {
		fields = append(fields, org.FieldOwnerID)
	}
	if m.FieldCleared(org.FieldDomain) {
		fields = append(fields, org.FieldDomain)
	}
	if m.FieldCleared(org.FieldCode) {
		fields = append(fields, org.FieldCode)
	}
	if m.FieldCleared(org.FieldProfile) {
		fields = append(fields, org.FieldProfile)
	}
	if m.FieldCleared(org.FieldStatus) {
		fields = append(fields, org.FieldStatus)
	}
	if m.FieldCleared(org.FieldPath) {
		fields = append(fields, org.FieldPath)
	}
	if m.FieldCleared(org.FieldDisplaySort) {
		fields = append(fields, org.FieldDisplaySort)
	}
	if m.FieldCleared(org.FieldCountryCode) {
		fields = append(fields, org.FieldCountryCode)
	}
	if m.FieldCleared(org.FieldTimezone) {
		fields = append(fields, org.FieldTimezone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgMutation) ClearField(name string) error {
	switch name {
	case org.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case org.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case org.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case org.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case org.FieldDomain:
		m.ClearDomain()
		return nil
	case org.FieldCode:
		m.ClearCode()
		return nil
	case org.FieldProfile:
		m.ClearProfile()
		return nil
	case org.FieldStatus:
		m.ClearStatus()
		return nil
	case org.FieldPath:
		m.ClearPath()
		return nil
	case org.FieldDisplaySort:
		m.ClearDisplaySort()
		return nil
	case org.FieldCountryCode:
		m.ClearCountryCode()
		return nil
	case org.FieldTimezone:
		m.ClearTimezone()
		return nil
	}
	return fmt.Errorf("unknown Org nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgMutation) ResetField(name string) error {
	switch name {
	case org.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case org.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case org.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case org.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case org.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case org.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case org.FieldKind:
		m.ResetKind()
		return nil
	case org.FieldParentID:
		m.ResetParentID()
		return nil
	case org.FieldDomain:
		m.ResetDomain()
		return nil
	case org.FieldCode:
		m.ResetCode()
		return nil
	case org.FieldName:
		m.ResetName()
		return nil
	case org.FieldProfile:
		m.ResetProfile()
		return nil
	case org.FieldStatus:
		m.ResetStatus()
		return nil
	case org.FieldPath:
		m.ResetPath()
		return nil
	case org.FieldDisplaySort:
		m.ResetDisplaySort()
		return nil
	case org.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case org.FieldTimezone:
		m.ResetTimezone()
		return nil
	}
	return fmt.Errorf("unknown Org field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.parent != nil {
		edges = append(edges, org.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, org.EdgeChildren)
	}
	if m.owner != nil {
		edges = append(edges, org.EdgeOwner)
	}
	if m.users != nil {
		edges = append(edges, org.EdgeUsers)
	}
	if m.roles_and_groups != nil {
		edges = append(edges, org.EdgeRolesAndGroups)
	}
	if m.permissions != nil {
		edges = append(edges, org.EdgePermissions)
	}
	if m.policies != nil {
		edges = append(edges, org.EdgePolicies)
	}
	if m.apps != nil {
		edges = append(edges, org.EdgeApps)
	}
	if m.org_user != nil {
		edges = append(edges, org.EdgeOrgUser)
	}
	if m.org_app != nil {
		edges = append(edges, org.EdgeOrgApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case org.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case org.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case org.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeRolesAndGroups:
		ids := make([]ent.Value, 0, len(m.roles_and_groups))
		for id := range m.roles_and_groups {
			ids = append(ids, id)
		}
		return ids
	case org.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case org.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.policies))
		for id := range m.policies {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeOrgUser:
		ids := make([]ent.Value, 0, len(m.org_user))
		for id := range m.org_user {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeOrgApp:
		ids := make([]ent.Value, 0, len(m.org_app))
		for id := range m.org_app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedchildren != nil {
		edges = append(edges, org.EdgeChildren)
	}
	if m.removedusers != nil {
		edges = append(edges, org.EdgeUsers)
	}
	if m.removedroles_and_groups != nil {
		edges = append(edges, org.EdgeRolesAndGroups)
	}
	if m.removedpermissions != nil {
		edges = append(edges, org.EdgePermissions)
	}
	if m.removedpolicies != nil {
		edges = append(edges, org.EdgePolicies)
	}
	if m.removedapps != nil {
		edges = append(edges, org.EdgeApps)
	}
	if m.removedorg_user != nil {
		edges = append(edges, org.EdgeOrgUser)
	}
	if m.removedorg_app != nil {
		edges = append(edges, org.EdgeOrgApp)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case org.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeRolesAndGroups:
		ids := make([]ent.Value, 0, len(m.removedroles_and_groups))
		for id := range m.removedroles_and_groups {
			ids = append(ids, id)
		}
		return ids
	case org.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case org.EdgePolicies:
		ids := make([]ent.Value, 0, len(m.removedpolicies))
		for id := range m.removedpolicies {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeOrgUser:
		ids := make([]ent.Value, 0, len(m.removedorg_user))
		for id := range m.removedorg_user {
			ids = append(ids, id)
		}
		return ids
	case org.EdgeOrgApp:
		ids := make([]ent.Value, 0, len(m.removedorg_app))
		for id := range m.removedorg_app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedparent {
		edges = append(edges, org.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, org.EdgeChildren)
	}
	if m.clearedowner {
		edges = append(edges, org.EdgeOwner)
	}
	if m.clearedusers {
		edges = append(edges, org.EdgeUsers)
	}
	if m.clearedroles_and_groups {
		edges = append(edges, org.EdgeRolesAndGroups)
	}
	if m.clearedpermissions {
		edges = append(edges, org.EdgePermissions)
	}
	if m.clearedpolicies {
		edges = append(edges, org.EdgePolicies)
	}
	if m.clearedapps {
		edges = append(edges, org.EdgeApps)
	}
	if m.clearedorg_user {
		edges = append(edges, org.EdgeOrgUser)
	}
	if m.clearedorg_app {
		edges = append(edges, org.EdgeOrgApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgMutation) EdgeCleared(name string) bool {
	switch name {
	case org.EdgeParent:
		return m.clearedparent
	case org.EdgeChildren:
		return m.clearedchildren
	case org.EdgeOwner:
		return m.clearedowner
	case org.EdgeUsers:
		return m.clearedusers
	case org.EdgeRolesAndGroups:
		return m.clearedroles_and_groups
	case org.EdgePermissions:
		return m.clearedpermissions
	case org.EdgePolicies:
		return m.clearedpolicies
	case org.EdgeApps:
		return m.clearedapps
	case org.EdgeOrgUser:
		return m.clearedorg_user
	case org.EdgeOrgApp:
		return m.clearedorg_app
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgMutation) ClearEdge(name string) error {
	switch name {
	case org.EdgeParent:
		m.ClearParent()
		return nil
	case org.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Org unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgMutation) ResetEdge(name string) error {
	switch name {
	case org.EdgeParent:
		m.ResetParent()
		return nil
	case org.EdgeChildren:
		m.ResetChildren()
		return nil
	case org.EdgeOwner:
		m.ResetOwner()
		return nil
	case org.EdgeUsers:
		m.ResetUsers()
		return nil
	case org.EdgeRolesAndGroups:
		m.ResetRolesAndGroups()
		return nil
	case org.EdgePermissions:
		m.ResetPermissions()
		return nil
	case org.EdgePolicies:
		m.ResetPolicies()
		return nil
	case org.EdgeApps:
		m.ResetApps()
		return nil
	case org.EdgeOrgUser:
		m.ResetOrgUser()
		return nil
	case org.EdgeOrgApp:
		m.ResetOrgApp()
		return nil
	}
	return fmt.Errorf("unknown Org edge %s", name)
}

// OrgAppMutation represents an operation that mutates the OrgApp nodes in the graph.
type OrgAppMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	clearedFields map[string]struct{}
	app           *int
	clearedapp    bool
	org           *int
	clearedorg    bool
	done          bool
	oldValue      func(context.Context) (*OrgApp, error)
	predicates    []predicate.OrgApp
}

var _ ent.Mutation = (*OrgAppMutation)(nil)

// orgappOption allows management of the mutation configuration using functional options.
type orgappOption func(*OrgAppMutation)

// newOrgAppMutation creates new mutation for the OrgApp entity.
func newOrgAppMutation(c config, op Op, opts ...orgappOption) *OrgAppMutation {
	m := &OrgAppMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgAppID sets the ID field of the mutation.
func withOrgAppID(id int) orgappOption {
	return func(m *OrgAppMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgApp
		)
		m.oldValue = func(ctx context.Context) (*OrgApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgApp sets the old OrgApp of the mutation.
func withOrgApp(node *OrgApp) orgappOption {
	return func(m *OrgAppMutation) {
		m.oldValue = func(context.Context) (*OrgApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgApp entities.
func (m *OrgAppMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgAppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgAppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgAppMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgAppMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgApp entity.
// If the OrgApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgAppMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrgAppMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrgAppMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgAppMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgAppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgAppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgApp entity.
// If the OrgApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgAppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgAppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgAppMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgAppMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgApp entity.
// If the OrgApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgAppMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrgAppMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrgAppMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgAppMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[orgapp.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgAppMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orgapp.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgAppMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, orgapp.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgAppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgAppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgApp entity.
// If the OrgApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgAppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgAppMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orgapp.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgAppMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orgapp.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgAppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orgapp.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *OrgAppMutation) SetOrgID(i int) {
	m.org = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrgAppMutation) OrgID() (r int, exists bool) {
	v := m.org
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrgApp entity.
// If the OrgApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgAppMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrgAppMutation) ResetOrgID() {
	m.org = nil
}

// SetAppID sets the "app_id" field.
func (m *OrgAppMutation) SetAppID(i int) {
	m.app = &i
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *OrgAppMutation) AppID() (r int, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the OrgApp entity.
// If the OrgApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgAppMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *OrgAppMutation) ResetAppID() {
	m.app = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *OrgAppMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *OrgAppMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *OrgAppMutation) AppIDs() (ids []int) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *OrgAppMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// ClearOrg clears the "org" edge to the Org entity.
func (m *OrgAppMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the Org entity was cleared.
func (m *OrgAppMutation) OrgCleared() bool {
	return m.clearedorg
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *OrgAppMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *OrgAppMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// Where appends a list predicates to the OrgAppMutation builder.
func (m *OrgAppMutation) Where(ps ...predicate.OrgApp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgAppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgAppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgApp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgAppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgAppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgApp).
func (m *OrgAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgAppMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_by != nil {
		fields = append(fields, orgapp.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, orgapp.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, orgapp.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, orgapp.FieldUpdatedAt)
	}
	if m.org != nil {
		fields = append(fields, orgapp.FieldOrgID)
	}
	if m.app != nil {
		fields = append(fields, orgapp.FieldAppID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgapp.FieldCreatedBy:
		return m.CreatedBy()
	case orgapp.FieldCreatedAt:
		return m.CreatedAt()
	case orgapp.FieldUpdatedBy:
		return m.UpdatedBy()
	case orgapp.FieldUpdatedAt:
		return m.UpdatedAt()
	case orgapp.FieldOrgID:
		return m.OrgID()
	case orgapp.FieldAppID:
		return m.AppID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgapp.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orgapp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orgapp.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orgapp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orgapp.FieldOrgID:
		return m.OldOrgID(ctx)
	case orgapp.FieldAppID:
		return m.OldAppID(ctx)
	}
	return nil, fmt.Errorf("unknown OrgApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgapp.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orgapp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orgapp.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orgapp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orgapp.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case orgapp.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgAppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, orgapp.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, orgapp.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgAppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orgapp.FieldCreatedBy:
		return m.AddedCreatedBy()
	case orgapp.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orgapp.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case orgapp.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown OrgApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgAppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgapp.FieldUpdatedBy) {
		fields = append(fields, orgapp.FieldUpdatedBy)
	}
	if m.FieldCleared(orgapp.FieldUpdatedAt) {
		fields = append(fields, orgapp.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgAppMutation) ClearField(name string) error {
	switch name {
	case orgapp.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case orgapp.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrgApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgAppMutation) ResetField(name string) error {
	switch name {
	case orgapp.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orgapp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orgapp.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orgapp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orgapp.FieldOrgID:
		m.ResetOrgID()
		return nil
	case orgapp.FieldAppID:
		m.ResetAppID()
		return nil
	}
	return fmt.Errorf("unknown OrgApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, orgapp.EdgeApp)
	}
	if m.org != nil {
		edges = append(edges, orgapp.EdgeOrg)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgAppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgapp.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case orgapp.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgAppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, orgapp.EdgeApp)
	}
	if m.clearedorg {
		edges = append(edges, orgapp.EdgeOrg)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgAppMutation) EdgeCleared(name string) bool {
	switch name {
	case orgapp.EdgeApp:
		return m.clearedapp
	case orgapp.EdgeOrg:
		return m.clearedorg
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgAppMutation) ClearEdge(name string) error {
	switch name {
	case orgapp.EdgeApp:
		m.ClearApp()
		return nil
	case orgapp.EdgeOrg:
		m.ClearOrg()
		return nil
	}
	return fmt.Errorf("unknown OrgApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgAppMutation) ResetEdge(name string) error {
	switch name {
	case orgapp.EdgeApp:
		m.ResetApp()
		return nil
	case orgapp.EdgeOrg:
		m.ResetOrg()
		return nil
	}
	return fmt.Errorf("unknown OrgApp edge %s", name)
}

// OrgPolicyMutation represents an operation that mutates the OrgPolicy nodes in the graph.
type OrgPolicyMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_by         *int
	addcreated_by      *int
	created_at         *time.Time
	updated_by         *int
	addupdated_by      *int
	updated_at         *time.Time
	app_id             *int
	addapp_id          *int
	app_policy_id      *int
	addapp_policy_id   *int
	name               *string
	comments           *string
	rules              *[]*types.PolicyRule
	appendrules        []*types.PolicyRule
	clearedFields      map[string]struct{}
	org                *int
	clearedorg         bool
	permissions        map[int]struct{}
	removedpermissions map[int]struct{}
	clearedpermissions bool
	done               bool
	oldValue           func(context.Context) (*OrgPolicy, error)
	predicates         []predicate.OrgPolicy
}

var _ ent.Mutation = (*OrgPolicyMutation)(nil)

// orgpolicyOption allows management of the mutation configuration using functional options.
type orgpolicyOption func(*OrgPolicyMutation)

// newOrgPolicyMutation creates new mutation for the OrgPolicy entity.
func newOrgPolicyMutation(c config, op Op, opts ...orgpolicyOption) *OrgPolicyMutation {
	m := &OrgPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgPolicyID sets the ID field of the mutation.
func withOrgPolicyID(id int) orgpolicyOption {
	return func(m *OrgPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgPolicy
		)
		m.oldValue = func(ctx context.Context) (*OrgPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgPolicy sets the old OrgPolicy of the mutation.
func withOrgPolicy(node *OrgPolicy) orgpolicyOption {
	return func(m *OrgPolicyMutation) {
		m.oldValue = func(context.Context) (*OrgPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgPolicy entities.
func (m *OrgPolicyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgPolicyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgPolicyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgPolicyMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgPolicyMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgPolicy entity.
// If the OrgPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgPolicyMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrgPolicyMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrgPolicyMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgPolicyMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgPolicy entity.
// If the OrgPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgPolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgPolicyMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgPolicyMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgPolicy entity.
// If the OrgPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgPolicyMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrgPolicyMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrgPolicyMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgPolicyMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[orgpolicy.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgPolicyMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orgpolicy.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgPolicyMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, orgpolicy.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgPolicy entity.
// If the OrgPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgPolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgPolicyMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orgpolicy.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgPolicyMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orgpolicy.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orgpolicy.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *OrgPolicyMutation) SetOrgID(i int) {
	m.org = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrgPolicyMutation) OrgID() (r int, exists bool) {
	v := m.org
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrgPolicy entity.
// If the OrgPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgPolicyMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ClearOrgID clears the value of the "org_id" field.
func (m *OrgPolicyMutation) ClearOrgID() {
	m.org = nil
	m.clearedFields[orgpolicy.FieldOrgID] = struct{}{}
}

// OrgIDCleared returns if the "org_id" field was cleared in this mutation.
func (m *OrgPolicyMutation) OrgIDCleared() bool {
	_, ok := m.clearedFields[orgpolicy.FieldOrgID]
	return ok
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrgPolicyMutation) ResetOrgID() {
	m.org = nil
	delete(m.clearedFields, orgpolicy.FieldOrgID)
}

// SetAppID sets the "app_id" field.
func (m *OrgPolicyMutation) SetAppID(i int) {
	m.app_id = &i
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *OrgPolicyMutation) AppID() (r int, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the OrgPolicy entity.
// If the OrgPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgPolicyMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds i to the "app_id" field.
func (m *OrgPolicyMutation) AddAppID(i int) {
	if m.addapp_id != nil {
		*m.addapp_id += i
	} else {
		m.addapp_id = &i
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *OrgPolicyMutation) AddedAppID() (r int, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppID clears the value of the "app_id" field.
func (m *OrgPolicyMutation) ClearAppID() {
	m.app_id = nil
	m.addapp_id = nil
	m.clearedFields[orgpolicy.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *OrgPolicyMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[orgpolicy.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *OrgPolicyMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
	delete(m.clearedFields, orgpolicy.FieldAppID)
}

// SetAppPolicyID sets the "app_policy_id" field.
func (m *OrgPolicyMutation) SetAppPolicyID(i int) {
	m.app_policy_id = &i
	m.addapp_policy_id = nil
}

// AppPolicyID returns the value of the "app_policy_id" field in the mutation.
func (m *OrgPolicyMutation) AppPolicyID() (r int, exists bool) {
	v := m.app_policy_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppPolicyID returns the old "app_policy_id" field's value of the OrgPolicy entity.
// If the OrgPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgPolicyMutation) OldAppPolicyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppPolicyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppPolicyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppPolicyID: %w", err)
	}
	return oldValue.AppPolicyID, nil
}

// AddAppPolicyID adds i to the "app_policy_id" field.
func (m *OrgPolicyMutation) AddAppPolicyID(i int) {
	if m.addapp_policy_id != nil {
		*m.addapp_policy_id += i
	} else {
		m.addapp_policy_id = &i
	}
}

// AddedAppPolicyID returns the value that was added to the "app_policy_id" field in this mutation.
func (m *OrgPolicyMutation) AddedAppPolicyID() (r int, exists bool) {
	v := m.addapp_policy_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppPolicyID clears the value of the "app_policy_id" field.
func (m *OrgPolicyMutation) ClearAppPolicyID() {
	m.app_policy_id = nil
	m.addapp_policy_id = nil
	m.clearedFields[orgpolicy.FieldAppPolicyID] = struct{}{}
}

// AppPolicyIDCleared returns if the "app_policy_id" field was cleared in this mutation.
func (m *OrgPolicyMutation) AppPolicyIDCleared() bool {
	_, ok := m.clearedFields[orgpolicy.FieldAppPolicyID]
	return ok
}

// ResetAppPolicyID resets all changes to the "app_policy_id" field.
func (m *OrgPolicyMutation) ResetAppPolicyID() {
	m.app_policy_id = nil
	m.addapp_policy_id = nil
	delete(m.clearedFields, orgpolicy.FieldAppPolicyID)
}

// SetName sets the "name" field.
func (m *OrgPolicyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrgPolicyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrgPolicy entity.
// If the OrgPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgPolicyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrgPolicyMutation) ResetName() {
	m.name = nil
}

// SetComments sets the "comments" field.
func (m *OrgPolicyMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *OrgPolicyMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the OrgPolicy entity.
// If the OrgPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgPolicyMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *OrgPolicyMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[orgpolicy.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *OrgPolicyMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[orgpolicy.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *OrgPolicyMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, orgpolicy.FieldComments)
}

// SetRules sets the "rules" field.
func (m *OrgPolicyMutation) SetRules(tr []*types.PolicyRule) {
	m.rules = &tr
	m.appendrules = nil
}

// Rules returns the value of the "rules" field in the mutation.
func (m *OrgPolicyMutation) Rules() (r []*types.PolicyRule, exists bool) {
	v := m.rules
	if v == nil {
		return
	}
	return *v, true
}

// OldRules returns the old "rules" field's value of the OrgPolicy entity.
// If the OrgPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgPolicyMutation) OldRules(ctx context.Context) (v []*types.PolicyRule, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRules: %w", err)
	}
	return oldValue.Rules, nil
}

// AppendRules adds tr to the "rules" field.
func (m *OrgPolicyMutation) AppendRules(tr []*types.PolicyRule) {
	m.appendrules = append(m.appendrules, tr...)
}

// AppendedRules returns the list of values that were appended to the "rules" field in this mutation.
func (m *OrgPolicyMutation) AppendedRules() ([]*types.PolicyRule, bool) {
	if len(m.appendrules) == 0 {
		return nil, false
	}
	return m.appendrules, true
}

// ResetRules resets all changes to the "rules" field.
func (m *OrgPolicyMutation) ResetRules() {
	m.rules = nil
	m.appendrules = nil
}

// ClearOrg clears the "org" edge to the Org entity.
func (m *OrgPolicyMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the Org entity was cleared.
func (m *OrgPolicyMutation) OrgCleared() bool {
	return m.OrgIDCleared() || m.clearedorg
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *OrgPolicyMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *OrgPolicyMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *OrgPolicyMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *OrgPolicyMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *OrgPolicyMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *OrgPolicyMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *OrgPolicyMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *OrgPolicyMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *OrgPolicyMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the OrgPolicyMutation builder.
func (m *OrgPolicyMutation) Where(ps ...predicate.OrgPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgPolicy).
func (m *OrgPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgPolicyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_by != nil {
		fields = append(fields, orgpolicy.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, orgpolicy.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, orgpolicy.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, orgpolicy.FieldUpdatedAt)
	}
	if m.org != nil {
		fields = append(fields, orgpolicy.FieldOrgID)
	}
	if m.app_id != nil {
		fields = append(fields, orgpolicy.FieldAppID)
	}
	if m.app_policy_id != nil {
		fields = append(fields, orgpolicy.FieldAppPolicyID)
	}
	if m.name != nil {
		fields = append(fields, orgpolicy.FieldName)
	}
	if m.comments != nil {
		fields = append(fields, orgpolicy.FieldComments)
	}
	if m.rules != nil {
		fields = append(fields, orgpolicy.FieldRules)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgpolicy.FieldCreatedBy:
		return m.CreatedBy()
	case orgpolicy.FieldCreatedAt:
		return m.CreatedAt()
	case orgpolicy.FieldUpdatedBy:
		return m.UpdatedBy()
	case orgpolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case orgpolicy.FieldOrgID:
		return m.OrgID()
	case orgpolicy.FieldAppID:
		return m.AppID()
	case orgpolicy.FieldAppPolicyID:
		return m.AppPolicyID()
	case orgpolicy.FieldName:
		return m.Name()
	case orgpolicy.FieldComments:
		return m.Comments()
	case orgpolicy.FieldRules:
		return m.Rules()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgpolicy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orgpolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orgpolicy.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orgpolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orgpolicy.FieldOrgID:
		return m.OldOrgID(ctx)
	case orgpolicy.FieldAppID:
		return m.OldAppID(ctx)
	case orgpolicy.FieldAppPolicyID:
		return m.OldAppPolicyID(ctx)
	case orgpolicy.FieldName:
		return m.OldName(ctx)
	case orgpolicy.FieldComments:
		return m.OldComments(ctx)
	case orgpolicy.FieldRules:
		return m.OldRules(ctx)
	}
	return nil, fmt.Errorf("unknown OrgPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgpolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orgpolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orgpolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orgpolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orgpolicy.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case orgpolicy.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case orgpolicy.FieldAppPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppPolicyID(v)
		return nil
	case orgpolicy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orgpolicy.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case orgpolicy.FieldRules:
		v, ok := value.([]*types.PolicyRule)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRules(v)
		return nil
	}
	return fmt.Errorf("unknown OrgPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgPolicyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, orgpolicy.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, orgpolicy.FieldUpdatedBy)
	}
	if m.addapp_id != nil {
		fields = append(fields, orgpolicy.FieldAppID)
	}
	if m.addapp_policy_id != nil {
		fields = append(fields, orgpolicy.FieldAppPolicyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgPolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orgpolicy.FieldCreatedBy:
		return m.AddedCreatedBy()
	case orgpolicy.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case orgpolicy.FieldAppID:
		return m.AddedAppID()
	case orgpolicy.FieldAppPolicyID:
		return m.AddedAppPolicyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orgpolicy.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case orgpolicy.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case orgpolicy.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	case orgpolicy.FieldAppPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppPolicyID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgpolicy.FieldUpdatedBy) {
		fields = append(fields, orgpolicy.FieldUpdatedBy)
	}
	if m.FieldCleared(orgpolicy.FieldUpdatedAt) {
		fields = append(fields, orgpolicy.FieldUpdatedAt)
	}
	if m.FieldCleared(orgpolicy.FieldOrgID) {
		fields = append(fields, orgpolicy.FieldOrgID)
	}
	if m.FieldCleared(orgpolicy.FieldAppID) {
		fields = append(fields, orgpolicy.FieldAppID)
	}
	if m.FieldCleared(orgpolicy.FieldAppPolicyID) {
		fields = append(fields, orgpolicy.FieldAppPolicyID)
	}
	if m.FieldCleared(orgpolicy.FieldComments) {
		fields = append(fields, orgpolicy.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgPolicyMutation) ClearField(name string) error {
	switch name {
	case orgpolicy.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case orgpolicy.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orgpolicy.FieldOrgID:
		m.ClearOrgID()
		return nil
	case orgpolicy.FieldAppID:
		m.ClearAppID()
		return nil
	case orgpolicy.FieldAppPolicyID:
		m.ClearAppPolicyID()
		return nil
	case orgpolicy.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown OrgPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgPolicyMutation) ResetField(name string) error {
	switch name {
	case orgpolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orgpolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orgpolicy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orgpolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orgpolicy.FieldOrgID:
		m.ResetOrgID()
		return nil
	case orgpolicy.FieldAppID:
		m.ResetAppID()
		return nil
	case orgpolicy.FieldAppPolicyID:
		m.ResetAppPolicyID()
		return nil
	case orgpolicy.FieldName:
		m.ResetName()
		return nil
	case orgpolicy.FieldComments:
		m.ResetComments()
		return nil
	case orgpolicy.FieldRules:
		m.ResetRules()
		return nil
	}
	return fmt.Errorf("unknown OrgPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.org != nil {
		edges = append(edges, orgpolicy.EdgeOrg)
	}
	if m.permissions != nil {
		edges = append(edges, orgpolicy.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgPolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgpolicy.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	case orgpolicy.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpermissions != nil {
		edges = append(edges, orgpolicy.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgPolicyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orgpolicy.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorg {
		edges = append(edges, orgpolicy.EdgeOrg)
	}
	if m.clearedpermissions {
		edges = append(edges, orgpolicy.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgPolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case orgpolicy.EdgeOrg:
		return m.clearedorg
	case orgpolicy.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgPolicyMutation) ClearEdge(name string) error {
	switch name {
	case orgpolicy.EdgeOrg:
		m.ClearOrg()
		return nil
	}
	return fmt.Errorf("unknown OrgPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgPolicyMutation) ResetEdge(name string) error {
	switch name {
	case orgpolicy.EdgeOrg:
		m.ResetOrg()
		return nil
	case orgpolicy.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown OrgPolicy edge %s", name)
}

// OrgRoleMutation represents an operation that mutates the OrgRole nodes in the graph.
type OrgRoleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_by           *int
	addcreated_by        *int
	created_at           *time.Time
	updated_by           *int
	addupdated_by        *int
	updated_at           *time.Time
	kind                 *orgrole.Kind
	name                 *string
	app_role_id          *int
	addapp_role_id       *int
	comments             *string
	clearedFields        map[string]struct{}
	org                  *int
	clearedorg           bool
	org_users            map[int]struct{}
	removedorg_users     map[int]struct{}
	clearedorg_users     bool
	org_role_user        map[int]struct{}
	removedorg_role_user map[int]struct{}
	clearedorg_role_user bool
	done                 bool
	oldValue             func(context.Context) (*OrgRole, error)
	predicates           []predicate.OrgRole
}

var _ ent.Mutation = (*OrgRoleMutation)(nil)

// orgroleOption allows management of the mutation configuration using functional options.
type orgroleOption func(*OrgRoleMutation)

// newOrgRoleMutation creates new mutation for the OrgRole entity.
func newOrgRoleMutation(c config, op Op, opts ...orgroleOption) *OrgRoleMutation {
	m := &OrgRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgRoleID sets the ID field of the mutation.
func withOrgRoleID(id int) orgroleOption {
	return func(m *OrgRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgRole
		)
		m.oldValue = func(ctx context.Context) (*OrgRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgRole sets the old OrgRole of the mutation.
func withOrgRole(node *OrgRole) orgroleOption {
	return func(m *OrgRoleMutation) {
		m.oldValue = func(context.Context) (*OrgRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgRole entities.
func (m *OrgRoleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgRoleMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgRoleMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrgRoleMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrgRoleMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgRoleMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgRoleMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrgRoleMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrgRoleMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgRoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[orgrole.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orgrole.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, orgrole.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orgrole.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orgrole.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orgrole.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *OrgRoleMutation) SetOrgID(i int) {
	m.org = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrgRoleMutation) OrgID() (r int, exists bool) {
	v := m.org
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ClearOrgID clears the value of the "org_id" field.
func (m *OrgRoleMutation) ClearOrgID() {
	m.org = nil
	m.clearedFields[orgrole.FieldOrgID] = struct{}{}
}

// OrgIDCleared returns if the "org_id" field was cleared in this mutation.
func (m *OrgRoleMutation) OrgIDCleared() bool {
	_, ok := m.clearedFields[orgrole.FieldOrgID]
	return ok
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrgRoleMutation) ResetOrgID() {
	m.org = nil
	delete(m.clearedFields, orgrole.FieldOrgID)
}

// SetKind sets the "kind" field.
func (m *OrgRoleMutation) SetKind(o orgrole.Kind) {
	m.kind = &o
}

// Kind returns the value of the "kind" field in the mutation.
func (m *OrgRoleMutation) Kind() (r orgrole.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldKind(ctx context.Context) (v orgrole.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *OrgRoleMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *OrgRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrgRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrgRoleMutation) ResetName() {
	m.name = nil
}

// SetAppRoleID sets the "app_role_id" field.
func (m *OrgRoleMutation) SetAppRoleID(i int) {
	m.app_role_id = &i
	m.addapp_role_id = nil
}

// AppRoleID returns the value of the "app_role_id" field in the mutation.
func (m *OrgRoleMutation) AppRoleID() (r int, exists bool) {
	v := m.app_role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppRoleID returns the old "app_role_id" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldAppRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppRoleID: %w", err)
	}
	return oldValue.AppRoleID, nil
}

// AddAppRoleID adds i to the "app_role_id" field.
func (m *OrgRoleMutation) AddAppRoleID(i int) {
	if m.addapp_role_id != nil {
		*m.addapp_role_id += i
	} else {
		m.addapp_role_id = &i
	}
}

// AddedAppRoleID returns the value that was added to the "app_role_id" field in this mutation.
func (m *OrgRoleMutation) AddedAppRoleID() (r int, exists bool) {
	v := m.addapp_role_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAppRoleID clears the value of the "app_role_id" field.
func (m *OrgRoleMutation) ClearAppRoleID() {
	m.app_role_id = nil
	m.addapp_role_id = nil
	m.clearedFields[orgrole.FieldAppRoleID] = struct{}{}
}

// AppRoleIDCleared returns if the "app_role_id" field was cleared in this mutation.
func (m *OrgRoleMutation) AppRoleIDCleared() bool {
	_, ok := m.clearedFields[orgrole.FieldAppRoleID]
	return ok
}

// ResetAppRoleID resets all changes to the "app_role_id" field.
func (m *OrgRoleMutation) ResetAppRoleID() {
	m.app_role_id = nil
	m.addapp_role_id = nil
	delete(m.clearedFields, orgrole.FieldAppRoleID)
}

// SetComments sets the "comments" field.
func (m *OrgRoleMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *OrgRoleMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *OrgRoleMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[orgrole.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *OrgRoleMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[orgrole.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *OrgRoleMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, orgrole.FieldComments)
}

// ClearOrg clears the "org" edge to the Org entity.
func (m *OrgRoleMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the Org entity was cleared.
func (m *OrgRoleMutation) OrgCleared() bool {
	return m.OrgIDCleared() || m.clearedorg
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *OrgRoleMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *OrgRoleMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// AddOrgUserIDs adds the "org_users" edge to the OrgUser entity by ids.
func (m *OrgRoleMutation) AddOrgUserIDs(ids ...int) {
	if m.org_users == nil {
		m.org_users = make(map[int]struct{})
	}
	for i := range ids {
		m.org_users[ids[i]] = struct{}{}
	}
}

// ClearOrgUsers clears the "org_users" edge to the OrgUser entity.
func (m *OrgRoleMutation) ClearOrgUsers() {
	m.clearedorg_users = true
}

// OrgUsersCleared reports if the "org_users" edge to the OrgUser entity was cleared.
func (m *OrgRoleMutation) OrgUsersCleared() bool {
	return m.clearedorg_users
}

// RemoveOrgUserIDs removes the "org_users" edge to the OrgUser entity by IDs.
func (m *OrgRoleMutation) RemoveOrgUserIDs(ids ...int) {
	if m.removedorg_users == nil {
		m.removedorg_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_users, ids[i])
		m.removedorg_users[ids[i]] = struct{}{}
	}
}

// RemovedOrgUsers returns the removed IDs of the "org_users" edge to the OrgUser entity.
func (m *OrgRoleMutation) RemovedOrgUsersIDs() (ids []int) {
	for id := range m.removedorg_users {
		ids = append(ids, id)
	}
	return
}

// OrgUsersIDs returns the "org_users" edge IDs in the mutation.
func (m *OrgRoleMutation) OrgUsersIDs() (ids []int) {
	for id := range m.org_users {
		ids = append(ids, id)
	}
	return
}

// ResetOrgUsers resets all changes to the "org_users" edge.
func (m *OrgRoleMutation) ResetOrgUsers() {
	m.org_users = nil
	m.clearedorg_users = false
	m.removedorg_users = nil
}

// AddOrgRoleUserIDs adds the "org_role_user" edge to the OrgRoleUser entity by ids.
func (m *OrgRoleMutation) AddOrgRoleUserIDs(ids ...int) {
	if m.org_role_user == nil {
		m.org_role_user = make(map[int]struct{})
	}
	for i := range ids {
		m.org_role_user[ids[i]] = struct{}{}
	}
}

// ClearOrgRoleUser clears the "org_role_user" edge to the OrgRoleUser entity.
func (m *OrgRoleMutation) ClearOrgRoleUser() {
	m.clearedorg_role_user = true
}

// OrgRoleUserCleared reports if the "org_role_user" edge to the OrgRoleUser entity was cleared.
func (m *OrgRoleMutation) OrgRoleUserCleared() bool {
	return m.clearedorg_role_user
}

// RemoveOrgRoleUserIDs removes the "org_role_user" edge to the OrgRoleUser entity by IDs.
func (m *OrgRoleMutation) RemoveOrgRoleUserIDs(ids ...int) {
	if m.removedorg_role_user == nil {
		m.removedorg_role_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_role_user, ids[i])
		m.removedorg_role_user[ids[i]] = struct{}{}
	}
}

// RemovedOrgRoleUser returns the removed IDs of the "org_role_user" edge to the OrgRoleUser entity.
func (m *OrgRoleMutation) RemovedOrgRoleUserIDs() (ids []int) {
	for id := range m.removedorg_role_user {
		ids = append(ids, id)
	}
	return
}

// OrgRoleUserIDs returns the "org_role_user" edge IDs in the mutation.
func (m *OrgRoleMutation) OrgRoleUserIDs() (ids []int) {
	for id := range m.org_role_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrgRoleUser resets all changes to the "org_role_user" edge.
func (m *OrgRoleMutation) ResetOrgRoleUser() {
	m.org_role_user = nil
	m.clearedorg_role_user = false
	m.removedorg_role_user = nil
}

// Where appends a list predicates to the OrgRoleMutation builder.
func (m *OrgRoleMutation) Where(ps ...predicate.OrgRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgRole).
func (m *OrgRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgRoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, orgrole.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, orgrole.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, orgrole.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, orgrole.FieldUpdatedAt)
	}
	if m.org != nil {
		fields = append(fields, orgrole.FieldOrgID)
	}
	if m.kind != nil {
		fields = append(fields, orgrole.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, orgrole.FieldName)
	}
	if m.app_role_id != nil {
		fields = append(fields, orgrole.FieldAppRoleID)
	}
	if m.comments != nil {
		fields = append(fields, orgrole.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgrole.FieldCreatedBy:
		return m.CreatedBy()
	case orgrole.FieldCreatedAt:
		return m.CreatedAt()
	case orgrole.FieldUpdatedBy:
		return m.UpdatedBy()
	case orgrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case orgrole.FieldOrgID:
		return m.OrgID()
	case orgrole.FieldKind:
		return m.Kind()
	case orgrole.FieldName:
		return m.Name()
	case orgrole.FieldAppRoleID:
		return m.AppRoleID()
	case orgrole.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgrole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orgrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orgrole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orgrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orgrole.FieldOrgID:
		return m.OldOrgID(ctx)
	case orgrole.FieldKind:
		return m.OldKind(ctx)
	case orgrole.FieldName:
		return m.OldName(ctx)
	case orgrole.FieldAppRoleID:
		return m.OldAppRoleID(ctx)
	case orgrole.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown OrgRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgrole.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orgrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orgrole.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orgrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orgrole.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case orgrole.FieldKind:
		v, ok := value.(orgrole.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case orgrole.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orgrole.FieldAppRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppRoleID(v)
		return nil
	case orgrole.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown OrgRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, orgrole.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, orgrole.FieldUpdatedBy)
	}
	if m.addapp_role_id != nil {
		fields = append(fields, orgrole.FieldAppRoleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orgrole.FieldCreatedBy:
		return m.AddedCreatedBy()
	case orgrole.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case orgrole.FieldAppRoleID:
		return m.AddedAppRoleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orgrole.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case orgrole.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case orgrole.FieldAppRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgrole.FieldUpdatedBy) {
		fields = append(fields, orgrole.FieldUpdatedBy)
	}
	if m.FieldCleared(orgrole.FieldUpdatedAt) {
		fields = append(fields, orgrole.FieldUpdatedAt)
	}
	if m.FieldCleared(orgrole.FieldOrgID) {
		fields = append(fields, orgrole.FieldOrgID)
	}
	if m.FieldCleared(orgrole.FieldAppRoleID) {
		fields = append(fields, orgrole.FieldAppRoleID)
	}
	if m.FieldCleared(orgrole.FieldComments) {
		fields = append(fields, orgrole.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgRoleMutation) ClearField(name string) error {
	switch name {
	case orgrole.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case orgrole.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orgrole.FieldOrgID:
		m.ClearOrgID()
		return nil
	case orgrole.FieldAppRoleID:
		m.ClearAppRoleID()
		return nil
	case orgrole.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown OrgRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgRoleMutation) ResetField(name string) error {
	switch name {
	case orgrole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orgrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orgrole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orgrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orgrole.FieldOrgID:
		m.ResetOrgID()
		return nil
	case orgrole.FieldKind:
		m.ResetKind()
		return nil
	case orgrole.FieldName:
		m.ResetName()
		return nil
	case orgrole.FieldAppRoleID:
		m.ResetAppRoleID()
		return nil
	case orgrole.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown OrgRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.org != nil {
		edges = append(edges, orgrole.EdgeOrg)
	}
	if m.org_users != nil {
		edges = append(edges, orgrole.EdgeOrgUsers)
	}
	if m.org_role_user != nil {
		edges = append(edges, orgrole.EdgeOrgRoleUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgrole.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	case orgrole.EdgeOrgUsers:
		ids := make([]ent.Value, 0, len(m.org_users))
		for id := range m.org_users {
			ids = append(ids, id)
		}
		return ids
	case orgrole.EdgeOrgRoleUser:
		ids := make([]ent.Value, 0, len(m.org_role_user))
		for id := range m.org_role_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorg_users != nil {
		edges = append(edges, orgrole.EdgeOrgUsers)
	}
	if m.removedorg_role_user != nil {
		edges = append(edges, orgrole.EdgeOrgRoleUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orgrole.EdgeOrgUsers:
		ids := make([]ent.Value, 0, len(m.removedorg_users))
		for id := range m.removedorg_users {
			ids = append(ids, id)
		}
		return ids
	case orgrole.EdgeOrgRoleUser:
		ids := make([]ent.Value, 0, len(m.removedorg_role_user))
		for id := range m.removedorg_role_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedorg {
		edges = append(edges, orgrole.EdgeOrg)
	}
	if m.clearedorg_users {
		edges = append(edges, orgrole.EdgeOrgUsers)
	}
	if m.clearedorg_role_user {
		edges = append(edges, orgrole.EdgeOrgRoleUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case orgrole.EdgeOrg:
		return m.clearedorg
	case orgrole.EdgeOrgUsers:
		return m.clearedorg_users
	case orgrole.EdgeOrgRoleUser:
		return m.clearedorg_role_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgRoleMutation) ClearEdge(name string) error {
	switch name {
	case orgrole.EdgeOrg:
		m.ClearOrg()
		return nil
	}
	return fmt.Errorf("unknown OrgRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgRoleMutation) ResetEdge(name string) error {
	switch name {
	case orgrole.EdgeOrg:
		m.ResetOrg()
		return nil
	case orgrole.EdgeOrgUsers:
		m.ResetOrgUsers()
		return nil
	case orgrole.EdgeOrgRoleUser:
		m.ResetOrgRoleUser()
		return nil
	}
	return fmt.Errorf("unknown OrgRole edge %s", name)
}

// OrgRoleUserMutation represents an operation that mutates the OrgRoleUser nodes in the graph.
type OrgRoleUserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_by      *int
	addcreated_by   *int
	created_at      *time.Time
	updated_by      *int
	addupdated_by   *int
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	org_role        *int
	clearedorg_role bool
	org_user        *int
	clearedorg_user bool
	user            *int
	cleareduser     bool
	org             *int
	clearedorg      bool
	done            bool
	oldValue        func(context.Context) (*OrgRoleUser, error)
	predicates      []predicate.OrgRoleUser
}

var _ ent.Mutation = (*OrgRoleUserMutation)(nil)

// orgroleuserOption allows management of the mutation configuration using functional options.
type orgroleuserOption func(*OrgRoleUserMutation)

// newOrgRoleUserMutation creates new mutation for the OrgRoleUser entity.
func newOrgRoleUserMutation(c config, op Op, opts ...orgroleuserOption) *OrgRoleUserMutation {
	m := &OrgRoleUserMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgRoleUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgRoleUserID sets the ID field of the mutation.
func withOrgRoleUserID(id int) orgroleuserOption {
	return func(m *OrgRoleUserMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgRoleUser
		)
		m.oldValue = func(ctx context.Context) (*OrgRoleUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgRoleUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgRoleUser sets the old OrgRoleUser of the mutation.
func withOrgRoleUser(node *OrgRoleUser) orgroleuserOption {
	return func(m *OrgRoleUserMutation) {
		m.oldValue = func(context.Context) (*OrgRoleUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgRoleUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgRoleUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgRoleUser entities.
func (m *OrgRoleUserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgRoleUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgRoleUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgRoleUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgRoleUserMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgRoleUserMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrgRoleUserMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrgRoleUserMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgRoleUserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgRoleUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgRoleUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgRoleUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgRoleUserMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgRoleUserMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrgRoleUserMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrgRoleUserMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgRoleUserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[orgroleuser.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgRoleUserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orgroleuser.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgRoleUserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, orgroleuser.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgRoleUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgRoleUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgRoleUserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orgroleuser.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgRoleUserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orgroleuser.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgRoleUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orgroleuser.FieldUpdatedAt)
}

// SetOrgRoleID sets the "org_role_id" field.
func (m *OrgRoleUserMutation) SetOrgRoleID(i int) {
	m.org_role = &i
}

// OrgRoleID returns the value of the "org_role_id" field in the mutation.
func (m *OrgRoleUserMutation) OrgRoleID() (r int, exists bool) {
	v := m.org_role
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgRoleID returns the old "org_role_id" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldOrgRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgRoleID: %w", err)
	}
	return oldValue.OrgRoleID, nil
}

// ResetOrgRoleID resets all changes to the "org_role_id" field.
func (m *OrgRoleUserMutation) ResetOrgRoleID() {
	m.org_role = nil
}

// SetOrgUserID sets the "org_user_id" field.
func (m *OrgRoleUserMutation) SetOrgUserID(i int) {
	m.org_user = &i
}

// OrgUserID returns the value of the "org_user_id" field in the mutation.
func (m *OrgRoleUserMutation) OrgUserID() (r int, exists bool) {
	v := m.org_user
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgUserID returns the old "org_user_id" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldOrgUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgUserID: %w", err)
	}
	return oldValue.OrgUserID, nil
}

// ResetOrgUserID resets all changes to the "org_user_id" field.
func (m *OrgRoleUserMutation) ResetOrgUserID() {
	m.org_user = nil
}

// SetUserID sets the "user_id" field.
func (m *OrgRoleUserMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrgRoleUserMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrgRoleUserMutation) ResetUserID() {
	m.user = nil
}

// SetOrgID sets the "org_id" field.
func (m *OrgRoleUserMutation) SetOrgID(i int) {
	m.org = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrgRoleUserMutation) OrgID() (r int, exists bool) {
	v := m.org
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrgRoleUserMutation) ResetOrgID() {
	m.org = nil
}

// ClearOrgRole clears the "org_role" edge to the OrgRole entity.
func (m *OrgRoleUserMutation) ClearOrgRole() {
	m.clearedorg_role = true
}

// OrgRoleCleared reports if the "org_role" edge to the OrgRole entity was cleared.
func (m *OrgRoleUserMutation) OrgRoleCleared() bool {
	return m.clearedorg_role
}

// OrgRoleIDs returns the "org_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgRoleID instead. It exists only for internal usage by the builders.
func (m *OrgRoleUserMutation) OrgRoleIDs() (ids []int) {
	if id := m.org_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrgRole resets all changes to the "org_role" edge.
func (m *OrgRoleUserMutation) ResetOrgRole() {
	m.org_role = nil
	m.clearedorg_role = false
}

// ClearOrgUser clears the "org_user" edge to the OrgUser entity.
func (m *OrgRoleUserMutation) ClearOrgUser() {
	m.clearedorg_user = true
}

// OrgUserCleared reports if the "org_user" edge to the OrgUser entity was cleared.
func (m *OrgRoleUserMutation) OrgUserCleared() bool {
	return m.clearedorg_user
}

// OrgUserIDs returns the "org_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgUserID instead. It exists only for internal usage by the builders.
func (m *OrgRoleUserMutation) OrgUserIDs() (ids []int) {
	if id := m.org_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrgUser resets all changes to the "org_user" edge.
func (m *OrgRoleUserMutation) ResetOrgUser() {
	m.org_user = nil
	m.clearedorg_user = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrgRoleUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrgRoleUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrgRoleUserMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrgRoleUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearOrg clears the "org" edge to the Org entity.
func (m *OrgRoleUserMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the Org entity was cleared.
func (m *OrgRoleUserMutation) OrgCleared() bool {
	return m.clearedorg
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *OrgRoleUserMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *OrgRoleUserMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// Where appends a list predicates to the OrgRoleUserMutation builder.
func (m *OrgRoleUserMutation) Where(ps ...predicate.OrgRoleUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgRoleUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgRoleUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgRoleUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgRoleUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgRoleUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgRoleUser).
func (m *OrgRoleUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgRoleUserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, orgroleuser.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, orgroleuser.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, orgroleuser.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, orgroleuser.FieldUpdatedAt)
	}
	if m.org_role != nil {
		fields = append(fields, orgroleuser.FieldOrgRoleID)
	}
	if m.org_user != nil {
		fields = append(fields, orgroleuser.FieldOrgUserID)
	}
	if m.user != nil {
		fields = append(fields, orgroleuser.FieldUserID)
	}
	if m.org != nil {
		fields = append(fields, orgroleuser.FieldOrgID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgRoleUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgroleuser.FieldCreatedBy:
		return m.CreatedBy()
	case orgroleuser.FieldCreatedAt:
		return m.CreatedAt()
	case orgroleuser.FieldUpdatedBy:
		return m.UpdatedBy()
	case orgroleuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case orgroleuser.FieldOrgRoleID:
		return m.OrgRoleID()
	case orgroleuser.FieldOrgUserID:
		return m.OrgUserID()
	case orgroleuser.FieldUserID:
		return m.UserID()
	case orgroleuser.FieldOrgID:
		return m.OrgID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgRoleUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgroleuser.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orgroleuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orgroleuser.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orgroleuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orgroleuser.FieldOrgRoleID:
		return m.OldOrgRoleID(ctx)
	case orgroleuser.FieldOrgUserID:
		return m.OldOrgUserID(ctx)
	case orgroleuser.FieldUserID:
		return m.OldUserID(ctx)
	case orgroleuser.FieldOrgID:
		return m.OldOrgID(ctx)
	}
	return nil, fmt.Errorf("unknown OrgRoleUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgRoleUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgroleuser.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orgroleuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orgroleuser.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orgroleuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orgroleuser.FieldOrgRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgRoleID(v)
		return nil
	case orgroleuser.FieldOrgUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgUserID(v)
		return nil
	case orgroleuser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orgroleuser.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgRoleUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, orgroleuser.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, orgroleuser.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgRoleUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orgroleuser.FieldCreatedBy:
		return m.AddedCreatedBy()
	case orgroleuser.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgRoleUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orgroleuser.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case orgroleuser.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgRoleUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgroleuser.FieldUpdatedBy) {
		fields = append(fields, orgroleuser.FieldUpdatedBy)
	}
	if m.FieldCleared(orgroleuser.FieldUpdatedAt) {
		fields = append(fields, orgroleuser.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgRoleUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgRoleUserMutation) ClearField(name string) error {
	switch name {
	case orgroleuser.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case orgroleuser.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgRoleUserMutation) ResetField(name string) error {
	switch name {
	case orgroleuser.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orgroleuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orgroleuser.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orgroleuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orgroleuser.FieldOrgRoleID:
		m.ResetOrgRoleID()
		return nil
	case orgroleuser.FieldOrgUserID:
		m.ResetOrgUserID()
		return nil
	case orgroleuser.FieldUserID:
		m.ResetUserID()
		return nil
	case orgroleuser.FieldOrgID:
		m.ResetOrgID()
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgRoleUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.org_role != nil {
		edges = append(edges, orgroleuser.EdgeOrgRole)
	}
	if m.org_user != nil {
		edges = append(edges, orgroleuser.EdgeOrgUser)
	}
	if m.user != nil {
		edges = append(edges, orgroleuser.EdgeUser)
	}
	if m.org != nil {
		edges = append(edges, orgroleuser.EdgeOrg)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgRoleUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgroleuser.EdgeOrgRole:
		if id := m.org_role; id != nil {
			return []ent.Value{*id}
		}
	case orgroleuser.EdgeOrgUser:
		if id := m.org_user; id != nil {
			return []ent.Value{*id}
		}
	case orgroleuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case orgroleuser.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgRoleUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgRoleUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgRoleUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorg_role {
		edges = append(edges, orgroleuser.EdgeOrgRole)
	}
	if m.clearedorg_user {
		edges = append(edges, orgroleuser.EdgeOrgUser)
	}
	if m.cleareduser {
		edges = append(edges, orgroleuser.EdgeUser)
	}
	if m.clearedorg {
		edges = append(edges, orgroleuser.EdgeOrg)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgRoleUserMutation) EdgeCleared(name string) bool {
	switch name {
	case orgroleuser.EdgeOrgRole:
		return m.clearedorg_role
	case orgroleuser.EdgeOrgUser:
		return m.clearedorg_user
	case orgroleuser.EdgeUser:
		return m.cleareduser
	case orgroleuser.EdgeOrg:
		return m.clearedorg
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgRoleUserMutation) ClearEdge(name string) error {
	switch name {
	case orgroleuser.EdgeOrgRole:
		m.ClearOrgRole()
		return nil
	case orgroleuser.EdgeOrgUser:
		m.ClearOrgUser()
		return nil
	case orgroleuser.EdgeUser:
		m.ClearUser()
		return nil
	case orgroleuser.EdgeOrg:
		m.ClearOrg()
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgRoleUserMutation) ResetEdge(name string) error {
	switch name {
	case orgroleuser.EdgeOrgRole:
		m.ResetOrgRole()
		return nil
	case orgroleuser.EdgeOrgUser:
		m.ResetOrgUser()
		return nil
	case orgroleuser.EdgeUser:
		m.ResetUser()
		return nil
	case orgroleuser.EdgeOrg:
		m.ResetOrg()
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser edge %s", name)
}

// OrgUserMutation represents an operation that mutates the OrgUser nodes in the graph.
type OrgUserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_by           *int
	addcreated_by        *int
	created_at           *time.Time
	updated_by           *int
	addupdated_by        *int
	updated_at           *time.Time
	joined_at            *time.Time
	display_name         *string
	clearedFields        map[string]struct{}
	org                  *int
	clearedorg           bool
	user                 *int
	cleareduser          bool
	org_roles            map[int]struct{}
	removedorg_roles     map[int]struct{}
	clearedorg_roles     bool
	org_role_user        map[int]struct{}
	removedorg_role_user map[int]struct{}
	clearedorg_role_user bool
	done                 bool
	oldValue             func(context.Context) (*OrgUser, error)
	predicates           []predicate.OrgUser
}

var _ ent.Mutation = (*OrgUserMutation)(nil)

// orguserOption allows management of the mutation configuration using functional options.
type orguserOption func(*OrgUserMutation)

// newOrgUserMutation creates new mutation for the OrgUser entity.
func newOrgUserMutation(c config, op Op, opts ...orguserOption) *OrgUserMutation {
	m := &OrgUserMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgUserID sets the ID field of the mutation.
func withOrgUserID(id int) orguserOption {
	return func(m *OrgUserMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgUser
		)
		m.oldValue = func(ctx context.Context) (*OrgUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgUser sets the old OrgUser of the mutation.
func withOrgUser(node *OrgUser) orguserOption {
	return func(m *OrgUserMutation) {
		m.oldValue = func(context.Context) (*OrgUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgUser entities.
func (m *OrgUserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgUserMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgUserMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrgUserMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrgUserMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgUserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgUserMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgUserMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrgUserMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrgUserMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgUserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[orguser.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgUserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orguser.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgUserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, orguser.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgUserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orguser.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgUserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orguser.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orguser.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *OrgUserMutation) SetOrgID(i int) {
	m.org = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrgUserMutation) OrgID() (r int, exists bool) {
	v := m.org
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrgUserMutation) ResetOrgID() {
	m.org = nil
}

// SetUserID sets the "user_id" field.
func (m *OrgUserMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrgUserMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrgUserMutation) ResetUserID() {
	m.user = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *OrgUserMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *OrgUserMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *OrgUserMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// SetDisplayName sets the "display_name" field.
func (m *OrgUserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OrgUserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OrgUserMutation) ResetDisplayName() {
	m.display_name = nil
}

// ClearOrg clears the "org" edge to the Org entity.
func (m *OrgUserMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the Org entity was cleared.
func (m *OrgUserMutation) OrgCleared() bool {
	return m.clearedorg
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *OrgUserMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *OrgUserMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrgUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrgUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrgUserMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrgUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddOrgRoleIDs adds the "org_roles" edge to the OrgRole entity by ids.
func (m *OrgUserMutation) AddOrgRoleIDs(ids ...int) {
	if m.org_roles == nil {
		m.org_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.org_roles[ids[i]] = struct{}{}
	}
}

// ClearOrgRoles clears the "org_roles" edge to the OrgRole entity.
func (m *OrgUserMutation) ClearOrgRoles() {
	m.clearedorg_roles = true
}

// OrgRolesCleared reports if the "org_roles" edge to the OrgRole entity was cleared.
func (m *OrgUserMutation) OrgRolesCleared() bool {
	return m.clearedorg_roles
}

// RemoveOrgRoleIDs removes the "org_roles" edge to the OrgRole entity by IDs.
func (m *OrgUserMutation) RemoveOrgRoleIDs(ids ...int) {
	if m.removedorg_roles == nil {
		m.removedorg_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_roles, ids[i])
		m.removedorg_roles[ids[i]] = struct{}{}
	}
}

// RemovedOrgRoles returns the removed IDs of the "org_roles" edge to the OrgRole entity.
func (m *OrgUserMutation) RemovedOrgRolesIDs() (ids []int) {
	for id := range m.removedorg_roles {
		ids = append(ids, id)
	}
	return
}

// OrgRolesIDs returns the "org_roles" edge IDs in the mutation.
func (m *OrgUserMutation) OrgRolesIDs() (ids []int) {
	for id := range m.org_roles {
		ids = append(ids, id)
	}
	return
}

// ResetOrgRoles resets all changes to the "org_roles" edge.
func (m *OrgUserMutation) ResetOrgRoles() {
	m.org_roles = nil
	m.clearedorg_roles = false
	m.removedorg_roles = nil
}

// AddOrgRoleUserIDs adds the "org_role_user" edge to the OrgRoleUser entity by ids.
func (m *OrgUserMutation) AddOrgRoleUserIDs(ids ...int) {
	if m.org_role_user == nil {
		m.org_role_user = make(map[int]struct{})
	}
	for i := range ids {
		m.org_role_user[ids[i]] = struct{}{}
	}
}

// ClearOrgRoleUser clears the "org_role_user" edge to the OrgRoleUser entity.
func (m *OrgUserMutation) ClearOrgRoleUser() {
	m.clearedorg_role_user = true
}

// OrgRoleUserCleared reports if the "org_role_user" edge to the OrgRoleUser entity was cleared.
func (m *OrgUserMutation) OrgRoleUserCleared() bool {
	return m.clearedorg_role_user
}

// RemoveOrgRoleUserIDs removes the "org_role_user" edge to the OrgRoleUser entity by IDs.
func (m *OrgUserMutation) RemoveOrgRoleUserIDs(ids ...int) {
	if m.removedorg_role_user == nil {
		m.removedorg_role_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_role_user, ids[i])
		m.removedorg_role_user[ids[i]] = struct{}{}
	}
}

// RemovedOrgRoleUser returns the removed IDs of the "org_role_user" edge to the OrgRoleUser entity.
func (m *OrgUserMutation) RemovedOrgRoleUserIDs() (ids []int) {
	for id := range m.removedorg_role_user {
		ids = append(ids, id)
	}
	return
}

// OrgRoleUserIDs returns the "org_role_user" edge IDs in the mutation.
func (m *OrgUserMutation) OrgRoleUserIDs() (ids []int) {
	for id := range m.org_role_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrgRoleUser resets all changes to the "org_role_user" edge.
func (m *OrgUserMutation) ResetOrgRoleUser() {
	m.org_role_user = nil
	m.clearedorg_role_user = false
	m.removedorg_role_user = nil
}

// Where appends a list predicates to the OrgUserMutation builder.
func (m *OrgUserMutation) Where(ps ...predicate.OrgUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgUser).
func (m *OrgUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgUserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, orguser.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, orguser.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, orguser.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, orguser.FieldUpdatedAt)
	}
	if m.org != nil {
		fields = append(fields, orguser.FieldOrgID)
	}
	if m.user != nil {
		fields = append(fields, orguser.FieldUserID)
	}
	if m.joined_at != nil {
		fields = append(fields, orguser.FieldJoinedAt)
	}
	if m.display_name != nil {
		fields = append(fields, orguser.FieldDisplayName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orguser.FieldCreatedBy:
		return m.CreatedBy()
	case orguser.FieldCreatedAt:
		return m.CreatedAt()
	case orguser.FieldUpdatedBy:
		return m.UpdatedBy()
	case orguser.FieldUpdatedAt:
		return m.UpdatedAt()
	case orguser.FieldOrgID:
		return m.OrgID()
	case orguser.FieldUserID:
		return m.UserID()
	case orguser.FieldJoinedAt:
		return m.JoinedAt()
	case orguser.FieldDisplayName:
		return m.DisplayName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orguser.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orguser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orguser.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orguser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orguser.FieldOrgID:
		return m.OldOrgID(ctx)
	case orguser.FieldUserID:
		return m.OldUserID(ctx)
	case orguser.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case orguser.FieldDisplayName:
		return m.OldDisplayName(ctx)
	}
	return nil, fmt.Errorf("unknown OrgUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orguser.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orguser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orguser.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orguser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orguser.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case orguser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orguser.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case orguser.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, orguser.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, orguser.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orguser.FieldCreatedBy:
		return m.AddedCreatedBy()
	case orguser.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orguser.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case orguser.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orguser.FieldUpdatedBy) {
		fields = append(fields, orguser.FieldUpdatedBy)
	}
	if m.FieldCleared(orguser.FieldUpdatedAt) {
		fields = append(fields, orguser.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgUserMutation) ClearField(name string) error {
	switch name {
	case orguser.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case orguser.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrgUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgUserMutation) ResetField(name string) error {
	switch name {
	case orguser.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orguser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orguser.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orguser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orguser.FieldOrgID:
		m.ResetOrgID()
		return nil
	case orguser.FieldUserID:
		m.ResetUserID()
		return nil
	case orguser.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case orguser.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	}
	return fmt.Errorf("unknown OrgUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.org != nil {
		edges = append(edges, orguser.EdgeOrg)
	}
	if m.user != nil {
		edges = append(edges, orguser.EdgeUser)
	}
	if m.org_roles != nil {
		edges = append(edges, orguser.EdgeOrgRoles)
	}
	if m.org_role_user != nil {
		edges = append(edges, orguser.EdgeOrgRoleUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orguser.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	case orguser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case orguser.EdgeOrgRoles:
		ids := make([]ent.Value, 0, len(m.org_roles))
		for id := range m.org_roles {
			ids = append(ids, id)
		}
		return ids
	case orguser.EdgeOrgRoleUser:
		ids := make([]ent.Value, 0, len(m.org_role_user))
		for id := range m.org_role_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedorg_roles != nil {
		edges = append(edges, orguser.EdgeOrgRoles)
	}
	if m.removedorg_role_user != nil {
		edges = append(edges, orguser.EdgeOrgRoleUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orguser.EdgeOrgRoles:
		ids := make([]ent.Value, 0, len(m.removedorg_roles))
		for id := range m.removedorg_roles {
			ids = append(ids, id)
		}
		return ids
	case orguser.EdgeOrgRoleUser:
		ids := make([]ent.Value, 0, len(m.removedorg_role_user))
		for id := range m.removedorg_role_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorg {
		edges = append(edges, orguser.EdgeOrg)
	}
	if m.cleareduser {
		edges = append(edges, orguser.EdgeUser)
	}
	if m.clearedorg_roles {
		edges = append(edges, orguser.EdgeOrgRoles)
	}
	if m.clearedorg_role_user {
		edges = append(edges, orguser.EdgeOrgRoleUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgUserMutation) EdgeCleared(name string) bool {
	switch name {
	case orguser.EdgeOrg:
		return m.clearedorg
	case orguser.EdgeUser:
		return m.cleareduser
	case orguser.EdgeOrgRoles:
		return m.clearedorg_roles
	case orguser.EdgeOrgRoleUser:
		return m.clearedorg_role_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgUserMutation) ClearEdge(name string) error {
	switch name {
	case orguser.EdgeOrg:
		m.ClearOrg()
		return nil
	case orguser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OrgUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgUserMutation) ResetEdge(name string) error {
	switch name {
	case orguser.EdgeOrg:
		m.ResetOrg()
		return nil
	case orguser.EdgeUser:
		m.ResetUser()
		return nil
	case orguser.EdgeOrgRoles:
		m.ResetOrgRoles()
		return nil
	case orguser.EdgeOrgRoleUser:
		m.ResetOrgRoleUser()
		return nil
	}
	return fmt.Errorf("unknown OrgUser edge %s", name)
}

// OrgUserPreferenceMutation represents an operation that mutates the OrgUserPreference nodes in the graph.
type OrgUserPreferenceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_by          *int
	addcreated_by       *int
	created_at          *time.Time
	updated_by          *int
	addupdated_by       *int
	updated_at          *time.Time
	menu_favorite       *[]int
	appendmenu_favorite []int
	menu_recent         *[]int
	appendmenu_recent   []int
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	org                 *int
	clearedorg          bool
	done                bool
	oldValue            func(context.Context) (*OrgUserPreference, error)
	predicates          []predicate.OrgUserPreference
}

var _ ent.Mutation = (*OrgUserPreferenceMutation)(nil)

// orguserpreferenceOption allows management of the mutation configuration using functional options.
type orguserpreferenceOption func(*OrgUserPreferenceMutation)

// newOrgUserPreferenceMutation creates new mutation for the OrgUserPreference entity.
func newOrgUserPreferenceMutation(c config, op Op, opts ...orguserpreferenceOption) *OrgUserPreferenceMutation {
	m := &OrgUserPreferenceMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgUserPreference,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgUserPreferenceID sets the ID field of the mutation.
func withOrgUserPreferenceID(id int) orguserpreferenceOption {
	return func(m *OrgUserPreferenceMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgUserPreference
		)
		m.oldValue = func(ctx context.Context) (*OrgUserPreference, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgUserPreference.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgUserPreference sets the old OrgUserPreference of the mutation.
func withOrgUserPreference(node *OrgUserPreference) orguserpreferenceOption {
	return func(m *OrgUserPreferenceMutation) {
		m.oldValue = func(context.Context) (*OrgUserPreference, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgUserPreferenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgUserPreferenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgUserPreference entities.
func (m *OrgUserPreferenceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgUserPreferenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgUserPreferenceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgUserPreference.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *OrgUserPreferenceMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrgUserPreferenceMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrgUserPreference entity.
// If the OrgUserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserPreferenceMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *OrgUserPreferenceMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *OrgUserPreferenceMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrgUserPreferenceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrgUserPreferenceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrgUserPreferenceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrgUserPreference entity.
// If the OrgUserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserPreferenceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrgUserPreferenceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrgUserPreferenceMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrgUserPreferenceMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the OrgUserPreference entity.
// If the OrgUserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserPreferenceMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *OrgUserPreferenceMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *OrgUserPreferenceMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrgUserPreferenceMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[orguserpreference.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrgUserPreferenceMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[orguserpreference.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrgUserPreferenceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, orguserpreference.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrgUserPreferenceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrgUserPreferenceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrgUserPreference entity.
// If the OrgUserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserPreferenceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OrgUserPreferenceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[orguserpreference.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OrgUserPreferenceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[orguserpreference.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrgUserPreferenceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, orguserpreference.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *OrgUserPreferenceMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrgUserPreferenceMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrgUserPreference entity.
// If the OrgUserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserPreferenceMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrgUserPreferenceMutation) ResetUserID() {
	m.user = nil
}

// SetOrgID sets the "org_id" field.
func (m *OrgUserPreferenceMutation) SetOrgID(i int) {
	m.org = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrgUserPreferenceMutation) OrgID() (r int, exists bool) {
	v := m.org
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrgUserPreference entity.
// If the OrgUserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserPreferenceMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrgUserPreferenceMutation) ResetOrgID() {
	m.org = nil
}

// SetMenuFavorite sets the "menu_favorite" field.
func (m *OrgUserPreferenceMutation) SetMenuFavorite(i []int) {
	m.menu_favorite = &i
	m.appendmenu_favorite = nil
}

// MenuFavorite returns the value of the "menu_favorite" field in the mutation.
func (m *OrgUserPreferenceMutation) MenuFavorite() (r []int, exists bool) {
	v := m.menu_favorite
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuFavorite returns the old "menu_favorite" field's value of the OrgUserPreference entity.
// If the OrgUserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserPreferenceMutation) OldMenuFavorite(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuFavorite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuFavorite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuFavorite: %w", err)
	}
	return oldValue.MenuFavorite, nil
}

// AppendMenuFavorite adds i to the "menu_favorite" field.
func (m *OrgUserPreferenceMutation) AppendMenuFavorite(i []int) {
	m.appendmenu_favorite = append(m.appendmenu_favorite, i...)
}

// AppendedMenuFavorite returns the list of values that were appended to the "menu_favorite" field in this mutation.
func (m *OrgUserPreferenceMutation) AppendedMenuFavorite() ([]int, bool) {
	if len(m.appendmenu_favorite) == 0 {
		return nil, false
	}
	return m.appendmenu_favorite, true
}

// ClearMenuFavorite clears the value of the "menu_favorite" field.
func (m *OrgUserPreferenceMutation) ClearMenuFavorite() {
	m.menu_favorite = nil
	m.appendmenu_favorite = nil
	m.clearedFields[orguserpreference.FieldMenuFavorite] = struct{}{}
}

// MenuFavoriteCleared returns if the "menu_favorite" field was cleared in this mutation.
func (m *OrgUserPreferenceMutation) MenuFavoriteCleared() bool {
	_, ok := m.clearedFields[orguserpreference.FieldMenuFavorite]
	return ok
}

// ResetMenuFavorite resets all changes to the "menu_favorite" field.
func (m *OrgUserPreferenceMutation) ResetMenuFavorite() {
	m.menu_favorite = nil
	m.appendmenu_favorite = nil
	delete(m.clearedFields, orguserpreference.FieldMenuFavorite)
}

// SetMenuRecent sets the "menu_recent" field.
func (m *OrgUserPreferenceMutation) SetMenuRecent(i []int) {
	m.menu_recent = &i
	m.appendmenu_recent = nil
}

// MenuRecent returns the value of the "menu_recent" field in the mutation.
func (m *OrgUserPreferenceMutation) MenuRecent() (r []int, exists bool) {
	v := m.menu_recent
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuRecent returns the old "menu_recent" field's value of the OrgUserPreference entity.
// If the OrgUserPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserPreferenceMutation) OldMenuRecent(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuRecent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuRecent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuRecent: %w", err)
	}
	return oldValue.MenuRecent, nil
}

// AppendMenuRecent adds i to the "menu_recent" field.
func (m *OrgUserPreferenceMutation) AppendMenuRecent(i []int) {
	m.appendmenu_recent = append(m.appendmenu_recent, i...)
}

// AppendedMenuRecent returns the list of values that were appended to the "menu_recent" field in this mutation.
func (m *OrgUserPreferenceMutation) AppendedMenuRecent() ([]int, bool) {
	if len(m.appendmenu_recent) == 0 {
		return nil, false
	}
	return m.appendmenu_recent, true
}

// ClearMenuRecent clears the value of the "menu_recent" field.
func (m *OrgUserPreferenceMutation) ClearMenuRecent() {
	m.menu_recent = nil
	m.appendmenu_recent = nil
	m.clearedFields[orguserpreference.FieldMenuRecent] = struct{}{}
}

// MenuRecentCleared returns if the "menu_recent" field was cleared in this mutation.
func (m *OrgUserPreferenceMutation) MenuRecentCleared() bool {
	_, ok := m.clearedFields[orguserpreference.FieldMenuRecent]
	return ok
}

// ResetMenuRecent resets all changes to the "menu_recent" field.
func (m *OrgUserPreferenceMutation) ResetMenuRecent() {
	m.menu_recent = nil
	m.appendmenu_recent = nil
	delete(m.clearedFields, orguserpreference.FieldMenuRecent)
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrgUserPreferenceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrgUserPreferenceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrgUserPreferenceMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrgUserPreferenceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearOrg clears the "org" edge to the Org entity.
func (m *OrgUserPreferenceMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the Org entity was cleared.
func (m *OrgUserPreferenceMutation) OrgCleared() bool {
	return m.clearedorg
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *OrgUserPreferenceMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *OrgUserPreferenceMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// Where appends a list predicates to the OrgUserPreferenceMutation builder.
func (m *OrgUserPreferenceMutation) Where(ps ...predicate.OrgUserPreference) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgUserPreferenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgUserPreferenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgUserPreference, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgUserPreferenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgUserPreferenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgUserPreference).
func (m *OrgUserPreferenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgUserPreferenceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_by != nil {
		fields = append(fields, orguserpreference.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, orguserpreference.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, orguserpreference.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, orguserpreference.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, orguserpreference.FieldUserID)
	}
	if m.org != nil {
		fields = append(fields, orguserpreference.FieldOrgID)
	}
	if m.menu_favorite != nil {
		fields = append(fields, orguserpreference.FieldMenuFavorite)
	}
	if m.menu_recent != nil {
		fields = append(fields, orguserpreference.FieldMenuRecent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgUserPreferenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orguserpreference.FieldCreatedBy:
		return m.CreatedBy()
	case orguserpreference.FieldCreatedAt:
		return m.CreatedAt()
	case orguserpreference.FieldUpdatedBy:
		return m.UpdatedBy()
	case orguserpreference.FieldUpdatedAt:
		return m.UpdatedAt()
	case orguserpreference.FieldUserID:
		return m.UserID()
	case orguserpreference.FieldOrgID:
		return m.OrgID()
	case orguserpreference.FieldMenuFavorite:
		return m.MenuFavorite()
	case orguserpreference.FieldMenuRecent:
		return m.MenuRecent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgUserPreferenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orguserpreference.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orguserpreference.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orguserpreference.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case orguserpreference.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orguserpreference.FieldUserID:
		return m.OldUserID(ctx)
	case orguserpreference.FieldOrgID:
		return m.OldOrgID(ctx)
	case orguserpreference.FieldMenuFavorite:
		return m.OldMenuFavorite(ctx)
	case orguserpreference.FieldMenuRecent:
		return m.OldMenuRecent(ctx)
	}
	return nil, fmt.Errorf("unknown OrgUserPreference field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUserPreferenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orguserpreference.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orguserpreference.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orguserpreference.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case orguserpreference.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orguserpreference.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orguserpreference.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case orguserpreference.FieldMenuFavorite:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuFavorite(v)
		return nil
	case orguserpreference.FieldMenuRecent:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuRecent(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUserPreference field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgUserPreferenceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, orguserpreference.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, orguserpreference.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgUserPreferenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orguserpreference.FieldCreatedBy:
		return m.AddedCreatedBy()
	case orguserpreference.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUserPreferenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orguserpreference.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case orguserpreference.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUserPreference numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgUserPreferenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orguserpreference.FieldUpdatedBy) {
		fields = append(fields, orguserpreference.FieldUpdatedBy)
	}
	if m.FieldCleared(orguserpreference.FieldUpdatedAt) {
		fields = append(fields, orguserpreference.FieldUpdatedAt)
	}
	if m.FieldCleared(orguserpreference.FieldMenuFavorite) {
		fields = append(fields, orguserpreference.FieldMenuFavorite)
	}
	if m.FieldCleared(orguserpreference.FieldMenuRecent) {
		fields = append(fields, orguserpreference.FieldMenuRecent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgUserPreferenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgUserPreferenceMutation) ClearField(name string) error {
	switch name {
	case orguserpreference.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case orguserpreference.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case orguserpreference.FieldMenuFavorite:
		m.ClearMenuFavorite()
		return nil
	case orguserpreference.FieldMenuRecent:
		m.ClearMenuRecent()
		return nil
	}
	return fmt.Errorf("unknown OrgUserPreference nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgUserPreferenceMutation) ResetField(name string) error {
	switch name {
	case orguserpreference.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orguserpreference.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orguserpreference.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case orguserpreference.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orguserpreference.FieldUserID:
		m.ResetUserID()
		return nil
	case orguserpreference.FieldOrgID:
		m.ResetOrgID()
		return nil
	case orguserpreference.FieldMenuFavorite:
		m.ResetMenuFavorite()
		return nil
	case orguserpreference.FieldMenuRecent:
		m.ResetMenuRecent()
		return nil
	}
	return fmt.Errorf("unknown OrgUserPreference field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgUserPreferenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, orguserpreference.EdgeUser)
	}
	if m.org != nil {
		edges = append(edges, orguserpreference.EdgeOrg)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgUserPreferenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orguserpreference.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case orguserpreference.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgUserPreferenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgUserPreferenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgUserPreferenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, orguserpreference.EdgeUser)
	}
	if m.clearedorg {
		edges = append(edges, orguserpreference.EdgeOrg)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgUserPreferenceMutation) EdgeCleared(name string) bool {
	switch name {
	case orguserpreference.EdgeUser:
		return m.cleareduser
	case orguserpreference.EdgeOrg:
		return m.clearedorg
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgUserPreferenceMutation) ClearEdge(name string) error {
	switch name {
	case orguserpreference.EdgeUser:
		m.ClearUser()
		return nil
	case orguserpreference.EdgeOrg:
		m.ClearOrg()
		return nil
	}
	return fmt.Errorf("unknown OrgUserPreference unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgUserPreferenceMutation) ResetEdge(name string) error {
	switch name {
	case orguserpreference.EdgeUser:
		m.ResetUser()
		return nil
	case orguserpreference.EdgeOrg:
		m.ResetOrg()
		return nil
	}
	return fmt.Errorf("unknown OrgUserPreference edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_by        *int
	addcreated_by     *int
	created_at        *time.Time
	updated_by        *int
	addupdated_by     *int
	updated_at        *time.Time
	principal_kind    *permission.PrincipalKind
	start_at          *time.Time
	end_at            *time.Time
	status            *typex.SimpleStatus
	clearedFields     map[string]struct{}
	org               *int
	clearedorg        bool
	user              *int
	cleareduser       bool
	role              *int
	clearedrole       bool
	org_policy        *int
	clearedorg_policy bool
	done              bool
	oldValue          func(context.Context) (*Permission, error)
	predicates        []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *PermissionMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PermissionMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *PermissionMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *PermissionMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PermissionMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PermissionMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PermissionMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *PermissionMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *PermissionMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PermissionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[permission.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PermissionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[permission.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PermissionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, permission.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PermissionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[permission.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PermissionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, permission.FieldUpdatedAt)
}

// SetOrgID sets the "org_id" field.
func (m *PermissionMutation) SetOrgID(i int) {
	m.org = &i
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *PermissionMutation) OrgID() (r int, exists bool) {
	v := m.org
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *PermissionMutation) ResetOrgID() {
	m.org = nil
}

// SetPrincipalKind sets the "principal_kind" field.
func (m *PermissionMutation) SetPrincipalKind(pk permission.PrincipalKind) {
	m.principal_kind = &pk
}

// PrincipalKind returns the value of the "principal_kind" field in the mutation.
func (m *PermissionMutation) PrincipalKind() (r permission.PrincipalKind, exists bool) {
	v := m.principal_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldPrincipalKind returns the old "principal_kind" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldPrincipalKind(ctx context.Context) (v permission.PrincipalKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrincipalKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrincipalKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrincipalKind: %w", err)
	}
	return oldValue.PrincipalKind, nil
}

// ResetPrincipalKind resets all changes to the "principal_kind" field.
func (m *PermissionMutation) ResetPrincipalKind() {
	m.principal_kind = nil
}

// SetUserID sets the "user_id" field.
func (m *PermissionMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PermissionMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *PermissionMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[permission.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *PermissionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[permission.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PermissionMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, permission.FieldUserID)
}

// SetRoleID sets the "role_id" field.
func (m *PermissionMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *PermissionMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *PermissionMutation) ClearRoleID() {
	m.role = nil
	m.clearedFields[permission.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *PermissionMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[permission.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *PermissionMutation) ResetRoleID() {
	m.role = nil
	delete(m.clearedFields, permission.FieldRoleID)
}

// SetOrgPolicyID sets the "org_policy_id" field.
func (m *PermissionMutation) SetOrgPolicyID(i int) {
	m.org_policy = &i
}

// OrgPolicyID returns the value of the "org_policy_id" field in the mutation.
func (m *PermissionMutation) OrgPolicyID() (r int, exists bool) {
	v := m.org_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgPolicyID returns the old "org_policy_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldOrgPolicyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgPolicyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgPolicyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgPolicyID: %w", err)
	}
	return oldValue.OrgPolicyID, nil
}

// ResetOrgPolicyID resets all changes to the "org_policy_id" field.
func (m *PermissionMutation) ResetOrgPolicyID() {
	m.org_policy = nil
}

// SetStartAt sets the "start_at" field.
func (m *PermissionMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *PermissionMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *PermissionMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[permission.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *PermissionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *PermissionMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, permission.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *PermissionMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *PermissionMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *PermissionMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[permission.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *PermissionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *PermissionMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, permission.FieldEndAt)
}

// SetStatus sets the "status" field.
func (m *PermissionMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *PermissionMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PermissionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[permission.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PermissionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[permission.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PermissionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, permission.FieldStatus)
}

// ClearOrg clears the "org" edge to the Org entity.
func (m *PermissionMutation) ClearOrg() {
	m.clearedorg = true
}

// OrgCleared reports if the "org" edge to the Org entity was cleared.
func (m *PermissionMutation) OrgCleared() bool {
	return m.clearedorg
}

// OrgIDs returns the "org" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) OrgIDs() (ids []int) {
	if id := m.org; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrg resets all changes to the "org" edge.
func (m *PermissionMutation) ResetOrg() {
	m.org = nil
	m.clearedorg = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *PermissionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PermissionMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PermissionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRole clears the "role" edge to the OrgRole entity.
func (m *PermissionMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the OrgRole entity was cleared.
func (m *PermissionMutation) RoleCleared() bool {
	return m.RoleIDCleared() || m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *PermissionMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// ClearOrgPolicy clears the "org_policy" edge to the OrgPolicy entity.
func (m *PermissionMutation) ClearOrgPolicy() {
	m.clearedorg_policy = true
}

// OrgPolicyCleared reports if the "org_policy" edge to the OrgPolicy entity was cleared.
func (m *PermissionMutation) OrgPolicyCleared() bool {
	return m.clearedorg_policy
}

// OrgPolicyIDs returns the "org_policy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgPolicyID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) OrgPolicyIDs() (ids []int) {
	if id := m.org_policy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrgPolicy resets all changes to the "org_policy" edge.
func (m *PermissionMutation) ResetOrgPolicy() {
	m.org_policy = nil
	m.clearedorg_policy = false
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_by != nil {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.org != nil {
		fields = append(fields, permission.FieldOrgID)
	}
	if m.principal_kind != nil {
		fields = append(fields, permission.FieldPrincipalKind)
	}
	if m.user != nil {
		fields = append(fields, permission.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, permission.FieldRoleID)
	}
	if m.org_policy != nil {
		fields = append(fields, permission.FieldOrgPolicyID)
	}
	if m.start_at != nil {
		fields = append(fields, permission.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, permission.FieldEndAt)
	}
	if m.status != nil {
		fields = append(fields, permission.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedBy:
		return m.CreatedBy()
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedBy:
		return m.UpdatedBy()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldOrgID:
		return m.OrgID()
	case permission.FieldPrincipalKind:
		return m.PrincipalKind()
	case permission.FieldUserID:
		return m.UserID()
	case permission.FieldRoleID:
		return m.RoleID()
	case permission.FieldOrgPolicyID:
		return m.OrgPolicyID()
	case permission.FieldStartAt:
		return m.StartAt()
	case permission.FieldEndAt:
		return m.EndAt()
	case permission.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldOrgID:
		return m.OldOrgID(ctx)
	case permission.FieldPrincipalKind:
		return m.OldPrincipalKind(ctx)
	case permission.FieldUserID:
		return m.OldUserID(ctx)
	case permission.FieldRoleID:
		return m.OldRoleID(ctx)
	case permission.FieldOrgPolicyID:
		return m.OldOrgPolicyID(ctx)
	case permission.FieldStartAt:
		return m.OldStartAt(ctx)
	case permission.FieldEndAt:
		return m.OldEndAt(ctx)
	case permission.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case permission.FieldPrincipalKind:
		v, ok := value.(permission.PrincipalKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrincipalKind(v)
		return nil
	case permission.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case permission.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case permission.FieldOrgPolicyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgPolicyID(v)
		return nil
	case permission.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case permission.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case permission.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, permission.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreatedBy:
		return m.AddedCreatedBy()
	case permission.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case permission.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldUpdatedBy) {
		fields = append(fields, permission.FieldUpdatedBy)
	}
	if m.FieldCleared(permission.FieldUpdatedAt) {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.FieldCleared(permission.FieldUserID) {
		fields = append(fields, permission.FieldUserID)
	}
	if m.FieldCleared(permission.FieldRoleID) {
		fields = append(fields, permission.FieldRoleID)
	}
	if m.FieldCleared(permission.FieldStartAt) {
		fields = append(fields, permission.FieldStartAt)
	}
	if m.FieldCleared(permission.FieldEndAt) {
		fields = append(fields, permission.FieldEndAt)
	}
	if m.FieldCleared(permission.FieldStatus) {
		fields = append(fields, permission.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case permission.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case permission.FieldUserID:
		m.ClearUserID()
		return nil
	case permission.FieldRoleID:
		m.ClearRoleID()
		return nil
	case permission.FieldStartAt:
		m.ClearStartAt()
		return nil
	case permission.FieldEndAt:
		m.ClearEndAt()
		return nil
	case permission.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldOrgID:
		m.ResetOrgID()
		return nil
	case permission.FieldPrincipalKind:
		m.ResetPrincipalKind()
		return nil
	case permission.FieldUserID:
		m.ResetUserID()
		return nil
	case permission.FieldRoleID:
		m.ResetRoleID()
		return nil
	case permission.FieldOrgPolicyID:
		m.ResetOrgPolicyID()
		return nil
	case permission.FieldStartAt:
		m.ResetStartAt()
		return nil
	case permission.FieldEndAt:
		m.ResetEndAt()
		return nil
	case permission.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.org != nil {
		edges = append(edges, permission.EdgeOrg)
	}
	if m.user != nil {
		edges = append(edges, permission.EdgeUser)
	}
	if m.role != nil {
		edges = append(edges, permission.EdgeRole)
	}
	if m.org_policy != nil {
		edges = append(edges, permission.EdgeOrgPolicy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeOrg:
		if id := m.org; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeOrgPolicy:
		if id := m.org_policy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorg {
		edges = append(edges, permission.EdgeOrg)
	}
	if m.cleareduser {
		edges = append(edges, permission.EdgeUser)
	}
	if m.clearedrole {
		edges = append(edges, permission.EdgeRole)
	}
	if m.clearedorg_policy {
		edges = append(edges, permission.EdgeOrgPolicy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeOrg:
		return m.clearedorg
	case permission.EdgeUser:
		return m.cleareduser
	case permission.EdgeRole:
		return m.clearedrole
	case permission.EdgeOrgPolicy:
		return m.clearedorg_policy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	case permission.EdgeOrg:
		m.ClearOrg()
		return nil
	case permission.EdgeUser:
		m.ClearUser()
		return nil
	case permission.EdgeRole:
		m.ClearRole()
		return nil
	case permission.EdgeOrgPolicy:
		m.ClearOrgPolicy()
		return nil
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeOrg:
		m.ResetOrg()
		return nil
	case permission.EdgeUser:
		m.ResetUser()
		return nil
	case permission.EdgeRole:
		m.ResetRole()
		return nil
	case permission.EdgeOrgPolicy:
		m.ResetOrgPolicy()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_by           *int
	addcreated_by        *int
	created_at           *time.Time
	updated_by           *int
	addupdated_by        *int
	updated_at           *time.Time
	deleted_at           *time.Time
	principal_name       *string
	display_name         *string
	email                *string
	mobile               *string
	user_type            *user.UserType
	creation_type        *user.CreationType
	register_ip          *string
	status               *typex.SimpleStatus
	comments             *string
	avatar_file_id       *int
	addavatar_file_id    *int
	clearedFields        map[string]struct{}
	identities           map[int]struct{}
	removedidentities    map[int]struct{}
	clearedidentities    bool
	login_profile        *int
	clearedlogin_profile bool
	passwords            map[int]struct{}
	removedpasswords     map[int]struct{}
	clearedpasswords     bool
	devices              map[int]struct{}
	removeddevices       map[int]struct{}
	cleareddevices       bool
	orgs                 map[int]struct{}
	removedorgs          map[int]struct{}
	clearedorgs          bool
	permissions          map[int]struct{}
	removedpermissions   map[int]struct{}
	clearedpermissions   bool
	oauth_clients        map[int]struct{}
	removedoauth_clients map[int]struct{}
	clearedoauth_clients bool
	org_user             map[int]struct{}
	removedorg_user      map[int]struct{}
	clearedorg_user      bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[user.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, user.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetPrincipalName sets the "principal_name" field.
func (m *UserMutation) SetPrincipalName(s string) {
	m.principal_name = &s
}

// PrincipalName returns the value of the "principal_name" field in the mutation.
func (m *UserMutation) PrincipalName() (r string, exists bool) {
	v := m.principal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPrincipalName returns the old "principal_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrincipalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrincipalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrincipalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrincipalName: %w", err)
	}
	return oldValue.PrincipalName, nil
}

// ResetPrincipalName resets all changes to the "principal_name" field.
func (m *UserMutation) ResetPrincipalName() {
	m.principal_name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *UserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *UserMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[user.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *UserMutation) MobileCleared() bool {
	_, ok := m.clearedFields[user.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, user.FieldMobile)
}

// SetUserType sets the "user_type" field.
func (m *UserMutation) SetUserType(ut user.UserType) {
	m.user_type = &ut
}

// UserType returns the value of the "user_type" field in the mutation.
func (m *UserMutation) UserType() (r user.UserType, exists bool) {
	v := m.user_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUserType returns the old "user_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserType(ctx context.Context) (v user.UserType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserType: %w", err)
	}
	return oldValue.UserType, nil
}

// ResetUserType resets all changes to the "user_type" field.
func (m *UserMutation) ResetUserType() {
	m.user_type = nil
}

// SetCreationType sets the "creation_type" field.
func (m *UserMutation) SetCreationType(ut user.CreationType) {
	m.creation_type = &ut
}

// CreationType returns the value of the "creation_type" field in the mutation.
func (m *UserMutation) CreationType() (r user.CreationType, exists bool) {
	v := m.creation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationType returns the old "creation_type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreationType(ctx context.Context) (v user.CreationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationType: %w", err)
	}
	return oldValue.CreationType, nil
}

// ResetCreationType resets all changes to the "creation_type" field.
func (m *UserMutation) ResetCreationType() {
	m.creation_type = nil
}

// SetRegisterIP sets the "register_ip" field.
func (m *UserMutation) SetRegisterIP(s string) {
	m.register_ip = &s
}

// RegisterIP returns the value of the "register_ip" field in the mutation.
func (m *UserMutation) RegisterIP() (r string, exists bool) {
	v := m.register_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterIP returns the old "register_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegisterIP(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterIP: %w", err)
	}
	return oldValue.RegisterIP, nil
}

// ResetRegisterIP resets all changes to the "register_ip" field.
func (m *UserMutation) ResetRegisterIP() {
	m.register_ip = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetComments sets the "comments" field.
func (m *UserMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *UserMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *UserMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[user.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *UserMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[user.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, user.FieldComments)
}

// SetAvatarFileID sets the "avatar_file_id" field.
func (m *UserMutation) SetAvatarFileID(i int) {
	m.avatar_file_id = &i
	m.addavatar_file_id = nil
}

// AvatarFileID returns the value of the "avatar_file_id" field in the mutation.
func (m *UserMutation) AvatarFileID() (r int, exists bool) {
	v := m.avatar_file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarFileID returns the old "avatar_file_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarFileID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarFileID: %w", err)
	}
	return oldValue.AvatarFileID, nil
}

// AddAvatarFileID adds i to the "avatar_file_id" field.
func (m *UserMutation) AddAvatarFileID(i int) {
	if m.addavatar_file_id != nil {
		*m.addavatar_file_id += i
	} else {
		m.addavatar_file_id = &i
	}
}

// AddedAvatarFileID returns the value that was added to the "avatar_file_id" field in this mutation.
func (m *UserMutation) AddedAvatarFileID() (r int, exists bool) {
	v := m.addavatar_file_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvatarFileID clears the value of the "avatar_file_id" field.
func (m *UserMutation) ClearAvatarFileID() {
	m.avatar_file_id = nil
	m.addavatar_file_id = nil
	m.clearedFields[user.FieldAvatarFileID] = struct{}{}
}

// AvatarFileIDCleared returns if the "avatar_file_id" field was cleared in this mutation.
func (m *UserMutation) AvatarFileIDCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarFileID]
	return ok
}

// ResetAvatarFileID resets all changes to the "avatar_file_id" field.
func (m *UserMutation) ResetAvatarFileID() {
	m.avatar_file_id = nil
	m.addavatar_file_id = nil
	delete(m.clearedFields, user.FieldAvatarFileID)
}

// AddIdentityIDs adds the "identities" edge to the UserIdentity entity by ids.
func (m *UserMutation) AddIdentityIDs(ids ...int) {
	if m.identities == nil {
		m.identities = make(map[int]struct{})
	}
	for i := range ids {
		m.identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "identities" edge to the UserIdentity entity.
func (m *UserMutation) ClearIdentities() {
	m.clearedidentities = true
}

// IdentitiesCleared reports if the "identities" edge to the UserIdentity entity was cleared.
func (m *UserMutation) IdentitiesCleared() bool {
	return m.clearedidentities
}

// RemoveIdentityIDs removes the "identities" edge to the UserIdentity entity by IDs.
func (m *UserMutation) RemoveIdentityIDs(ids ...int) {
	if m.removedidentities == nil {
		m.removedidentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.identities, ids[i])
		m.removedidentities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "identities" edge to the UserIdentity entity.
func (m *UserMutation) RemovedIdentitiesIDs() (ids []int) {
	for id := range m.removedidentities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "identities" edge IDs in the mutation.
func (m *UserMutation) IdentitiesIDs() (ids []int) {
	for id := range m.identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "identities" edge.
func (m *UserMutation) ResetIdentities() {
	m.identities = nil
	m.clearedidentities = false
	m.removedidentities = nil
}

// SetLoginProfileID sets the "login_profile" edge to the UserLoginProfile entity by id.
func (m *UserMutation) SetLoginProfileID(id int) {
	m.login_profile = &id
}

// ClearLoginProfile clears the "login_profile" edge to the UserLoginProfile entity.
func (m *UserMutation) ClearLoginProfile() {
	m.clearedlogin_profile = true
}

// LoginProfileCleared reports if the "login_profile" edge to the UserLoginProfile entity was cleared.
func (m *UserMutation) LoginProfileCleared() bool {
	return m.clearedlogin_profile
}

// LoginProfileID returns the "login_profile" edge ID in the mutation.
func (m *UserMutation) LoginProfileID() (id int, exists bool) {
	if m.login_profile != nil {
		return *m.login_profile, true
	}
	return
}

// LoginProfileIDs returns the "login_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LoginProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) LoginProfileIDs() (ids []int) {
	if id := m.login_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLoginProfile resets all changes to the "login_profile" edge.
func (m *UserMutation) ResetLoginProfile() {
	m.login_profile = nil
	m.clearedlogin_profile = false
}

// AddPasswordIDs adds the "passwords" edge to the UserPassword entity by ids.
func (m *UserMutation) AddPasswordIDs(ids ...int) {
	if m.passwords == nil {
		m.passwords = make(map[int]struct{})
	}
	for i := range ids {
		m.passwords[ids[i]] = struct{}{}
	}
}

// ClearPasswords clears the "passwords" edge to the UserPassword entity.
func (m *UserMutation) ClearPasswords() {
	m.clearedpasswords = true
}

// PasswordsCleared reports if the "passwords" edge to the UserPassword entity was cleared.
func (m *UserMutation) PasswordsCleared() bool {
	return m.clearedpasswords
}

// RemovePasswordIDs removes the "passwords" edge to the UserPassword entity by IDs.
func (m *UserMutation) RemovePasswordIDs(ids ...int) {
	if m.removedpasswords == nil {
		m.removedpasswords = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.passwords, ids[i])
		m.removedpasswords[ids[i]] = struct{}{}
	}
}

// RemovedPasswords returns the removed IDs of the "passwords" edge to the UserPassword entity.
func (m *UserMutation) RemovedPasswordsIDs() (ids []int) {
	for id := range m.removedpasswords {
		ids = append(ids, id)
	}
	return
}

// PasswordsIDs returns the "passwords" edge IDs in the mutation.
func (m *UserMutation) PasswordsIDs() (ids []int) {
	for id := range m.passwords {
		ids = append(ids, id)
	}
	return
}

// ResetPasswords resets all changes to the "passwords" edge.
func (m *UserMutation) ResetPasswords() {
	m.passwords = nil
	m.clearedpasswords = false
	m.removedpasswords = nil
}

// AddDeviceIDs adds the "devices" edge to the UserDevice entity by ids.
func (m *UserMutation) AddDeviceIDs(ids ...int) {
	if m.devices == nil {
		m.devices = make(map[int]struct{})
	}
	for i := range ids {
		m.devices[ids[i]] = struct{}{}
	}
}

// ClearDevices clears the "devices" edge to the UserDevice entity.
func (m *UserMutation) ClearDevices() {
	m.cleareddevices = true
}

// DevicesCleared reports if the "devices" edge to the UserDevice entity was cleared.
func (m *UserMutation) DevicesCleared() bool {
	return m.cleareddevices
}

// RemoveDeviceIDs removes the "devices" edge to the UserDevice entity by IDs.
func (m *UserMutation) RemoveDeviceIDs(ids ...int) {
	if m.removeddevices == nil {
		m.removeddevices = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.devices, ids[i])
		m.removeddevices[ids[i]] = struct{}{}
	}
}

// RemovedDevices returns the removed IDs of the "devices" edge to the UserDevice entity.
func (m *UserMutation) RemovedDevicesIDs() (ids []int) {
	for id := range m.removeddevices {
		ids = append(ids, id)
	}
	return
}

// DevicesIDs returns the "devices" edge IDs in the mutation.
func (m *UserMutation) DevicesIDs() (ids []int) {
	for id := range m.devices {
		ids = append(ids, id)
	}
	return
}

// ResetDevices resets all changes to the "devices" edge.
func (m *UserMutation) ResetDevices() {
	m.devices = nil
	m.cleareddevices = false
	m.removeddevices = nil
}

// AddOrgIDs adds the "orgs" edge to the Org entity by ids.
func (m *UserMutation) AddOrgIDs(ids ...int) {
	if m.orgs == nil {
		m.orgs = make(map[int]struct{})
	}
	for i := range ids {
		m.orgs[ids[i]] = struct{}{}
	}
}

// ClearOrgs clears the "orgs" edge to the Org entity.
func (m *UserMutation) ClearOrgs() {
	m.clearedorgs = true
}

// OrgsCleared reports if the "orgs" edge to the Org entity was cleared.
func (m *UserMutation) OrgsCleared() bool {
	return m.clearedorgs
}

// RemoveOrgIDs removes the "orgs" edge to the Org entity by IDs.
func (m *UserMutation) RemoveOrgIDs(ids ...int) {
	if m.removedorgs == nil {
		m.removedorgs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.orgs, ids[i])
		m.removedorgs[ids[i]] = struct{}{}
	}
}

// RemovedOrgs returns the removed IDs of the "orgs" edge to the Org entity.
func (m *UserMutation) RemovedOrgsIDs() (ids []int) {
	for id := range m.removedorgs {
		ids = append(ids, id)
	}
	return
}

// OrgsIDs returns the "orgs" edge IDs in the mutation.
func (m *UserMutation) OrgsIDs() (ids []int) {
	for id := range m.orgs {
		ids = append(ids, id)
	}
	return
}

// ResetOrgs resets all changes to the "orgs" edge.
func (m *UserMutation) ResetOrgs() {
	m.orgs = nil
	m.clearedorgs = false
	m.removedorgs = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *UserMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *UserMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *UserMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *UserMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *UserMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *UserMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *UserMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddOauthClientIDs adds the "oauth_clients" edge to the OauthClient entity by ids.
func (m *UserMutation) AddOauthClientIDs(ids ...int) {
	if m.oauth_clients == nil {
		m.oauth_clients = make(map[int]struct{})
	}
	for i := range ids {
		m.oauth_clients[ids[i]] = struct{}{}
	}
}

// ClearOauthClients clears the "oauth_clients" edge to the OauthClient entity.
func (m *UserMutation) ClearOauthClients() {
	m.clearedoauth_clients = true
}

// OauthClientsCleared reports if the "oauth_clients" edge to the OauthClient entity was cleared.
func (m *UserMutation) OauthClientsCleared() bool {
	return m.clearedoauth_clients
}

// RemoveOauthClientIDs removes the "oauth_clients" edge to the OauthClient entity by IDs.
func (m *UserMutation) RemoveOauthClientIDs(ids ...int) {
	if m.removedoauth_clients == nil {
		m.removedoauth_clients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.oauth_clients, ids[i])
		m.removedoauth_clients[ids[i]] = struct{}{}
	}
}

// RemovedOauthClients returns the removed IDs of the "oauth_clients" edge to the OauthClient entity.
func (m *UserMutation) RemovedOauthClientsIDs() (ids []int) {
	for id := range m.removedoauth_clients {
		ids = append(ids, id)
	}
	return
}

// OauthClientsIDs returns the "oauth_clients" edge IDs in the mutation.
func (m *UserMutation) OauthClientsIDs() (ids []int) {
	for id := range m.oauth_clients {
		ids = append(ids, id)
	}
	return
}

// ResetOauthClients resets all changes to the "oauth_clients" edge.
func (m *UserMutation) ResetOauthClients() {
	m.oauth_clients = nil
	m.clearedoauth_clients = false
	m.removedoauth_clients = nil
}

// AddOrgUserIDs adds the "org_user" edge to the OrgUser entity by ids.
func (m *UserMutation) AddOrgUserIDs(ids ...int) {
	if m.org_user == nil {
		m.org_user = make(map[int]struct{})
	}
	for i := range ids {
		m.org_user[ids[i]] = struct{}{}
	}
}

// ClearOrgUser clears the "org_user" edge to the OrgUser entity.
func (m *UserMutation) ClearOrgUser() {
	m.clearedorg_user = true
}

// OrgUserCleared reports if the "org_user" edge to the OrgUser entity was cleared.
func (m *UserMutation) OrgUserCleared() bool {
	return m.clearedorg_user
}

// RemoveOrgUserIDs removes the "org_user" edge to the OrgUser entity by IDs.
func (m *UserMutation) RemoveOrgUserIDs(ids ...int) {
	if m.removedorg_user == nil {
		m.removedorg_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_user, ids[i])
		m.removedorg_user[ids[i]] = struct{}{}
	}
}

// RemovedOrgUser returns the removed IDs of the "org_user" edge to the OrgUser entity.
func (m *UserMutation) RemovedOrgUserIDs() (ids []int) {
	for id := range m.removedorg_user {
		ids = append(ids, id)
	}
	return
}

// OrgUserIDs returns the "org_user" edge IDs in the mutation.
func (m *UserMutation) OrgUserIDs() (ids []int) {
	for id := range m.org_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrgUser resets all changes to the "org_user" edge.
func (m *UserMutation) ResetOrgUser() {
	m.org_user = nil
	m.clearedorg_user = false
	m.removedorg_user = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.principal_name != nil {
		fields = append(fields, user.FieldPrincipalName)
	}
	if m.display_name != nil {
		fields = append(fields, user.FieldDisplayName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.user_type != nil {
		fields = append(fields, user.FieldUserType)
	}
	if m.creation_type != nil {
		fields = append(fields, user.FieldCreationType)
	}
	if m.register_ip != nil {
		fields = append(fields, user.FieldRegisterIP)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.comments != nil {
		fields = append(fields, user.FieldComments)
	}
	if m.avatar_file_id != nil {
		fields = append(fields, user.FieldAvatarFileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldPrincipalName:
		return m.PrincipalName()
	case user.FieldDisplayName:
		return m.DisplayName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldUserType:
		return m.UserType()
	case user.FieldCreationType:
		return m.CreationType()
	case user.FieldRegisterIP:
		return m.RegisterIP()
	case user.FieldStatus:
		return m.Status()
	case user.FieldComments:
		return m.Comments()
	case user.FieldAvatarFileID:
		return m.AvatarFileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldPrincipalName:
		return m.OldPrincipalName(ctx)
	case user.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldUserType:
		return m.OldUserType(ctx)
	case user.FieldCreationType:
		return m.OldCreationType(ctx)
	case user.FieldRegisterIP:
		return m.OldRegisterIP(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldComments:
		return m.OldComments(ctx)
	case user.FieldAvatarFileID:
		return m.OldAvatarFileID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldPrincipalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrincipalName(v)
		return nil
	case user.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldUserType:
		v, ok := value.(user.UserType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserType(v)
		return nil
	case user.FieldCreationType:
		v, ok := value.(user.CreationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationType(v)
		return nil
	case user.FieldRegisterIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterIP(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case user.FieldAvatarFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarFileID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.addavatar_file_id != nil {
		fields = append(fields, user.FieldAvatarFileID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case user.FieldAvatarFileID:
		return m.AddedAvatarFileID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case user.FieldAvatarFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvatarFileID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUpdatedBy) {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldMobile) {
		fields = append(fields, user.FieldMobile)
	}
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldComments) {
		fields = append(fields, user.FieldComments)
	}
	if m.FieldCleared(user.FieldAvatarFileID) {
		fields = append(fields, user.FieldAvatarFileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldMobile:
		m.ClearMobile()
		return nil
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldComments:
		m.ClearComments()
		return nil
	case user.FieldAvatarFileID:
		m.ClearAvatarFileID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldPrincipalName:
		m.ResetPrincipalName()
		return nil
	case user.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldUserType:
		m.ResetUserType()
		return nil
	case user.FieldCreationType:
		m.ResetCreationType()
		return nil
	case user.FieldRegisterIP:
		m.ResetRegisterIP()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldComments:
		m.ResetComments()
		return nil
	case user.FieldAvatarFileID:
		m.ResetAvatarFileID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.identities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.login_profile != nil {
		edges = append(edges, user.EdgeLoginProfile)
	}
	if m.passwords != nil {
		edges = append(edges, user.EdgePasswords)
	}
	if m.devices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.orgs != nil {
		edges = append(edges, user.EdgeOrgs)
	}
	if m.permissions != nil {
		edges = append(edges, user.EdgePermissions)
	}
	if m.oauth_clients != nil {
		edges = append(edges, user.EdgeOauthClients)
	}
	if m.org_user != nil {
		edges = append(edges, user.EdgeOrgUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.identities))
		for id := range m.identities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLoginProfile:
		if id := m.login_profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.passwords))
		for id := range m.passwords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.devices))
		for id := range m.devices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrgs:
		ids := make([]ent.Value, 0, len(m.orgs))
		for id := range m.orgs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthClients:
		ids := make([]ent.Value, 0, len(m.oauth_clients))
		for id := range m.oauth_clients {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrgUser:
		ids := make([]ent.Value, 0, len(m.org_user))
		for id := range m.org_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedidentities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.removedpasswords != nil {
		edges = append(edges, user.EdgePasswords)
	}
	if m.removeddevices != nil {
		edges = append(edges, user.EdgeDevices)
	}
	if m.removedorgs != nil {
		edges = append(edges, user.EdgeOrgs)
	}
	if m.removedpermissions != nil {
		edges = append(edges, user.EdgePermissions)
	}
	if m.removedoauth_clients != nil {
		edges = append(edges, user.EdgeOauthClients)
	}
	if m.removedorg_user != nil {
		edges = append(edges, user.EdgeOrgUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removedidentities))
		for id := range m.removedidentities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePasswords:
		ids := make([]ent.Value, 0, len(m.removedpasswords))
		for id := range m.removedpasswords {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevices:
		ids := make([]ent.Value, 0, len(m.removeddevices))
		for id := range m.removeddevices {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrgs:
		ids := make([]ent.Value, 0, len(m.removedorgs))
		for id := range m.removedorgs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOauthClients:
		ids := make([]ent.Value, 0, len(m.removedoauth_clients))
		for id := range m.removedoauth_clients {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrgUser:
		ids := make([]ent.Value, 0, len(m.removedorg_user))
		for id := range m.removedorg_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedidentities {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.clearedlogin_profile {
		edges = append(edges, user.EdgeLoginProfile)
	}
	if m.clearedpasswords {
		edges = append(edges, user.EdgePasswords)
	}
	if m.cleareddevices {
		edges = append(edges, user.EdgeDevices)
	}
	if m.clearedorgs {
		edges = append(edges, user.EdgeOrgs)
	}
	if m.clearedpermissions {
		edges = append(edges, user.EdgePermissions)
	}
	if m.clearedoauth_clients {
		edges = append(edges, user.EdgeOauthClients)
	}
	if m.clearedorg_user {
		edges = append(edges, user.EdgeOrgUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeIdentities:
		return m.clearedidentities
	case user.EdgeLoginProfile:
		return m.clearedlogin_profile
	case user.EdgePasswords:
		return m.clearedpasswords
	case user.EdgeDevices:
		return m.cleareddevices
	case user.EdgeOrgs:
		return m.clearedorgs
	case user.EdgePermissions:
		return m.clearedpermissions
	case user.EdgeOauthClients:
		return m.clearedoauth_clients
	case user.EdgeOrgUser:
		return m.clearedorg_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeLoginProfile:
		m.ClearLoginProfile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case user.EdgeLoginProfile:
		m.ResetLoginProfile()
		return nil
	case user.EdgePasswords:
		m.ResetPasswords()
		return nil
	case user.EdgeDevices:
		m.ResetDevices()
		return nil
	case user.EdgeOrgs:
		m.ResetOrgs()
		return nil
	case user.EdgePermissions:
		m.ResetPermissions()
		return nil
	case user.EdgeOauthClients:
		m.ResetOauthClients()
		return nil
	case user.EdgeOrgUser:
		m.ResetOrgUser()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserDeviceMutation represents an operation that mutates the UserDevice nodes in the graph.
type UserDeviceMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_by     *int
	addcreated_by  *int
	created_at     *time.Time
	updated_by     *int
	addupdated_by  *int
	updated_at     *time.Time
	device_uid     *string
	device_name    *string
	system_name    *string
	system_version *string
	app_version    *string
	device_model   *string
	status         *typex.SimpleStatus
	comments       *string
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserDevice, error)
	predicates     []predicate.UserDevice
}

var _ ent.Mutation = (*UserDeviceMutation)(nil)

// userdeviceOption allows management of the mutation configuration using functional options.
type userdeviceOption func(*UserDeviceMutation)

// newUserDeviceMutation creates new mutation for the UserDevice entity.
func newUserDeviceMutation(c config, op Op, opts ...userdeviceOption) *UserDeviceMutation {
	m := &UserDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDeviceID sets the ID field of the mutation.
func withUserDeviceID(id int) userdeviceOption {
	return func(m *UserDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDevice
		)
		m.oldValue = func(ctx context.Context) (*UserDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDevice sets the old UserDevice of the mutation.
func withUserDevice(node *UserDevice) userdeviceOption {
	return func(m *UserDeviceMutation) {
		m.oldValue = func(context.Context) (*UserDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserDevice entities.
func (m *UserDeviceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserDeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserDeviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserDeviceMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserDeviceMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserDeviceMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserDeviceMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserDeviceMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserDeviceMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserDeviceMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserDeviceMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserDeviceMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserDeviceMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userdevice.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserDeviceMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserDeviceMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userdevice.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserDeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserDeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserDeviceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userdevice.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserDeviceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserDeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userdevice.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserDeviceMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserDeviceMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserDeviceMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userdevice.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserDeviceMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserDeviceMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userdevice.FieldUserID)
}

// SetDeviceUID sets the "device_uid" field.
func (m *UserDeviceMutation) SetDeviceUID(s string) {
	m.device_uid = &s
}

// DeviceUID returns the value of the "device_uid" field in the mutation.
func (m *UserDeviceMutation) DeviceUID() (r string, exists bool) {
	v := m.device_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceUID returns the old "device_uid" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceUID: %w", err)
	}
	return oldValue.DeviceUID, nil
}

// ResetDeviceUID resets all changes to the "device_uid" field.
func (m *UserDeviceMutation) ResetDeviceUID() {
	m.device_uid = nil
}

// SetDeviceName sets the "device_name" field.
func (m *UserDeviceMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *UserDeviceMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ClearDeviceName clears the value of the "device_name" field.
func (m *UserDeviceMutation) ClearDeviceName() {
	m.device_name = nil
	m.clearedFields[userdevice.FieldDeviceName] = struct{}{}
}

// DeviceNameCleared returns if the "device_name" field was cleared in this mutation.
func (m *UserDeviceMutation) DeviceNameCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldDeviceName]
	return ok
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *UserDeviceMutation) ResetDeviceName() {
	m.device_name = nil
	delete(m.clearedFields, userdevice.FieldDeviceName)
}

// SetSystemName sets the "system_name" field.
func (m *UserDeviceMutation) SetSystemName(s string) {
	m.system_name = &s
}

// SystemName returns the value of the "system_name" field in the mutation.
func (m *UserDeviceMutation) SystemName() (r string, exists bool) {
	v := m.system_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemName returns the old "system_name" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldSystemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemName: %w", err)
	}
	return oldValue.SystemName, nil
}

// ClearSystemName clears the value of the "system_name" field.
func (m *UserDeviceMutation) ClearSystemName() {
	m.system_name = nil
	m.clearedFields[userdevice.FieldSystemName] = struct{}{}
}

// SystemNameCleared returns if the "system_name" field was cleared in this mutation.
func (m *UserDeviceMutation) SystemNameCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldSystemName]
	return ok
}

// ResetSystemName resets all changes to the "system_name" field.
func (m *UserDeviceMutation) ResetSystemName() {
	m.system_name = nil
	delete(m.clearedFields, userdevice.FieldSystemName)
}

// SetSystemVersion sets the "system_version" field.
func (m *UserDeviceMutation) SetSystemVersion(s string) {
	m.system_version = &s
}

// SystemVersion returns the value of the "system_version" field in the mutation.
func (m *UserDeviceMutation) SystemVersion() (r string, exists bool) {
	v := m.system_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemVersion returns the old "system_version" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldSystemVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemVersion: %w", err)
	}
	return oldValue.SystemVersion, nil
}

// ClearSystemVersion clears the value of the "system_version" field.
func (m *UserDeviceMutation) ClearSystemVersion() {
	m.system_version = nil
	m.clearedFields[userdevice.FieldSystemVersion] = struct{}{}
}

// SystemVersionCleared returns if the "system_version" field was cleared in this mutation.
func (m *UserDeviceMutation) SystemVersionCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldSystemVersion]
	return ok
}

// ResetSystemVersion resets all changes to the "system_version" field.
func (m *UserDeviceMutation) ResetSystemVersion() {
	m.system_version = nil
	delete(m.clearedFields, userdevice.FieldSystemVersion)
}

// SetAppVersion sets the "app_version" field.
func (m *UserDeviceMutation) SetAppVersion(s string) {
	m.app_version = &s
}

// AppVersion returns the value of the "app_version" field in the mutation.
func (m *UserDeviceMutation) AppVersion() (r string, exists bool) {
	v := m.app_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAppVersion returns the old "app_version" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldAppVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppVersion: %w", err)
	}
	return oldValue.AppVersion, nil
}

// ClearAppVersion clears the value of the "app_version" field.
func (m *UserDeviceMutation) ClearAppVersion() {
	m.app_version = nil
	m.clearedFields[userdevice.FieldAppVersion] = struct{}{}
}

// AppVersionCleared returns if the "app_version" field was cleared in this mutation.
func (m *UserDeviceMutation) AppVersionCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldAppVersion]
	return ok
}

// ResetAppVersion resets all changes to the "app_version" field.
func (m *UserDeviceMutation) ResetAppVersion() {
	m.app_version = nil
	delete(m.clearedFields, userdevice.FieldAppVersion)
}

// SetDeviceModel sets the "device_model" field.
func (m *UserDeviceMutation) SetDeviceModel(s string) {
	m.device_model = &s
}

// DeviceModel returns the value of the "device_model" field in the mutation.
func (m *UserDeviceMutation) DeviceModel() (r string, exists bool) {
	v := m.device_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceModel returns the old "device_model" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceModel: %w", err)
	}
	return oldValue.DeviceModel, nil
}

// ClearDeviceModel clears the value of the "device_model" field.
func (m *UserDeviceMutation) ClearDeviceModel() {
	m.device_model = nil
	m.clearedFields[userdevice.FieldDeviceModel] = struct{}{}
}

// DeviceModelCleared returns if the "device_model" field was cleared in this mutation.
func (m *UserDeviceMutation) DeviceModelCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldDeviceModel]
	return ok
}

// ResetDeviceModel resets all changes to the "device_model" field.
func (m *UserDeviceMutation) ResetDeviceModel() {
	m.device_model = nil
	delete(m.clearedFields, userdevice.FieldDeviceModel)
}

// SetStatus sets the "status" field.
func (m *UserDeviceMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *UserDeviceMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserDeviceMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[userdevice.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserDeviceMutation) StatusCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserDeviceMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, userdevice.FieldStatus)
}

// SetComments sets the "comments" field.
func (m *UserDeviceMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *UserDeviceMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *UserDeviceMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[userdevice.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *UserDeviceMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[userdevice.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *UserDeviceMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, userdevice.FieldComments)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserDeviceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserDeviceMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserDeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserDeviceMutation builder.
func (m *UserDeviceMutation) Where(ps ...predicate.UserDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserDevice).
func (m *UserDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserDeviceMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userdevice.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userdevice.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.device_uid != nil {
		fields = append(fields, userdevice.FieldDeviceUID)
	}
	if m.device_name != nil {
		fields = append(fields, userdevice.FieldDeviceName)
	}
	if m.system_name != nil {
		fields = append(fields, userdevice.FieldSystemName)
	}
	if m.system_version != nil {
		fields = append(fields, userdevice.FieldSystemVersion)
	}
	if m.app_version != nil {
		fields = append(fields, userdevice.FieldAppVersion)
	}
	if m.device_model != nil {
		fields = append(fields, userdevice.FieldDeviceModel)
	}
	if m.status != nil {
		fields = append(fields, userdevice.FieldStatus)
	}
	if m.comments != nil {
		fields = append(fields, userdevice.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.CreatedBy()
	case userdevice.FieldCreatedAt:
		return m.CreatedAt()
	case userdevice.FieldUpdatedBy:
		return m.UpdatedBy()
	case userdevice.FieldUpdatedAt:
		return m.UpdatedAt()
	case userdevice.FieldUserID:
		return m.UserID()
	case userdevice.FieldDeviceUID:
		return m.DeviceUID()
	case userdevice.FieldDeviceName:
		return m.DeviceName()
	case userdevice.FieldSystemName:
		return m.SystemName()
	case userdevice.FieldSystemVersion:
		return m.SystemVersion()
	case userdevice.FieldAppVersion:
		return m.AppVersion()
	case userdevice.FieldDeviceModel:
		return m.DeviceModel()
	case userdevice.FieldStatus:
		return m.Status()
	case userdevice.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userdevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userdevice.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userdevice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userdevice.FieldUserID:
		return m.OldUserID(ctx)
	case userdevice.FieldDeviceUID:
		return m.OldDeviceUID(ctx)
	case userdevice.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case userdevice.FieldSystemName:
		return m.OldSystemName(ctx)
	case userdevice.FieldSystemVersion:
		return m.OldSystemVersion(ctx)
	case userdevice.FieldAppVersion:
		return m.OldAppVersion(ctx)
	case userdevice.FieldDeviceModel:
		return m.OldDeviceModel(ctx)
	case userdevice.FieldStatus:
		return m.OldStatus(ctx)
	case userdevice.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown UserDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userdevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userdevice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userdevice.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userdevice.FieldDeviceUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceUID(v)
		return nil
	case userdevice.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case userdevice.FieldSystemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemName(v)
		return nil
	case userdevice.FieldSystemVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemVersion(v)
		return nil
	case userdevice.FieldAppVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppVersion(v)
		return nil
	case userdevice.FieldDeviceModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceModel(v)
		return nil
	case userdevice.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case userdevice.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserDeviceMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userdevice.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserDeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userdevice.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userdevice.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserDeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userdevice.FieldUpdatedBy) {
		fields = append(fields, userdevice.FieldUpdatedBy)
	}
	if m.FieldCleared(userdevice.FieldUpdatedAt) {
		fields = append(fields, userdevice.FieldUpdatedAt)
	}
	if m.FieldCleared(userdevice.FieldUserID) {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.FieldCleared(userdevice.FieldDeviceName) {
		fields = append(fields, userdevice.FieldDeviceName)
	}
	if m.FieldCleared(userdevice.FieldSystemName) {
		fields = append(fields, userdevice.FieldSystemName)
	}
	if m.FieldCleared(userdevice.FieldSystemVersion) {
		fields = append(fields, userdevice.FieldSystemVersion)
	}
	if m.FieldCleared(userdevice.FieldAppVersion) {
		fields = append(fields, userdevice.FieldAppVersion)
	}
	if m.FieldCleared(userdevice.FieldDeviceModel) {
		fields = append(fields, userdevice.FieldDeviceModel)
	}
	if m.FieldCleared(userdevice.FieldStatus) {
		fields = append(fields, userdevice.FieldStatus)
	}
	if m.FieldCleared(userdevice.FieldComments) {
		fields = append(fields, userdevice.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDeviceMutation) ClearField(name string) error {
	switch name {
	case userdevice.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userdevice.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userdevice.FieldUserID:
		m.ClearUserID()
		return nil
	case userdevice.FieldDeviceName:
		m.ClearDeviceName()
		return nil
	case userdevice.FieldSystemName:
		m.ClearSystemName()
		return nil
	case userdevice.FieldSystemVersion:
		m.ClearSystemVersion()
		return nil
	case userdevice.FieldAppVersion:
		m.ClearAppVersion()
		return nil
	case userdevice.FieldDeviceModel:
		m.ClearDeviceModel()
		return nil
	case userdevice.FieldStatus:
		m.ClearStatus()
		return nil
	case userdevice.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown UserDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserDeviceMutation) ResetField(name string) error {
	switch name {
	case userdevice.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userdevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userdevice.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userdevice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userdevice.FieldUserID:
		m.ResetUserID()
		return nil
	case userdevice.FieldDeviceUID:
		m.ResetDeviceUID()
		return nil
	case userdevice.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case userdevice.FieldSystemName:
		m.ResetSystemName()
		return nil
	case userdevice.FieldSystemVersion:
		m.ResetSystemVersion()
		return nil
	case userdevice.FieldAppVersion:
		m.ResetAppVersion()
		return nil
	case userdevice.FieldDeviceModel:
		m.ResetDeviceModel()
		return nil
	case userdevice.FieldStatus:
		m.ResetStatus()
		return nil
	case userdevice.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userdevice.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userdevice.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserDeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userdevice.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case userdevice.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserDeviceMutation) ClearEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserDeviceMutation) ResetEdge(name string) error {
	switch name {
	case userdevice.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserDevice edge %s", name)
}

// UserIdentityMutation represents an operation that mutates the UserIdentity nodes in the graph.
type UserIdentityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	kind          *useridentity.Kind
	code          *string
	code_extend   *string
	status        *typex.SimpleStatus
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserIdentity, error)
	predicates    []predicate.UserIdentity
}

var _ ent.Mutation = (*UserIdentityMutation)(nil)

// useridentityOption allows management of the mutation configuration using functional options.
type useridentityOption func(*UserIdentityMutation)

// newUserIdentityMutation creates new mutation for the UserIdentity entity.
func newUserIdentityMutation(c config, op Op, opts ...useridentityOption) *UserIdentityMutation {
	m := &UserIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserIdentityID sets the ID field of the mutation.
func withUserIdentityID(id int) useridentityOption {
	return func(m *UserIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserIdentity
		)
		m.oldValue = func(ctx context.Context) (*UserIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserIdentity sets the old UserIdentity of the mutation.
func withUserIdentity(node *UserIdentity) useridentityOption {
	return func(m *UserIdentityMutation) {
		m.oldValue = func(context.Context) (*UserIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserIdentity entities.
func (m *UserIdentityMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserIdentityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserIdentityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserIdentityMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserIdentityMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserIdentityMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserIdentityMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserIdentityMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserIdentityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserIdentityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserIdentityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserIdentityMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserIdentityMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserIdentityMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserIdentityMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserIdentityMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[useridentity.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserIdentityMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserIdentityMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, useridentity.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserIdentityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserIdentityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserIdentityMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[useridentity.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserIdentityMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserIdentityMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, useridentity.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserIdentityMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserIdentityMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserIdentityMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[useridentity.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserIdentityMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserIdentityMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, useridentity.FieldUserID)
}

// SetKind sets the "kind" field.
func (m *UserIdentityMutation) SetKind(u useridentity.Kind) {
	m.kind = &u
}

// Kind returns the value of the "kind" field in the mutation.
func (m *UserIdentityMutation) Kind() (r useridentity.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldKind(ctx context.Context) (v useridentity.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *UserIdentityMutation) ResetKind() {
	m.kind = nil
}

// SetCode sets the "code" field.
func (m *UserIdentityMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *UserIdentityMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *UserIdentityMutation) ClearCode() {
	m.code = nil
	m.clearedFields[useridentity.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *UserIdentityMutation) CodeCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *UserIdentityMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, useridentity.FieldCode)
}

// SetCodeExtend sets the "code_extend" field.
func (m *UserIdentityMutation) SetCodeExtend(s string) {
	m.code_extend = &s
}

// CodeExtend returns the value of the "code_extend" field in the mutation.
func (m *UserIdentityMutation) CodeExtend() (r string, exists bool) {
	v := m.code_extend
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeExtend returns the old "code_extend" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCodeExtend(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeExtend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeExtend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeExtend: %w", err)
	}
	return oldValue.CodeExtend, nil
}

// ClearCodeExtend clears the value of the "code_extend" field.
func (m *UserIdentityMutation) ClearCodeExtend() {
	m.code_extend = nil
	m.clearedFields[useridentity.FieldCodeExtend] = struct{}{}
}

// CodeExtendCleared returns if the "code_extend" field was cleared in this mutation.
func (m *UserIdentityMutation) CodeExtendCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldCodeExtend]
	return ok
}

// ResetCodeExtend resets all changes to the "code_extend" field.
func (m *UserIdentityMutation) ResetCodeExtend() {
	m.code_extend = nil
	delete(m.clearedFields, useridentity.FieldCodeExtend)
}

// SetStatus sets the "status" field.
func (m *UserIdentityMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *UserIdentityMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserIdentityMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[useridentity.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserIdentityMutation) StatusCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserIdentityMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, useridentity.FieldStatus)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserIdentityMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserIdentityMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserIdentityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserIdentityMutation builder.
func (m *UserIdentityMutation) Where(ps ...predicate.UserIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserIdentity).
func (m *UserIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserIdentityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, useridentity.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, useridentity.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, useridentity.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, useridentity.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.kind != nil {
		fields = append(fields, useridentity.FieldKind)
	}
	if m.code != nil {
		fields = append(fields, useridentity.FieldCode)
	}
	if m.code_extend != nil {
		fields = append(fields, useridentity.FieldCodeExtend)
	}
	if m.status != nil {
		fields = append(fields, useridentity.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useridentity.FieldCreatedBy:
		return m.CreatedBy()
	case useridentity.FieldCreatedAt:
		return m.CreatedAt()
	case useridentity.FieldUpdatedBy:
		return m.UpdatedBy()
	case useridentity.FieldUpdatedAt:
		return m.UpdatedAt()
	case useridentity.FieldUserID:
		return m.UserID()
	case useridentity.FieldKind:
		return m.Kind()
	case useridentity.FieldCode:
		return m.Code()
	case useridentity.FieldCodeExtend:
		return m.CodeExtend()
	case useridentity.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useridentity.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case useridentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case useridentity.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case useridentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case useridentity.FieldUserID:
		return m.OldUserID(ctx)
	case useridentity.FieldKind:
		return m.OldKind(ctx)
	case useridentity.FieldCode:
		return m.OldCode(ctx)
	case useridentity.FieldCodeExtend:
		return m.OldCodeExtend(ctx)
	case useridentity.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useridentity.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case useridentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useridentity.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case useridentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case useridentity.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useridentity.FieldKind:
		v, ok := value.(useridentity.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case useridentity.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case useridentity.FieldCodeExtend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeExtend(v)
		return nil
	case useridentity.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserIdentityMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, useridentity.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, useridentity.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserIdentityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case useridentity.FieldCreatedBy:
		return m.AddedCreatedBy()
	case useridentity.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case useridentity.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case useridentity.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserIdentityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useridentity.FieldUpdatedBy) {
		fields = append(fields, useridentity.FieldUpdatedBy)
	}
	if m.FieldCleared(useridentity.FieldUpdatedAt) {
		fields = append(fields, useridentity.FieldUpdatedAt)
	}
	if m.FieldCleared(useridentity.FieldUserID) {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.FieldCleared(useridentity.FieldCode) {
		fields = append(fields, useridentity.FieldCode)
	}
	if m.FieldCleared(useridentity.FieldCodeExtend) {
		fields = append(fields, useridentity.FieldCodeExtend)
	}
	if m.FieldCleared(useridentity.FieldStatus) {
		fields = append(fields, useridentity.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserIdentityMutation) ClearField(name string) error {
	switch name {
	case useridentity.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case useridentity.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case useridentity.FieldUserID:
		m.ClearUserID()
		return nil
	case useridentity.FieldCode:
		m.ClearCode()
		return nil
	case useridentity.FieldCodeExtend:
		m.ClearCodeExtend()
		return nil
	case useridentity.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserIdentityMutation) ResetField(name string) error {
	switch name {
	case useridentity.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case useridentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useridentity.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case useridentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case useridentity.FieldUserID:
		m.ResetUserID()
		return nil
	case useridentity.FieldKind:
		m.ResetKind()
		return nil
	case useridentity.FieldCode:
		m.ResetCode()
		return nil
	case useridentity.FieldCodeExtend:
		m.ResetCodeExtend()
		return nil
	case useridentity.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useridentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserIdentityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case useridentity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserIdentityMutation) ClearEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserIdentityMutation) ResetEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity edge %s", name)
}

// UserLoginProfileMutation represents an operation that mutates the UserLoginProfile nodes in the graph.
type UserLoginProfileMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_by     *int
	addcreated_by  *int
	created_at     *time.Time
	updated_by     *int
	addupdated_by  *int
	updated_at     *time.Time
	last_login_ip  *string
	last_login_at  *time.Time
	can_login      *bool
	set_kind       *userloginprofile.SetKind
	password_reset *bool
	verify_device  *bool
	mfa_enabled    *bool
	mfa_secret     *string
	mfa_status     *typex.SimpleStatus
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserLoginProfile, error)
	predicates     []predicate.UserLoginProfile
}

var _ ent.Mutation = (*UserLoginProfileMutation)(nil)

// userloginprofileOption allows management of the mutation configuration using functional options.
type userloginprofileOption func(*UserLoginProfileMutation)

// newUserLoginProfileMutation creates new mutation for the UserLoginProfile entity.
func newUserLoginProfileMutation(c config, op Op, opts ...userloginprofileOption) *UserLoginProfileMutation {
	m := &UserLoginProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLoginProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginProfileID sets the ID field of the mutation.
func withUserLoginProfileID(id int) userloginprofileOption {
	return func(m *UserLoginProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLoginProfile
		)
		m.oldValue = func(ctx context.Context) (*UserLoginProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLoginProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLoginProfile sets the old UserLoginProfile of the mutation.
func withUserLoginProfile(node *UserLoginProfile) userloginprofileOption {
	return func(m *UserLoginProfileMutation) {
		m.oldValue = func(context.Context) (*UserLoginProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserLoginProfile entities.
func (m *UserLoginProfileMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLoginProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLoginProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLoginProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserLoginProfileMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserLoginProfileMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserLoginProfileMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserLoginProfileMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserLoginProfileMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserLoginProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserLoginProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserLoginProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserLoginProfileMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserLoginProfileMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserLoginProfileMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserLoginProfileMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserLoginProfileMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userloginprofile.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserLoginProfileMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserLoginProfileMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userloginprofile.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserLoginProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserLoginProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserLoginProfileMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userloginprofile.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserLoginProfileMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserLoginProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userloginprofile.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserLoginProfileMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserLoginProfileMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserLoginProfileMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userloginprofile.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserLoginProfileMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserLoginProfileMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userloginprofile.FieldUserID)
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *UserLoginProfileMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *UserLoginProfileMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldLastLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *UserLoginProfileMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[userloginprofile.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *UserLoginProfileMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *UserLoginProfileMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, userloginprofile.FieldLastLoginIP)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserLoginProfileMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserLoginProfileMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserLoginProfileMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[userloginprofile.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserLoginProfileMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserLoginProfileMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, userloginprofile.FieldLastLoginAt)
}

// SetCanLogin sets the "can_login" field.
func (m *UserLoginProfileMutation) SetCanLogin(b bool) {
	m.can_login = &b
}

// CanLogin returns the value of the "can_login" field in the mutation.
func (m *UserLoginProfileMutation) CanLogin() (r bool, exists bool) {
	v := m.can_login
	if v == nil {
		return
	}
	return *v, true
}

// OldCanLogin returns the old "can_login" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldCanLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanLogin: %w", err)
	}
	return oldValue.CanLogin, nil
}

// ClearCanLogin clears the value of the "can_login" field.
func (m *UserLoginProfileMutation) ClearCanLogin() {
	m.can_login = nil
	m.clearedFields[userloginprofile.FieldCanLogin] = struct{}{}
}

// CanLoginCleared returns if the "can_login" field was cleared in this mutation.
func (m *UserLoginProfileMutation) CanLoginCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldCanLogin]
	return ok
}

// ResetCanLogin resets all changes to the "can_login" field.
func (m *UserLoginProfileMutation) ResetCanLogin() {
	m.can_login = nil
	delete(m.clearedFields, userloginprofile.FieldCanLogin)
}

// SetSetKind sets the "set_kind" field.
func (m *UserLoginProfileMutation) SetSetKind(uk userloginprofile.SetKind) {
	m.set_kind = &uk
}

// SetKind returns the value of the "set_kind" field in the mutation.
func (m *UserLoginProfileMutation) SetKind() (r userloginprofile.SetKind, exists bool) {
	v := m.set_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldSetKind returns the old "set_kind" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldSetKind(ctx context.Context) (v userloginprofile.SetKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetKind: %w", err)
	}
	return oldValue.SetKind, nil
}

// ResetSetKind resets all changes to the "set_kind" field.
func (m *UserLoginProfileMutation) ResetSetKind() {
	m.set_kind = nil
}

// SetPasswordReset sets the "password_reset" field.
func (m *UserLoginProfileMutation) SetPasswordReset(b bool) {
	m.password_reset = &b
}

// PasswordReset returns the value of the "password_reset" field in the mutation.
func (m *UserLoginProfileMutation) PasswordReset() (r bool, exists bool) {
	v := m.password_reset
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordReset returns the old "password_reset" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldPasswordReset(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordReset is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordReset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordReset: %w", err)
	}
	return oldValue.PasswordReset, nil
}

// ClearPasswordReset clears the value of the "password_reset" field.
func (m *UserLoginProfileMutation) ClearPasswordReset() {
	m.password_reset = nil
	m.clearedFields[userloginprofile.FieldPasswordReset] = struct{}{}
}

// PasswordResetCleared returns if the "password_reset" field was cleared in this mutation.
func (m *UserLoginProfileMutation) PasswordResetCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldPasswordReset]
	return ok
}

// ResetPasswordReset resets all changes to the "password_reset" field.
func (m *UserLoginProfileMutation) ResetPasswordReset() {
	m.password_reset = nil
	delete(m.clearedFields, userloginprofile.FieldPasswordReset)
}

// SetVerifyDevice sets the "verify_device" field.
func (m *UserLoginProfileMutation) SetVerifyDevice(b bool) {
	m.verify_device = &b
}

// VerifyDevice returns the value of the "verify_device" field in the mutation.
func (m *UserLoginProfileMutation) VerifyDevice() (r bool, exists bool) {
	v := m.verify_device
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyDevice returns the old "verify_device" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldVerifyDevice(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifyDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifyDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyDevice: %w", err)
	}
	return oldValue.VerifyDevice, nil
}

// ResetVerifyDevice resets all changes to the "verify_device" field.
func (m *UserLoginProfileMutation) ResetVerifyDevice() {
	m.verify_device = nil
}

// SetMfaEnabled sets the "mfa_enabled" field.
func (m *UserLoginProfileMutation) SetMfaEnabled(b bool) {
	m.mfa_enabled = &b
}

// MfaEnabled returns the value of the "mfa_enabled" field in the mutation.
func (m *UserLoginProfileMutation) MfaEnabled() (r bool, exists bool) {
	v := m.mfa_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaEnabled returns the old "mfa_enabled" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldMfaEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaEnabled: %w", err)
	}
	return oldValue.MfaEnabled, nil
}

// ClearMfaEnabled clears the value of the "mfa_enabled" field.
func (m *UserLoginProfileMutation) ClearMfaEnabled() {
	m.mfa_enabled = nil
	m.clearedFields[userloginprofile.FieldMfaEnabled] = struct{}{}
}

// MfaEnabledCleared returns if the "mfa_enabled" field was cleared in this mutation.
func (m *UserLoginProfileMutation) MfaEnabledCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldMfaEnabled]
	return ok
}

// ResetMfaEnabled resets all changes to the "mfa_enabled" field.
func (m *UserLoginProfileMutation) ResetMfaEnabled() {
	m.mfa_enabled = nil
	delete(m.clearedFields, userloginprofile.FieldMfaEnabled)
}

// SetMfaSecret sets the "mfa_secret" field.
func (m *UserLoginProfileMutation) SetMfaSecret(s string) {
	m.mfa_secret = &s
}

// MfaSecret returns the value of the "mfa_secret" field in the mutation.
func (m *UserLoginProfileMutation) MfaSecret() (r string, exists bool) {
	v := m.mfa_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaSecret returns the old "mfa_secret" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldMfaSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaSecret: %w", err)
	}
	return oldValue.MfaSecret, nil
}

// ClearMfaSecret clears the value of the "mfa_secret" field.
func (m *UserLoginProfileMutation) ClearMfaSecret() {
	m.mfa_secret = nil
	m.clearedFields[userloginprofile.FieldMfaSecret] = struct{}{}
}

// MfaSecretCleared returns if the "mfa_secret" field was cleared in this mutation.
func (m *UserLoginProfileMutation) MfaSecretCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldMfaSecret]
	return ok
}

// ResetMfaSecret resets all changes to the "mfa_secret" field.
func (m *UserLoginProfileMutation) ResetMfaSecret() {
	m.mfa_secret = nil
	delete(m.clearedFields, userloginprofile.FieldMfaSecret)
}

// SetMfaStatus sets the "mfa_status" field.
func (m *UserLoginProfileMutation) SetMfaStatus(ts typex.SimpleStatus) {
	m.mfa_status = &ts
}

// MfaStatus returns the value of the "mfa_status" field in the mutation.
func (m *UserLoginProfileMutation) MfaStatus() (r typex.SimpleStatus, exists bool) {
	v := m.mfa_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMfaStatus returns the old "mfa_status" field's value of the UserLoginProfile entity.
// If the UserLoginProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginProfileMutation) OldMfaStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMfaStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMfaStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMfaStatus: %w", err)
	}
	return oldValue.MfaStatus, nil
}

// ClearMfaStatus clears the value of the "mfa_status" field.
func (m *UserLoginProfileMutation) ClearMfaStatus() {
	m.mfa_status = nil
	m.clearedFields[userloginprofile.FieldMfaStatus] = struct{}{}
}

// MfaStatusCleared returns if the "mfa_status" field was cleared in this mutation.
func (m *UserLoginProfileMutation) MfaStatusCleared() bool {
	_, ok := m.clearedFields[userloginprofile.FieldMfaStatus]
	return ok
}

// ResetMfaStatus resets all changes to the "mfa_status" field.
func (m *UserLoginProfileMutation) ResetMfaStatus() {
	m.mfa_status = nil
	delete(m.clearedFields, userloginprofile.FieldMfaStatus)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserLoginProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserLoginProfileMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserLoginProfileMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserLoginProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserLoginProfileMutation builder.
func (m *UserLoginProfileMutation) Where(ps ...predicate.UserLoginProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLoginProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLoginProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLoginProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLoginProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLoginProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLoginProfile).
func (m *UserLoginProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginProfileMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, userloginprofile.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userloginprofile.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userloginprofile.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userloginprofile.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userloginprofile.FieldUserID)
	}
	if m.last_login_ip != nil {
		fields = append(fields, userloginprofile.FieldLastLoginIP)
	}
	if m.last_login_at != nil {
		fields = append(fields, userloginprofile.FieldLastLoginAt)
	}
	if m.can_login != nil {
		fields = append(fields, userloginprofile.FieldCanLogin)
	}
	if m.set_kind != nil {
		fields = append(fields, userloginprofile.FieldSetKind)
	}
	if m.password_reset != nil {
		fields = append(fields, userloginprofile.FieldPasswordReset)
	}
	if m.verify_device != nil {
		fields = append(fields, userloginprofile.FieldVerifyDevice)
	}
	if m.mfa_enabled != nil {
		fields = append(fields, userloginprofile.FieldMfaEnabled)
	}
	if m.mfa_secret != nil {
		fields = append(fields, userloginprofile.FieldMfaSecret)
	}
	if m.mfa_status != nil {
		fields = append(fields, userloginprofile.FieldMfaStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userloginprofile.FieldCreatedBy:
		return m.CreatedBy()
	case userloginprofile.FieldCreatedAt:
		return m.CreatedAt()
	case userloginprofile.FieldUpdatedBy:
		return m.UpdatedBy()
	case userloginprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case userloginprofile.FieldUserID:
		return m.UserID()
	case userloginprofile.FieldLastLoginIP:
		return m.LastLoginIP()
	case userloginprofile.FieldLastLoginAt:
		return m.LastLoginAt()
	case userloginprofile.FieldCanLogin:
		return m.CanLogin()
	case userloginprofile.FieldSetKind:
		return m.SetKind()
	case userloginprofile.FieldPasswordReset:
		return m.PasswordReset()
	case userloginprofile.FieldVerifyDevice:
		return m.VerifyDevice()
	case userloginprofile.FieldMfaEnabled:
		return m.MfaEnabled()
	case userloginprofile.FieldMfaSecret:
		return m.MfaSecret()
	case userloginprofile.FieldMfaStatus:
		return m.MfaStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userloginprofile.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userloginprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userloginprofile.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userloginprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userloginprofile.FieldUserID:
		return m.OldUserID(ctx)
	case userloginprofile.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case userloginprofile.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case userloginprofile.FieldCanLogin:
		return m.OldCanLogin(ctx)
	case userloginprofile.FieldSetKind:
		return m.OldSetKind(ctx)
	case userloginprofile.FieldPasswordReset:
		return m.OldPasswordReset(ctx)
	case userloginprofile.FieldVerifyDevice:
		return m.OldVerifyDevice(ctx)
	case userloginprofile.FieldMfaEnabled:
		return m.OldMfaEnabled(ctx)
	case userloginprofile.FieldMfaSecret:
		return m.OldMfaSecret(ctx)
	case userloginprofile.FieldMfaStatus:
		return m.OldMfaStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserLoginProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userloginprofile.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userloginprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userloginprofile.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userloginprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userloginprofile.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userloginprofile.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case userloginprofile.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case userloginprofile.FieldCanLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanLogin(v)
		return nil
	case userloginprofile.FieldSetKind:
		v, ok := value.(userloginprofile.SetKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetKind(v)
		return nil
	case userloginprofile.FieldPasswordReset:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordReset(v)
		return nil
	case userloginprofile.FieldVerifyDevice:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyDevice(v)
		return nil
	case userloginprofile.FieldMfaEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaEnabled(v)
		return nil
	case userloginprofile.FieldMfaSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaSecret(v)
		return nil
	case userloginprofile.FieldMfaStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMfaStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginProfileMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userloginprofile.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userloginprofile.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userloginprofile.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userloginprofile.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userloginprofile.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userloginprofile.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userloginprofile.FieldUpdatedBy) {
		fields = append(fields, userloginprofile.FieldUpdatedBy)
	}
	if m.FieldCleared(userloginprofile.FieldUpdatedAt) {
		fields = append(fields, userloginprofile.FieldUpdatedAt)
	}
	if m.FieldCleared(userloginprofile.FieldUserID) {
		fields = append(fields, userloginprofile.FieldUserID)
	}
	if m.FieldCleared(userloginprofile.FieldLastLoginIP) {
		fields = append(fields, userloginprofile.FieldLastLoginIP)
	}
	if m.FieldCleared(userloginprofile.FieldLastLoginAt) {
		fields = append(fields, userloginprofile.FieldLastLoginAt)
	}
	if m.FieldCleared(userloginprofile.FieldCanLogin) {
		fields = append(fields, userloginprofile.FieldCanLogin)
	}
	if m.FieldCleared(userloginprofile.FieldPasswordReset) {
		fields = append(fields, userloginprofile.FieldPasswordReset)
	}
	if m.FieldCleared(userloginprofile.FieldMfaEnabled) {
		fields = append(fields, userloginprofile.FieldMfaEnabled)
	}
	if m.FieldCleared(userloginprofile.FieldMfaSecret) {
		fields = append(fields, userloginprofile.FieldMfaSecret)
	}
	if m.FieldCleared(userloginprofile.FieldMfaStatus) {
		fields = append(fields, userloginprofile.FieldMfaStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginProfileMutation) ClearField(name string) error {
	switch name {
	case userloginprofile.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userloginprofile.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userloginprofile.FieldUserID:
		m.ClearUserID()
		return nil
	case userloginprofile.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	case userloginprofile.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case userloginprofile.FieldCanLogin:
		m.ClearCanLogin()
		return nil
	case userloginprofile.FieldPasswordReset:
		m.ClearPasswordReset()
		return nil
	case userloginprofile.FieldMfaEnabled:
		m.ClearMfaEnabled()
		return nil
	case userloginprofile.FieldMfaSecret:
		m.ClearMfaSecret()
		return nil
	case userloginprofile.FieldMfaStatus:
		m.ClearMfaStatus()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginProfileMutation) ResetField(name string) error {
	switch name {
	case userloginprofile.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userloginprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userloginprofile.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userloginprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userloginprofile.FieldUserID:
		m.ResetUserID()
		return nil
	case userloginprofile.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case userloginprofile.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case userloginprofile.FieldCanLogin:
		m.ResetCanLogin()
		return nil
	case userloginprofile.FieldSetKind:
		m.ResetSetKind()
		return nil
	case userloginprofile.FieldPasswordReset:
		m.ResetPasswordReset()
		return nil
	case userloginprofile.FieldVerifyDevice:
		m.ResetVerifyDevice()
		return nil
	case userloginprofile.FieldMfaEnabled:
		m.ResetMfaEnabled()
		return nil
	case userloginprofile.FieldMfaSecret:
		m.ResetMfaSecret()
		return nil
	case userloginprofile.FieldMfaStatus:
		m.ResetMfaStatus()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userloginprofile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userloginprofile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userloginprofile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userloginprofile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginProfileMutation) ClearEdge(name string) error {
	switch name {
	case userloginprofile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginProfileMutation) ResetEdge(name string) error {
	switch name {
	case userloginprofile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserLoginProfile edge %s", name)
}

// UserPasswordMutation represents an operation that mutates the UserPassword nodes in the graph.
type UserPasswordMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_by    *int
	addcreated_by *int
	created_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	scene         *userpassword.Scene
	password      *string
	salt          *string
	status        *typex.SimpleStatus
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserPassword, error)
	predicates    []predicate.UserPassword
}

var _ ent.Mutation = (*UserPasswordMutation)(nil)

// userpasswordOption allows management of the mutation configuration using functional options.
type userpasswordOption func(*UserPasswordMutation)

// newUserPasswordMutation creates new mutation for the UserPassword entity.
func newUserPasswordMutation(c config, op Op, opts ...userpasswordOption) *UserPasswordMutation {
	m := &UserPasswordMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPassword,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPasswordID sets the ID field of the mutation.
func withUserPasswordID(id int) userpasswordOption {
	return func(m *UserPasswordMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPassword
		)
		m.oldValue = func(ctx context.Context) (*UserPassword, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPassword.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPassword sets the old UserPassword of the mutation.
func withUserPassword(node *UserPassword) userpasswordOption {
	return func(m *UserPasswordMutation) {
		m.oldValue = func(context.Context) (*UserPassword, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPasswordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPasswordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPassword entities.
func (m *UserPasswordMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPasswordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPasswordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPassword.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *UserPasswordMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserPasswordMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserPasswordMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserPasswordMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserPasswordMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserPasswordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserPasswordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserPasswordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserPasswordMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserPasswordMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserPasswordMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserPasswordMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserPasswordMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[userpassword.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserPasswordMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserPasswordMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, userpassword.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserPasswordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserPasswordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserPasswordMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userpassword.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserPasswordMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserPasswordMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userpassword.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserPasswordMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPasswordMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserPasswordMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userpassword.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserPasswordMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPasswordMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userpassword.FieldUserID)
}

// SetScene sets the "scene" field.
func (m *UserPasswordMutation) SetScene(u userpassword.Scene) {
	m.scene = &u
}

// Scene returns the value of the "scene" field in the mutation.
func (m *UserPasswordMutation) Scene() (r userpassword.Scene, exists bool) {
	v := m.scene
	if v == nil {
		return
	}
	return *v, true
}

// OldScene returns the old "scene" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldScene(ctx context.Context) (v userpassword.Scene, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScene is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScene requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScene: %w", err)
	}
	return oldValue.Scene, nil
}

// ResetScene resets all changes to the "scene" field.
func (m *UserPasswordMutation) ResetScene() {
	m.scene = nil
}

// SetPassword sets the "password" field.
func (m *UserPasswordMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserPasswordMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserPasswordMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[userpassword.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserPasswordMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserPasswordMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, userpassword.FieldPassword)
}

// SetSalt sets the "salt" field.
func (m *UserPasswordMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *UserPasswordMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *UserPasswordMutation) ResetSalt() {
	m.salt = nil
}

// SetStatus sets the "status" field.
func (m *UserPasswordMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *UserPasswordMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserPassword entity.
// If the UserPassword object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPasswordMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserPasswordMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[userpassword.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserPasswordMutation) StatusCleared() bool {
	_, ok := m.clearedFields[userpassword.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserPasswordMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, userpassword.FieldStatus)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserPasswordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserPasswordMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserPasswordMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserPasswordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserPasswordMutation builder.
func (m *UserPasswordMutation) Where(ps ...predicate.UserPassword) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPasswordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPasswordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPassword, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPasswordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPasswordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPassword).
func (m *UserPasswordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPasswordMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, userpassword.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userpassword.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, userpassword.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, userpassword.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userpassword.FieldUserID)
	}
	if m.scene != nil {
		fields = append(fields, userpassword.FieldScene)
	}
	if m.password != nil {
		fields = append(fields, userpassword.FieldPassword)
	}
	if m.salt != nil {
		fields = append(fields, userpassword.FieldSalt)
	}
	if m.status != nil {
		fields = append(fields, userpassword.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPasswordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpassword.FieldCreatedBy:
		return m.CreatedBy()
	case userpassword.FieldCreatedAt:
		return m.CreatedAt()
	case userpassword.FieldUpdatedBy:
		return m.UpdatedBy()
	case userpassword.FieldUpdatedAt:
		return m.UpdatedAt()
	case userpassword.FieldUserID:
		return m.UserID()
	case userpassword.FieldScene:
		return m.Scene()
	case userpassword.FieldPassword:
		return m.Password()
	case userpassword.FieldSalt:
		return m.Salt()
	case userpassword.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPasswordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpassword.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userpassword.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userpassword.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case userpassword.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userpassword.FieldUserID:
		return m.OldUserID(ctx)
	case userpassword.FieldScene:
		return m.OldScene(ctx)
	case userpassword.FieldPassword:
		return m.OldPassword(ctx)
	case userpassword.FieldSalt:
		return m.OldSalt(ctx)
	case userpassword.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserPassword field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPasswordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpassword.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userpassword.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userpassword.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case userpassword.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userpassword.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userpassword.FieldScene:
		v, ok := value.(userpassword.Scene)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScene(v)
		return nil
	case userpassword.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case userpassword.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case userpassword.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserPassword field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPasswordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, userpassword.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, userpassword.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPasswordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userpassword.FieldCreatedBy:
		return m.AddedCreatedBy()
	case userpassword.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPasswordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userpassword.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case userpassword.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserPassword numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPasswordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userpassword.FieldUpdatedBy) {
		fields = append(fields, userpassword.FieldUpdatedBy)
	}
	if m.FieldCleared(userpassword.FieldUpdatedAt) {
		fields = append(fields, userpassword.FieldUpdatedAt)
	}
	if m.FieldCleared(userpassword.FieldUserID) {
		fields = append(fields, userpassword.FieldUserID)
	}
	if m.FieldCleared(userpassword.FieldPassword) {
		fields = append(fields, userpassword.FieldPassword)
	}
	if m.FieldCleared(userpassword.FieldStatus) {
		fields = append(fields, userpassword.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPasswordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPasswordMutation) ClearField(name string) error {
	switch name {
	case userpassword.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case userpassword.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userpassword.FieldUserID:
		m.ClearUserID()
		return nil
	case userpassword.FieldPassword:
		m.ClearPassword()
		return nil
	case userpassword.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown UserPassword nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPasswordMutation) ResetField(name string) error {
	switch name {
	case userpassword.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userpassword.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userpassword.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case userpassword.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userpassword.FieldUserID:
		m.ResetUserID()
		return nil
	case userpassword.FieldScene:
		m.ResetScene()
		return nil
	case userpassword.FieldPassword:
		m.ResetPassword()
		return nil
	case userpassword.FieldSalt:
		m.ResetSalt()
		return nil
	case userpassword.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserPassword field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPasswordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userpassword.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPasswordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userpassword.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPasswordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPasswordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPasswordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userpassword.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPasswordMutation) EdgeCleared(name string) bool {
	switch name {
	case userpassword.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPasswordMutation) ClearEdge(name string) error {
	switch name {
	case userpassword.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserPassword unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPasswordMutation) ResetEdge(name string) error {
	switch name {
	case userpassword.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserPassword edge %s", name)
}
