// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/woocoos/entco/schemax/typex"
	"github.com/woocoos/knockout/ent/app"
	"github.com/woocoos/knockout/ent/appaction"
	"github.com/woocoos/knockout/ent/appmenu"
	"github.com/woocoos/knockout/ent/apppolicy"
	"github.com/woocoos/knockout/ent/appres"
	"github.com/woocoos/knockout/ent/approle"
	"github.com/woocoos/knockout/ent/org"
	"github.com/woocoos/knockout/ent/orgpolicy"
	"github.com/woocoos/knockout/ent/orgrole"
	"github.com/woocoos/knockout/ent/orguser"
	"github.com/woocoos/knockout/ent/permission"
	"github.com/woocoos/knockout/ent/predicate"
	"github.com/woocoos/knockout/ent/user"
	"github.com/woocoos/knockout/ent/userdevice"
	"github.com/woocoos/knockout/ent/useridentity"
	"github.com/woocoos/knockout/ent/userloginprofile"
	"github.com/woocoos/knockout/ent/userpassword"
)

// AppWhereInput represents a where input for filtering App queries.
type AppWhereInput struct {
	Predicates []predicate.App  `json:"-"`
	Not        *AppWhereInput   `json:"not,omitempty"`
	Or         []*AppWhereInput `json:"or,omitempty"`
	And        []*AppWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "kind" field predicates.
	Kind      *app.Kind  `json:"kind,omitempty"`
	KindNEQ   *app.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []app.Kind `json:"kindIn,omitempty"`
	KindNotIn []app.Kind `json:"kindNotIn,omitempty"`

	// "redirect_uri" field predicates.
	RedirectURI             *string  `json:"redirectURI,omitempty"`
	RedirectURINEQ          *string  `json:"redirectURINEQ,omitempty"`
	RedirectURIIn           []string `json:"redirectURIIn,omitempty"`
	RedirectURINotIn        []string `json:"redirectURINotIn,omitempty"`
	RedirectURIGT           *string  `json:"redirectURIGT,omitempty"`
	RedirectURIGTE          *string  `json:"redirectURIGTE,omitempty"`
	RedirectURILT           *string  `json:"redirectURILT,omitempty"`
	RedirectURILTE          *string  `json:"redirectURILTE,omitempty"`
	RedirectURIContains     *string  `json:"redirectURIContains,omitempty"`
	RedirectURIHasPrefix    *string  `json:"redirectURIHasPrefix,omitempty"`
	RedirectURIHasSuffix    *string  `json:"redirectURIHasSuffix,omitempty"`
	RedirectURIIsNil        bool     `json:"redirectURIIsNil,omitempty"`
	RedirectURINotNil       bool     `json:"redirectURINotNil,omitempty"`
	RedirectURIEqualFold    *string  `json:"redirectURIEqualFold,omitempty"`
	RedirectURIContainsFold *string  `json:"redirectURIContainsFold,omitempty"`

	// "app_key" field predicates.
	AppKey             *string  `json:"appKey,omitempty"`
	AppKeyNEQ          *string  `json:"appKeyNEQ,omitempty"`
	AppKeyIn           []string `json:"appKeyIn,omitempty"`
	AppKeyNotIn        []string `json:"appKeyNotIn,omitempty"`
	AppKeyGT           *string  `json:"appKeyGT,omitempty"`
	AppKeyGTE          *string  `json:"appKeyGTE,omitempty"`
	AppKeyLT           *string  `json:"appKeyLT,omitempty"`
	AppKeyLTE          *string  `json:"appKeyLTE,omitempty"`
	AppKeyContains     *string  `json:"appKeyContains,omitempty"`
	AppKeyHasPrefix    *string  `json:"appKeyHasPrefix,omitempty"`
	AppKeyHasSuffix    *string  `json:"appKeyHasSuffix,omitempty"`
	AppKeyIsNil        bool     `json:"appKeyIsNil,omitempty"`
	AppKeyNotNil       bool     `json:"appKeyNotNil,omitempty"`
	AppKeyEqualFold    *string  `json:"appKeyEqualFold,omitempty"`
	AppKeyContainsFold *string  `json:"appKeyContainsFold,omitempty"`

	// "app_secret" field predicates.
	AppSecret             *string  `json:"appSecret,omitempty"`
	AppSecretNEQ          *string  `json:"appSecretNEQ,omitempty"`
	AppSecretIn           []string `json:"appSecretIn,omitempty"`
	AppSecretNotIn        []string `json:"appSecretNotIn,omitempty"`
	AppSecretGT           *string  `json:"appSecretGT,omitempty"`
	AppSecretGTE          *string  `json:"appSecretGTE,omitempty"`
	AppSecretLT           *string  `json:"appSecretLT,omitempty"`
	AppSecretLTE          *string  `json:"appSecretLTE,omitempty"`
	AppSecretContains     *string  `json:"appSecretContains,omitempty"`
	AppSecretHasPrefix    *string  `json:"appSecretHasPrefix,omitempty"`
	AppSecretHasSuffix    *string  `json:"appSecretHasSuffix,omitempty"`
	AppSecretIsNil        bool     `json:"appSecretIsNil,omitempty"`
	AppSecretNotNil       bool     `json:"appSecretNotNil,omitempty"`
	AppSecretEqualFold    *string  `json:"appSecretEqualFold,omitempty"`
	AppSecretContainsFold *string  `json:"appSecretContainsFold,omitempty"`

	// "scopes" field predicates.
	Scopes             *string  `json:"scopes,omitempty"`
	ScopesNEQ          *string  `json:"scopesNEQ,omitempty"`
	ScopesIn           []string `json:"scopesIn,omitempty"`
	ScopesNotIn        []string `json:"scopesNotIn,omitempty"`
	ScopesGT           *string  `json:"scopesGT,omitempty"`
	ScopesGTE          *string  `json:"scopesGTE,omitempty"`
	ScopesLT           *string  `json:"scopesLT,omitempty"`
	ScopesLTE          *string  `json:"scopesLTE,omitempty"`
	ScopesContains     *string  `json:"scopesContains,omitempty"`
	ScopesHasPrefix    *string  `json:"scopesHasPrefix,omitempty"`
	ScopesHasSuffix    *string  `json:"scopesHasSuffix,omitempty"`
	ScopesIsNil        bool     `json:"scopesIsNil,omitempty"`
	ScopesNotNil       bool     `json:"scopesNotNil,omitempty"`
	ScopesEqualFold    *string  `json:"scopesEqualFold,omitempty"`
	ScopesContainsFold *string  `json:"scopesContainsFold,omitempty"`

	// "token_validity" field predicates.
	TokenValidity       *int32  `json:"tokenValidity,omitempty"`
	TokenValidityNEQ    *int32  `json:"tokenValidityNEQ,omitempty"`
	TokenValidityIn     []int32 `json:"tokenValidityIn,omitempty"`
	TokenValidityNotIn  []int32 `json:"tokenValidityNotIn,omitempty"`
	TokenValidityGT     *int32  `json:"tokenValidityGT,omitempty"`
	TokenValidityGTE    *int32  `json:"tokenValidityGTE,omitempty"`
	TokenValidityLT     *int32  `json:"tokenValidityLT,omitempty"`
	TokenValidityLTE    *int32  `json:"tokenValidityLTE,omitempty"`
	TokenValidityIsNil  bool    `json:"tokenValidityIsNil,omitempty"`
	TokenValidityNotNil bool    `json:"tokenValidityNotNil,omitempty"`

	// "refresh_token_validity" field predicates.
	RefreshTokenValidity       *int32  `json:"refreshTokenValidity,omitempty"`
	RefreshTokenValidityNEQ    *int32  `json:"refreshTokenValidityNEQ,omitempty"`
	RefreshTokenValidityIn     []int32 `json:"refreshTokenValidityIn,omitempty"`
	RefreshTokenValidityNotIn  []int32 `json:"refreshTokenValidityNotIn,omitempty"`
	RefreshTokenValidityGT     *int32  `json:"refreshTokenValidityGT,omitempty"`
	RefreshTokenValidityGTE    *int32  `json:"refreshTokenValidityGTE,omitempty"`
	RefreshTokenValidityLT     *int32  `json:"refreshTokenValidityLT,omitempty"`
	RefreshTokenValidityLTE    *int32  `json:"refreshTokenValidityLTE,omitempty"`
	RefreshTokenValidityIsNil  bool    `json:"refreshTokenValidityIsNil,omitempty"`
	RefreshTokenValidityNotNil bool    `json:"refreshTokenValidityNotNil,omitempty"`

	// "logo" field predicates.
	Logo             *string  `json:"logo,omitempty"`
	LogoNEQ          *string  `json:"logoNEQ,omitempty"`
	LogoIn           []string `json:"logoIn,omitempty"`
	LogoNotIn        []string `json:"logoNotIn,omitempty"`
	LogoGT           *string  `json:"logoGT,omitempty"`
	LogoGTE          *string  `json:"logoGTE,omitempty"`
	LogoLT           *string  `json:"logoLT,omitempty"`
	LogoLTE          *string  `json:"logoLTE,omitempty"`
	LogoContains     *string  `json:"logoContains,omitempty"`
	LogoHasPrefix    *string  `json:"logoHasPrefix,omitempty"`
	LogoHasSuffix    *string  `json:"logoHasSuffix,omitempty"`
	LogoIsNil        bool     `json:"logoIsNil,omitempty"`
	LogoNotNil       bool     `json:"logoNotNil,omitempty"`
	LogoEqualFold    *string  `json:"logoEqualFold,omitempty"`
	LogoContainsFold *string  `json:"logoContainsFold,omitempty"`

	// "comments" field predicates.
	Comments             *string  `json:"comments,omitempty"`
	CommentsNEQ          *string  `json:"commentsNEQ,omitempty"`
	CommentsIn           []string `json:"commentsIn,omitempty"`
	CommentsNotIn        []string `json:"commentsNotIn,omitempty"`
	CommentsGT           *string  `json:"commentsGT,omitempty"`
	CommentsGTE          *string  `json:"commentsGTE,omitempty"`
	CommentsLT           *string  `json:"commentsLT,omitempty"`
	CommentsLTE          *string  `json:"commentsLTE,omitempty"`
	CommentsContains     *string  `json:"commentsContains,omitempty"`
	CommentsHasPrefix    *string  `json:"commentsHasPrefix,omitempty"`
	CommentsHasSuffix    *string  `json:"commentsHasSuffix,omitempty"`
	CommentsIsNil        bool     `json:"commentsIsNil,omitempty"`
	CommentsNotNil       bool     `json:"commentsNotNil,omitempty"`
	CommentsEqualFold    *string  `json:"commentsEqualFold,omitempty"`
	CommentsContainsFold *string  `json:"commentsContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "menus" edge predicates.
	HasMenus     *bool                `json:"hasMenus,omitempty"`
	HasMenusWith []*AppMenuWhereInput `json:"hasMenusWith,omitempty"`

	// "actions" edge predicates.
	HasActions     *bool                  `json:"hasActions,omitempty"`
	HasActionsWith []*AppActionWhereInput `json:"hasActionsWith,omitempty"`

	// "resources" edge predicates.
	HasResources     *bool               `json:"hasResources,omitempty"`
	HasResourcesWith []*AppResWhereInput `json:"hasResourcesWith,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool                `json:"hasRoles,omitempty"`
	HasRolesWith []*AppRoleWhereInput `json:"hasRolesWith,omitempty"`

	// "policies" edge predicates.
	HasPolicies     *bool                  `json:"hasPolicies,omitempty"`
	HasPoliciesWith []*AppPolicyWhereInput `json:"hasPoliciesWith,omitempty"`

	// "orgs" edge predicates.
	HasOrgs     *bool            `json:"hasOrgs,omitempty"`
	HasOrgsWith []*OrgWhereInput `json:"hasOrgsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AppWhereInput) AddPredicates(predicates ...predicate.App) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AppWhereInput filter on the AppQuery builder.
func (i *AppWhereInput) Filter(q *AppQuery) (*AppQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAppWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAppWhereInput is returned in case the AppWhereInput is empty.
var ErrEmptyAppWhereInput = errors.New("ent: empty predicate AppWhereInput")

// P returns a predicate for filtering apps.
// An error is returned if the input is empty or invalid.
func (i *AppWhereInput) P() (predicate.App, error) {
	var predicates []predicate.App
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, app.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.App, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, app.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.App, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, app.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, app.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, app.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, app.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, app.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, app.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, app.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, app.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, app.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, app.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, app.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, app.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, app.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, app.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, app.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, app.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, app.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, app.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, app.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, app.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, app.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, app.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, app.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, app.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, app.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, app.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, app.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, app.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, app.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, app.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, app.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, app.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, app.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, app.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, app.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, app.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, app.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, app.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, app.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, app.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, app.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, app.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, app.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, app.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, app.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, app.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, app.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, app.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, app.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, app.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, app.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, app.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, app.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, app.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, app.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, app.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, app.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, app.NameContainsFold(*i.NameContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, app.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, app.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, app.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, app.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, app.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, app.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, app.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, app.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, app.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, app.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, app.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, app.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, app.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, app.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, app.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, app.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, app.KindNotIn(i.KindNotIn...))
	}
	if i.RedirectURI != nil {
		predicates = append(predicates, app.RedirectURIEQ(*i.RedirectURI))
	}
	if i.RedirectURINEQ != nil {
		predicates = append(predicates, app.RedirectURINEQ(*i.RedirectURINEQ))
	}
	if len(i.RedirectURIIn) > 0 {
		predicates = append(predicates, app.RedirectURIIn(i.RedirectURIIn...))
	}
	if len(i.RedirectURINotIn) > 0 {
		predicates = append(predicates, app.RedirectURINotIn(i.RedirectURINotIn...))
	}
	if i.RedirectURIGT != nil {
		predicates = append(predicates, app.RedirectURIGT(*i.RedirectURIGT))
	}
	if i.RedirectURIGTE != nil {
		predicates = append(predicates, app.RedirectURIGTE(*i.RedirectURIGTE))
	}
	if i.RedirectURILT != nil {
		predicates = append(predicates, app.RedirectURILT(*i.RedirectURILT))
	}
	if i.RedirectURILTE != nil {
		predicates = append(predicates, app.RedirectURILTE(*i.RedirectURILTE))
	}
	if i.RedirectURIContains != nil {
		predicates = append(predicates, app.RedirectURIContains(*i.RedirectURIContains))
	}
	if i.RedirectURIHasPrefix != nil {
		predicates = append(predicates, app.RedirectURIHasPrefix(*i.RedirectURIHasPrefix))
	}
	if i.RedirectURIHasSuffix != nil {
		predicates = append(predicates, app.RedirectURIHasSuffix(*i.RedirectURIHasSuffix))
	}
	if i.RedirectURIIsNil {
		predicates = append(predicates, app.RedirectURIIsNil())
	}
	if i.RedirectURINotNil {
		predicates = append(predicates, app.RedirectURINotNil())
	}
	if i.RedirectURIEqualFold != nil {
		predicates = append(predicates, app.RedirectURIEqualFold(*i.RedirectURIEqualFold))
	}
	if i.RedirectURIContainsFold != nil {
		predicates = append(predicates, app.RedirectURIContainsFold(*i.RedirectURIContainsFold))
	}
	if i.AppKey != nil {
		predicates = append(predicates, app.AppKeyEQ(*i.AppKey))
	}
	if i.AppKeyNEQ != nil {
		predicates = append(predicates, app.AppKeyNEQ(*i.AppKeyNEQ))
	}
	if len(i.AppKeyIn) > 0 {
		predicates = append(predicates, app.AppKeyIn(i.AppKeyIn...))
	}
	if len(i.AppKeyNotIn) > 0 {
		predicates = append(predicates, app.AppKeyNotIn(i.AppKeyNotIn...))
	}
	if i.AppKeyGT != nil {
		predicates = append(predicates, app.AppKeyGT(*i.AppKeyGT))
	}
	if i.AppKeyGTE != nil {
		predicates = append(predicates, app.AppKeyGTE(*i.AppKeyGTE))
	}
	if i.AppKeyLT != nil {
		predicates = append(predicates, app.AppKeyLT(*i.AppKeyLT))
	}
	if i.AppKeyLTE != nil {
		predicates = append(predicates, app.AppKeyLTE(*i.AppKeyLTE))
	}
	if i.AppKeyContains != nil {
		predicates = append(predicates, app.AppKeyContains(*i.AppKeyContains))
	}
	if i.AppKeyHasPrefix != nil {
		predicates = append(predicates, app.AppKeyHasPrefix(*i.AppKeyHasPrefix))
	}
	if i.AppKeyHasSuffix != nil {
		predicates = append(predicates, app.AppKeyHasSuffix(*i.AppKeyHasSuffix))
	}
	if i.AppKeyIsNil {
		predicates = append(predicates, app.AppKeyIsNil())
	}
	if i.AppKeyNotNil {
		predicates = append(predicates, app.AppKeyNotNil())
	}
	if i.AppKeyEqualFold != nil {
		predicates = append(predicates, app.AppKeyEqualFold(*i.AppKeyEqualFold))
	}
	if i.AppKeyContainsFold != nil {
		predicates = append(predicates, app.AppKeyContainsFold(*i.AppKeyContainsFold))
	}
	if i.AppSecret != nil {
		predicates = append(predicates, app.AppSecretEQ(*i.AppSecret))
	}
	if i.AppSecretNEQ != nil {
		predicates = append(predicates, app.AppSecretNEQ(*i.AppSecretNEQ))
	}
	if len(i.AppSecretIn) > 0 {
		predicates = append(predicates, app.AppSecretIn(i.AppSecretIn...))
	}
	if len(i.AppSecretNotIn) > 0 {
		predicates = append(predicates, app.AppSecretNotIn(i.AppSecretNotIn...))
	}
	if i.AppSecretGT != nil {
		predicates = append(predicates, app.AppSecretGT(*i.AppSecretGT))
	}
	if i.AppSecretGTE != nil {
		predicates = append(predicates, app.AppSecretGTE(*i.AppSecretGTE))
	}
	if i.AppSecretLT != nil {
		predicates = append(predicates, app.AppSecretLT(*i.AppSecretLT))
	}
	if i.AppSecretLTE != nil {
		predicates = append(predicates, app.AppSecretLTE(*i.AppSecretLTE))
	}
	if i.AppSecretContains != nil {
		predicates = append(predicates, app.AppSecretContains(*i.AppSecretContains))
	}
	if i.AppSecretHasPrefix != nil {
		predicates = append(predicates, app.AppSecretHasPrefix(*i.AppSecretHasPrefix))
	}
	if i.AppSecretHasSuffix != nil {
		predicates = append(predicates, app.AppSecretHasSuffix(*i.AppSecretHasSuffix))
	}
	if i.AppSecretIsNil {
		predicates = append(predicates, app.AppSecretIsNil())
	}
	if i.AppSecretNotNil {
		predicates = append(predicates, app.AppSecretNotNil())
	}
	if i.AppSecretEqualFold != nil {
		predicates = append(predicates, app.AppSecretEqualFold(*i.AppSecretEqualFold))
	}
	if i.AppSecretContainsFold != nil {
		predicates = append(predicates, app.AppSecretContainsFold(*i.AppSecretContainsFold))
	}
	if i.Scopes != nil {
		predicates = append(predicates, app.ScopesEQ(*i.Scopes))
	}
	if i.ScopesNEQ != nil {
		predicates = append(predicates, app.ScopesNEQ(*i.ScopesNEQ))
	}
	if len(i.ScopesIn) > 0 {
		predicates = append(predicates, app.ScopesIn(i.ScopesIn...))
	}
	if len(i.ScopesNotIn) > 0 {
		predicates = append(predicates, app.ScopesNotIn(i.ScopesNotIn...))
	}
	if i.ScopesGT != nil {
		predicates = append(predicates, app.ScopesGT(*i.ScopesGT))
	}
	if i.ScopesGTE != nil {
		predicates = append(predicates, app.ScopesGTE(*i.ScopesGTE))
	}
	if i.ScopesLT != nil {
		predicates = append(predicates, app.ScopesLT(*i.ScopesLT))
	}
	if i.ScopesLTE != nil {
		predicates = append(predicates, app.ScopesLTE(*i.ScopesLTE))
	}
	if i.ScopesContains != nil {
		predicates = append(predicates, app.ScopesContains(*i.ScopesContains))
	}
	if i.ScopesHasPrefix != nil {
		predicates = append(predicates, app.ScopesHasPrefix(*i.ScopesHasPrefix))
	}
	if i.ScopesHasSuffix != nil {
		predicates = append(predicates, app.ScopesHasSuffix(*i.ScopesHasSuffix))
	}
	if i.ScopesIsNil {
		predicates = append(predicates, app.ScopesIsNil())
	}
	if i.ScopesNotNil {
		predicates = append(predicates, app.ScopesNotNil())
	}
	if i.ScopesEqualFold != nil {
		predicates = append(predicates, app.ScopesEqualFold(*i.ScopesEqualFold))
	}
	if i.ScopesContainsFold != nil {
		predicates = append(predicates, app.ScopesContainsFold(*i.ScopesContainsFold))
	}
	if i.TokenValidity != nil {
		predicates = append(predicates, app.TokenValidityEQ(*i.TokenValidity))
	}
	if i.TokenValidityNEQ != nil {
		predicates = append(predicates, app.TokenValidityNEQ(*i.TokenValidityNEQ))
	}
	if len(i.TokenValidityIn) > 0 {
		predicates = append(predicates, app.TokenValidityIn(i.TokenValidityIn...))
	}
	if len(i.TokenValidityNotIn) > 0 {
		predicates = append(predicates, app.TokenValidityNotIn(i.TokenValidityNotIn...))
	}
	if i.TokenValidityGT != nil {
		predicates = append(predicates, app.TokenValidityGT(*i.TokenValidityGT))
	}
	if i.TokenValidityGTE != nil {
		predicates = append(predicates, app.TokenValidityGTE(*i.TokenValidityGTE))
	}
	if i.TokenValidityLT != nil {
		predicates = append(predicates, app.TokenValidityLT(*i.TokenValidityLT))
	}
	if i.TokenValidityLTE != nil {
		predicates = append(predicates, app.TokenValidityLTE(*i.TokenValidityLTE))
	}
	if i.TokenValidityIsNil {
		predicates = append(predicates, app.TokenValidityIsNil())
	}
	if i.TokenValidityNotNil {
		predicates = append(predicates, app.TokenValidityNotNil())
	}
	if i.RefreshTokenValidity != nil {
		predicates = append(predicates, app.RefreshTokenValidityEQ(*i.RefreshTokenValidity))
	}
	if i.RefreshTokenValidityNEQ != nil {
		predicates = append(predicates, app.RefreshTokenValidityNEQ(*i.RefreshTokenValidityNEQ))
	}
	if len(i.RefreshTokenValidityIn) > 0 {
		predicates = append(predicates, app.RefreshTokenValidityIn(i.RefreshTokenValidityIn...))
	}
	if len(i.RefreshTokenValidityNotIn) > 0 {
		predicates = append(predicates, app.RefreshTokenValidityNotIn(i.RefreshTokenValidityNotIn...))
	}
	if i.RefreshTokenValidityGT != nil {
		predicates = append(predicates, app.RefreshTokenValidityGT(*i.RefreshTokenValidityGT))
	}
	if i.RefreshTokenValidityGTE != nil {
		predicates = append(predicates, app.RefreshTokenValidityGTE(*i.RefreshTokenValidityGTE))
	}
	if i.RefreshTokenValidityLT != nil {
		predicates = append(predicates, app.RefreshTokenValidityLT(*i.RefreshTokenValidityLT))
	}
	if i.RefreshTokenValidityLTE != nil {
		predicates = append(predicates, app.RefreshTokenValidityLTE(*i.RefreshTokenValidityLTE))
	}
	if i.RefreshTokenValidityIsNil {
		predicates = append(predicates, app.RefreshTokenValidityIsNil())
	}
	if i.RefreshTokenValidityNotNil {
		predicates = append(predicates, app.RefreshTokenValidityNotNil())
	}
	if i.Logo != nil {
		predicates = append(predicates, app.LogoEQ(*i.Logo))
	}
	if i.LogoNEQ != nil {
		predicates = append(predicates, app.LogoNEQ(*i.LogoNEQ))
	}
	if len(i.LogoIn) > 0 {
		predicates = append(predicates, app.LogoIn(i.LogoIn...))
	}
	if len(i.LogoNotIn) > 0 {
		predicates = append(predicates, app.LogoNotIn(i.LogoNotIn...))
	}
	if i.LogoGT != nil {
		predicates = append(predicates, app.LogoGT(*i.LogoGT))
	}
	if i.LogoGTE != nil {
		predicates = append(predicates, app.LogoGTE(*i.LogoGTE))
	}
	if i.LogoLT != nil {
		predicates = append(predicates, app.LogoLT(*i.LogoLT))
	}
	if i.LogoLTE != nil {
		predicates = append(predicates, app.LogoLTE(*i.LogoLTE))
	}
	if i.LogoContains != nil {
		predicates = append(predicates, app.LogoContains(*i.LogoContains))
	}
	if i.LogoHasPrefix != nil {
		predicates = append(predicates, app.LogoHasPrefix(*i.LogoHasPrefix))
	}
	if i.LogoHasSuffix != nil {
		predicates = append(predicates, app.LogoHasSuffix(*i.LogoHasSuffix))
	}
	if i.LogoIsNil {
		predicates = append(predicates, app.LogoIsNil())
	}
	if i.LogoNotNil {
		predicates = append(predicates, app.LogoNotNil())
	}
	if i.LogoEqualFold != nil {
		predicates = append(predicates, app.LogoEqualFold(*i.LogoEqualFold))
	}
	if i.LogoContainsFold != nil {
		predicates = append(predicates, app.LogoContainsFold(*i.LogoContainsFold))
	}
	if i.Comments != nil {
		predicates = append(predicates, app.CommentsEQ(*i.Comments))
	}
	if i.CommentsNEQ != nil {
		predicates = append(predicates, app.CommentsNEQ(*i.CommentsNEQ))
	}
	if len(i.CommentsIn) > 0 {
		predicates = append(predicates, app.CommentsIn(i.CommentsIn...))
	}
	if len(i.CommentsNotIn) > 0 {
		predicates = append(predicates, app.CommentsNotIn(i.CommentsNotIn...))
	}
	if i.CommentsGT != nil {
		predicates = append(predicates, app.CommentsGT(*i.CommentsGT))
	}
	if i.CommentsGTE != nil {
		predicates = append(predicates, app.CommentsGTE(*i.CommentsGTE))
	}
	if i.CommentsLT != nil {
		predicates = append(predicates, app.CommentsLT(*i.CommentsLT))
	}
	if i.CommentsLTE != nil {
		predicates = append(predicates, app.CommentsLTE(*i.CommentsLTE))
	}
	if i.CommentsContains != nil {
		predicates = append(predicates, app.CommentsContains(*i.CommentsContains))
	}
	if i.CommentsHasPrefix != nil {
		predicates = append(predicates, app.CommentsHasPrefix(*i.CommentsHasPrefix))
	}
	if i.CommentsHasSuffix != nil {
		predicates = append(predicates, app.CommentsHasSuffix(*i.CommentsHasSuffix))
	}
	if i.CommentsIsNil {
		predicates = append(predicates, app.CommentsIsNil())
	}
	if i.CommentsNotNil {
		predicates = append(predicates, app.CommentsNotNil())
	}
	if i.CommentsEqualFold != nil {
		predicates = append(predicates, app.CommentsEqualFold(*i.CommentsEqualFold))
	}
	if i.CommentsContainsFold != nil {
		predicates = append(predicates, app.CommentsContainsFold(*i.CommentsContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, app.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, app.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, app.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, app.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, app.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, app.StatusNotNil())
	}

	if i.HasMenus != nil {
		p := app.HasMenus()
		if !*i.HasMenus {
			p = app.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMenusWith) > 0 {
		with := make([]predicate.AppMenu, 0, len(i.HasMenusWith))
		for _, w := range i.HasMenusWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMenusWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, app.HasMenusWith(with...))
	}
	if i.HasActions != nil {
		p := app.HasActions()
		if !*i.HasActions {
			p = app.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionsWith) > 0 {
		with := make([]predicate.AppAction, 0, len(i.HasActionsWith))
		for _, w := range i.HasActionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, app.HasActionsWith(with...))
	}
	if i.HasResources != nil {
		p := app.HasResources()
		if !*i.HasResources {
			p = app.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasResourcesWith) > 0 {
		with := make([]predicate.AppRes, 0, len(i.HasResourcesWith))
		for _, w := range i.HasResourcesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasResourcesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, app.HasResourcesWith(with...))
	}
	if i.HasRoles != nil {
		p := app.HasRoles()
		if !*i.HasRoles {
			p = app.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.AppRole, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, app.HasRolesWith(with...))
	}
	if i.HasPolicies != nil {
		p := app.HasPolicies()
		if !*i.HasPolicies {
			p = app.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPoliciesWith) > 0 {
		with := make([]predicate.AppPolicy, 0, len(i.HasPoliciesWith))
		for _, w := range i.HasPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, app.HasPoliciesWith(with...))
	}
	if i.HasOrgs != nil {
		p := app.HasOrgs()
		if !*i.HasOrgs {
			p = app.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrgsWith) > 0 {
		with := make([]predicate.Org, 0, len(i.HasOrgsWith))
		for _, w := range i.HasOrgsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrgsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, app.HasOrgsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAppWhereInput
	case 1:
		return predicates[0], nil
	default:
		return app.And(predicates...), nil
	}
}

// AppActionWhereInput represents a where input for filtering AppAction queries.
type AppActionWhereInput struct {
	Predicates []predicate.AppAction  `json:"-"`
	Not        *AppActionWhereInput   `json:"not,omitempty"`
	Or         []*AppActionWhereInput `json:"or,omitempty"`
	And        []*AppActionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "kind" field predicates.
	Kind      *appaction.Kind  `json:"kind,omitempty"`
	KindNEQ   *appaction.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []appaction.Kind `json:"kindIn,omitempty"`
	KindNotIn []appaction.Kind `json:"kindNotIn,omitempty"`

	// "method" field predicates.
	Method      *appaction.Method  `json:"method,omitempty"`
	MethodNEQ   *appaction.Method  `json:"methodNEQ,omitempty"`
	MethodIn    []appaction.Method `json:"methodIn,omitempty"`
	MethodNotIn []appaction.Method `json:"methodNotIn,omitempty"`

	// "app" edge predicates.
	HasApp     *bool            `json:"hasApp,omitempty"`
	HasAppWith []*AppWhereInput `json:"hasAppWith,omitempty"`

	// "menus" edge predicates.
	HasMenus     *bool                `json:"hasMenus,omitempty"`
	HasMenusWith []*AppMenuWhereInput `json:"hasMenusWith,omitempty"`

	// "resources" edge predicates.
	HasResources     *bool               `json:"hasResources,omitempty"`
	HasResourcesWith []*AppResWhereInput `json:"hasResourcesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AppActionWhereInput) AddPredicates(predicates ...predicate.AppAction) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AppActionWhereInput filter on the AppActionQuery builder.
func (i *AppActionWhereInput) Filter(q *AppActionQuery) (*AppActionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAppActionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAppActionWhereInput is returned in case the AppActionWhereInput is empty.
var ErrEmptyAppActionWhereInput = errors.New("ent: empty predicate AppActionWhereInput")

// P returns a predicate for filtering appactions.
// An error is returned if the input is empty or invalid.
func (i *AppActionWhereInput) P() (predicate.AppAction, error) {
	var predicates []predicate.AppAction
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, appaction.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AppAction, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, appaction.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AppAction, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, appaction.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, appaction.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, appaction.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, appaction.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, appaction.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, appaction.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, appaction.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, appaction.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, appaction.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, appaction.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, appaction.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, appaction.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, appaction.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, appaction.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, appaction.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, appaction.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, appaction.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, appaction.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, appaction.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, appaction.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, appaction.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, appaction.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, appaction.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, appaction.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, appaction.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, appaction.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, appaction.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, appaction.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, appaction.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, appaction.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, appaction.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, appaction.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, appaction.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, appaction.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, appaction.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, appaction.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, appaction.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, appaction.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, appaction.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, appaction.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, appaction.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, appaction.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, appaction.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, appaction.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, appaction.UpdatedAtNotNil())
	}
	if i.AppID != nil {
		predicates = append(predicates, appaction.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, appaction.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, appaction.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, appaction.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, appaction.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, appaction.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, appaction.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, appaction.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, appaction.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, appaction.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, appaction.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, appaction.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, appaction.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, appaction.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, appaction.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, appaction.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, appaction.NameContainsFold(*i.NameContainsFold))
	}
	if i.Kind != nil {
		predicates = append(predicates, appaction.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, appaction.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, appaction.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, appaction.KindNotIn(i.KindNotIn...))
	}
	if i.Method != nil {
		predicates = append(predicates, appaction.MethodEQ(*i.Method))
	}
	if i.MethodNEQ != nil {
		predicates = append(predicates, appaction.MethodNEQ(*i.MethodNEQ))
	}
	if len(i.MethodIn) > 0 {
		predicates = append(predicates, appaction.MethodIn(i.MethodIn...))
	}
	if len(i.MethodNotIn) > 0 {
		predicates = append(predicates, appaction.MethodNotIn(i.MethodNotIn...))
	}

	if i.HasApp != nil {
		p := appaction.HasApp()
		if !*i.HasApp {
			p = appaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAppWith) > 0 {
		with := make([]predicate.App, 0, len(i.HasAppWith))
		for _, w := range i.HasAppWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAppWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, appaction.HasAppWith(with...))
	}
	if i.HasMenus != nil {
		p := appaction.HasMenus()
		if !*i.HasMenus {
			p = appaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMenusWith) > 0 {
		with := make([]predicate.AppMenu, 0, len(i.HasMenusWith))
		for _, w := range i.HasMenusWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMenusWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, appaction.HasMenusWith(with...))
	}
	if i.HasResources != nil {
		p := appaction.HasResources()
		if !*i.HasResources {
			p = appaction.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasResourcesWith) > 0 {
		with := make([]predicate.AppRes, 0, len(i.HasResourcesWith))
		for _, w := range i.HasResourcesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasResourcesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, appaction.HasResourcesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAppActionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return appaction.And(predicates...), nil
	}
}

// AppMenuWhereInput represents a where input for filtering AppMenu queries.
type AppMenuWhereInput struct {
	Predicates []predicate.AppMenu  `json:"-"`
	Not        *AppMenuWhereInput   `json:"not,omitempty"`
	Or         []*AppMenuWhereInput `json:"or,omitempty"`
	And        []*AppMenuWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`

	// "parent_id" field predicates.
	ParentID      *int  `json:"parentID,omitempty"`
	ParentIDNEQ   *int  `json:"parentIDNEQ,omitempty"`
	ParentIDIn    []int `json:"parentIDIn,omitempty"`
	ParentIDNotIn []int `json:"parentIDNotIn,omitempty"`
	ParentIDGT    *int  `json:"parentIDGT,omitempty"`
	ParentIDGTE   *int  `json:"parentIDGTE,omitempty"`
	ParentIDLT    *int  `json:"parentIDLT,omitempty"`
	ParentIDLTE   *int  `json:"parentIDLTE,omitempty"`

	// "kind" field predicates.
	Kind      *appmenu.Kind  `json:"kind,omitempty"`
	KindNEQ   *appmenu.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []appmenu.Kind `json:"kindIn,omitempty"`
	KindNotIn []appmenu.Kind `json:"kindNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "action_id" field predicates.
	ActionID       *int  `json:"actionID,omitempty"`
	ActionIDNEQ    *int  `json:"actionIDNEQ,omitempty"`
	ActionIDIn     []int `json:"actionIDIn,omitempty"`
	ActionIDNotIn  []int `json:"actionIDNotIn,omitempty"`
	ActionIDIsNil  bool  `json:"actionIDIsNil,omitempty"`
	ActionIDNotNil bool  `json:"actionIDNotNil,omitempty"`

	// "app" edge predicates.
	HasApp     *bool            `json:"hasApp,omitempty"`
	HasAppWith []*AppWhereInput `json:"hasAppWith,omitempty"`

	// "action" edge predicates.
	HasAction     *bool                  `json:"hasAction,omitempty"`
	HasActionWith []*AppActionWhereInput `json:"hasActionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AppMenuWhereInput) AddPredicates(predicates ...predicate.AppMenu) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AppMenuWhereInput filter on the AppMenuQuery builder.
func (i *AppMenuWhereInput) Filter(q *AppMenuQuery) (*AppMenuQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAppMenuWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAppMenuWhereInput is returned in case the AppMenuWhereInput is empty.
var ErrEmptyAppMenuWhereInput = errors.New("ent: empty predicate AppMenuWhereInput")

// P returns a predicate for filtering appmenus.
// An error is returned if the input is empty or invalid.
func (i *AppMenuWhereInput) P() (predicate.AppMenu, error) {
	var predicates []predicate.AppMenu
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, appmenu.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AppMenu, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, appmenu.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AppMenu, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, appmenu.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, appmenu.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, appmenu.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, appmenu.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, appmenu.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, appmenu.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, appmenu.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, appmenu.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, appmenu.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, appmenu.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, appmenu.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, appmenu.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, appmenu.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, appmenu.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, appmenu.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, appmenu.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, appmenu.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, appmenu.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, appmenu.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, appmenu.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, appmenu.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, appmenu.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, appmenu.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, appmenu.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, appmenu.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, appmenu.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, appmenu.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, appmenu.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, appmenu.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, appmenu.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, appmenu.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, appmenu.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, appmenu.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, appmenu.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, appmenu.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, appmenu.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, appmenu.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, appmenu.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, appmenu.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, appmenu.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, appmenu.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, appmenu.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, appmenu.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, appmenu.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, appmenu.UpdatedAtNotNil())
	}
	if i.AppID != nil {
		predicates = append(predicates, appmenu.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, appmenu.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, appmenu.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, appmenu.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.ParentID != nil {
		predicates = append(predicates, appmenu.ParentIDEQ(*i.ParentID))
	}
	if i.ParentIDNEQ != nil {
		predicates = append(predicates, appmenu.ParentIDNEQ(*i.ParentIDNEQ))
	}
	if len(i.ParentIDIn) > 0 {
		predicates = append(predicates, appmenu.ParentIDIn(i.ParentIDIn...))
	}
	if len(i.ParentIDNotIn) > 0 {
		predicates = append(predicates, appmenu.ParentIDNotIn(i.ParentIDNotIn...))
	}
	if i.ParentIDGT != nil {
		predicates = append(predicates, appmenu.ParentIDGT(*i.ParentIDGT))
	}
	if i.ParentIDGTE != nil {
		predicates = append(predicates, appmenu.ParentIDGTE(*i.ParentIDGTE))
	}
	if i.ParentIDLT != nil {
		predicates = append(predicates, appmenu.ParentIDLT(*i.ParentIDLT))
	}
	if i.ParentIDLTE != nil {
		predicates = append(predicates, appmenu.ParentIDLTE(*i.ParentIDLTE))
	}
	if i.Kind != nil {
		predicates = append(predicates, appmenu.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, appmenu.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, appmenu.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, appmenu.KindNotIn(i.KindNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, appmenu.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, appmenu.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, appmenu.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, appmenu.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, appmenu.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, appmenu.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, appmenu.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, appmenu.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, appmenu.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, appmenu.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, appmenu.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, appmenu.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, appmenu.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, appmenu.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, appmenu.NameContainsFold(*i.NameContainsFold))
	}
	if i.ActionID != nil {
		predicates = append(predicates, appmenu.ActionIDEQ(*i.ActionID))
	}
	if i.ActionIDNEQ != nil {
		predicates = append(predicates, appmenu.ActionIDNEQ(*i.ActionIDNEQ))
	}
	if len(i.ActionIDIn) > 0 {
		predicates = append(predicates, appmenu.ActionIDIn(i.ActionIDIn...))
	}
	if len(i.ActionIDNotIn) > 0 {
		predicates = append(predicates, appmenu.ActionIDNotIn(i.ActionIDNotIn...))
	}
	if i.ActionIDIsNil {
		predicates = append(predicates, appmenu.ActionIDIsNil())
	}
	if i.ActionIDNotNil {
		predicates = append(predicates, appmenu.ActionIDNotNil())
	}

	if i.HasApp != nil {
		p := appmenu.HasApp()
		if !*i.HasApp {
			p = appmenu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAppWith) > 0 {
		with := make([]predicate.App, 0, len(i.HasAppWith))
		for _, w := range i.HasAppWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAppWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, appmenu.HasAppWith(with...))
	}
	if i.HasAction != nil {
		p := appmenu.HasAction()
		if !*i.HasAction {
			p = appmenu.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActionWith) > 0 {
		with := make([]predicate.AppAction, 0, len(i.HasActionWith))
		for _, w := range i.HasActionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, appmenu.HasActionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAppMenuWhereInput
	case 1:
		return predicates[0], nil
	default:
		return appmenu.And(predicates...), nil
	}
}

// AppPolicyWhereInput represents a where input for filtering AppPolicy queries.
type AppPolicyWhereInput struct {
	Predicates []predicate.AppPolicy  `json:"-"`
	Not        *AppPolicyWhereInput   `json:"not,omitempty"`
	Or         []*AppPolicyWhereInput `json:"or,omitempty"`
	And        []*AppPolicyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "comments" field predicates.
	Comments             *string  `json:"comments,omitempty"`
	CommentsNEQ          *string  `json:"commentsNEQ,omitempty"`
	CommentsIn           []string `json:"commentsIn,omitempty"`
	CommentsNotIn        []string `json:"commentsNotIn,omitempty"`
	CommentsGT           *string  `json:"commentsGT,omitempty"`
	CommentsGTE          *string  `json:"commentsGTE,omitempty"`
	CommentsLT           *string  `json:"commentsLT,omitempty"`
	CommentsLTE          *string  `json:"commentsLTE,omitempty"`
	CommentsContains     *string  `json:"commentsContains,omitempty"`
	CommentsHasPrefix    *string  `json:"commentsHasPrefix,omitempty"`
	CommentsHasSuffix    *string  `json:"commentsHasSuffix,omitempty"`
	CommentsEqualFold    *string  `json:"commentsEqualFold,omitempty"`
	CommentsContainsFold *string  `json:"commentsContainsFold,omitempty"`

	// "version" field predicates.
	Version             *string  `json:"version,omitempty"`
	VersionNEQ          *string  `json:"versionNEQ,omitempty"`
	VersionIn           []string `json:"versionIn,omitempty"`
	VersionNotIn        []string `json:"versionNotIn,omitempty"`
	VersionGT           *string  `json:"versionGT,omitempty"`
	VersionGTE          *string  `json:"versionGTE,omitempty"`
	VersionLT           *string  `json:"versionLT,omitempty"`
	VersionLTE          *string  `json:"versionLTE,omitempty"`
	VersionContains     *string  `json:"versionContains,omitempty"`
	VersionHasPrefix    *string  `json:"versionHasPrefix,omitempty"`
	VersionHasSuffix    *string  `json:"versionHasSuffix,omitempty"`
	VersionEqualFold    *string  `json:"versionEqualFold,omitempty"`
	VersionContainsFold *string  `json:"versionContainsFold,omitempty"`

	// "auto_grant" field predicates.
	AutoGrant    *bool `json:"autoGrant,omitempty"`
	AutoGrantNEQ *bool `json:"autoGrantNEQ,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "app" edge predicates.
	HasApp     *bool            `json:"hasApp,omitempty"`
	HasAppWith []*AppWhereInput `json:"hasAppWith,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool                `json:"hasRoles,omitempty"`
	HasRolesWith []*AppRoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AppPolicyWhereInput) AddPredicates(predicates ...predicate.AppPolicy) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AppPolicyWhereInput filter on the AppPolicyQuery builder.
func (i *AppPolicyWhereInput) Filter(q *AppPolicyQuery) (*AppPolicyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAppPolicyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAppPolicyWhereInput is returned in case the AppPolicyWhereInput is empty.
var ErrEmptyAppPolicyWhereInput = errors.New("ent: empty predicate AppPolicyWhereInput")

// P returns a predicate for filtering apppolicies.
// An error is returned if the input is empty or invalid.
func (i *AppPolicyWhereInput) P() (predicate.AppPolicy, error) {
	var predicates []predicate.AppPolicy
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apppolicy.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AppPolicy, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apppolicy.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AppPolicy, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apppolicy.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apppolicy.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apppolicy.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apppolicy.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apppolicy.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apppolicy.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apppolicy.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apppolicy.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apppolicy.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, apppolicy.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, apppolicy.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, apppolicy.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, apppolicy.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, apppolicy.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, apppolicy.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, apppolicy.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, apppolicy.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apppolicy.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apppolicy.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apppolicy.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apppolicy.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apppolicy.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apppolicy.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apppolicy.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apppolicy.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, apppolicy.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, apppolicy.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, apppolicy.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, apppolicy.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, apppolicy.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, apppolicy.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, apppolicy.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, apppolicy.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, apppolicy.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, apppolicy.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, apppolicy.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, apppolicy.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, apppolicy.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, apppolicy.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, apppolicy.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, apppolicy.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, apppolicy.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, apppolicy.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, apppolicy.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, apppolicy.UpdatedAtNotNil())
	}
	if i.AppID != nil {
		predicates = append(predicates, apppolicy.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, apppolicy.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, apppolicy.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, apppolicy.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, apppolicy.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, apppolicy.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, apppolicy.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, apppolicy.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, apppolicy.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, apppolicy.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, apppolicy.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, apppolicy.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, apppolicy.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, apppolicy.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, apppolicy.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, apppolicy.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, apppolicy.NameContainsFold(*i.NameContainsFold))
	}
	if i.Comments != nil {
		predicates = append(predicates, apppolicy.CommentsEQ(*i.Comments))
	}
	if i.CommentsNEQ != nil {
		predicates = append(predicates, apppolicy.CommentsNEQ(*i.CommentsNEQ))
	}
	if len(i.CommentsIn) > 0 {
		predicates = append(predicates, apppolicy.CommentsIn(i.CommentsIn...))
	}
	if len(i.CommentsNotIn) > 0 {
		predicates = append(predicates, apppolicy.CommentsNotIn(i.CommentsNotIn...))
	}
	if i.CommentsGT != nil {
		predicates = append(predicates, apppolicy.CommentsGT(*i.CommentsGT))
	}
	if i.CommentsGTE != nil {
		predicates = append(predicates, apppolicy.CommentsGTE(*i.CommentsGTE))
	}
	if i.CommentsLT != nil {
		predicates = append(predicates, apppolicy.CommentsLT(*i.CommentsLT))
	}
	if i.CommentsLTE != nil {
		predicates = append(predicates, apppolicy.CommentsLTE(*i.CommentsLTE))
	}
	if i.CommentsContains != nil {
		predicates = append(predicates, apppolicy.CommentsContains(*i.CommentsContains))
	}
	if i.CommentsHasPrefix != nil {
		predicates = append(predicates, apppolicy.CommentsHasPrefix(*i.CommentsHasPrefix))
	}
	if i.CommentsHasSuffix != nil {
		predicates = append(predicates, apppolicy.CommentsHasSuffix(*i.CommentsHasSuffix))
	}
	if i.CommentsEqualFold != nil {
		predicates = append(predicates, apppolicy.CommentsEqualFold(*i.CommentsEqualFold))
	}
	if i.CommentsContainsFold != nil {
		predicates = append(predicates, apppolicy.CommentsContainsFold(*i.CommentsContainsFold))
	}
	if i.Version != nil {
		predicates = append(predicates, apppolicy.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, apppolicy.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, apppolicy.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, apppolicy.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, apppolicy.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, apppolicy.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, apppolicy.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, apppolicy.VersionLTE(*i.VersionLTE))
	}
	if i.VersionContains != nil {
		predicates = append(predicates, apppolicy.VersionContains(*i.VersionContains))
	}
	if i.VersionHasPrefix != nil {
		predicates = append(predicates, apppolicy.VersionHasPrefix(*i.VersionHasPrefix))
	}
	if i.VersionHasSuffix != nil {
		predicates = append(predicates, apppolicy.VersionHasSuffix(*i.VersionHasSuffix))
	}
	if i.VersionEqualFold != nil {
		predicates = append(predicates, apppolicy.VersionEqualFold(*i.VersionEqualFold))
	}
	if i.VersionContainsFold != nil {
		predicates = append(predicates, apppolicy.VersionContainsFold(*i.VersionContainsFold))
	}
	if i.AutoGrant != nil {
		predicates = append(predicates, apppolicy.AutoGrantEQ(*i.AutoGrant))
	}
	if i.AutoGrantNEQ != nil {
		predicates = append(predicates, apppolicy.AutoGrantNEQ(*i.AutoGrantNEQ))
	}
	if i.Status != nil {
		predicates = append(predicates, apppolicy.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, apppolicy.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, apppolicy.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, apppolicy.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, apppolicy.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, apppolicy.StatusNotNil())
	}

	if i.HasApp != nil {
		p := apppolicy.HasApp()
		if !*i.HasApp {
			p = apppolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAppWith) > 0 {
		with := make([]predicate.App, 0, len(i.HasAppWith))
		for _, w := range i.HasAppWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAppWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apppolicy.HasAppWith(with...))
	}
	if i.HasRoles != nil {
		p := apppolicy.HasRoles()
		if !*i.HasRoles {
			p = apppolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.AppRole, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apppolicy.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAppPolicyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apppolicy.And(predicates...), nil
	}
}

// AppResWhereInput represents a where input for filtering AppRes queries.
type AppResWhereInput struct {
	Predicates []predicate.AppRes  `json:"-"`
	Not        *AppResWhereInput   `json:"not,omitempty"`
	Or         []*AppResWhereInput `json:"or,omitempty"`
	And        []*AppResWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "type_name" field predicates.
	TypeName             *string  `json:"typeName,omitempty"`
	TypeNameNEQ          *string  `json:"typeNameNEQ,omitempty"`
	TypeNameIn           []string `json:"typeNameIn,omitempty"`
	TypeNameNotIn        []string `json:"typeNameNotIn,omitempty"`
	TypeNameGT           *string  `json:"typeNameGT,omitempty"`
	TypeNameGTE          *string  `json:"typeNameGTE,omitempty"`
	TypeNameLT           *string  `json:"typeNameLT,omitempty"`
	TypeNameLTE          *string  `json:"typeNameLTE,omitempty"`
	TypeNameContains     *string  `json:"typeNameContains,omitempty"`
	TypeNameHasPrefix    *string  `json:"typeNameHasPrefix,omitempty"`
	TypeNameHasSuffix    *string  `json:"typeNameHasSuffix,omitempty"`
	TypeNameEqualFold    *string  `json:"typeNameEqualFold,omitempty"`
	TypeNameContainsFold *string  `json:"typeNameContainsFold,omitempty"`

	// "arn_pattern" field predicates.
	ArnPattern             *string  `json:"arnPattern,omitempty"`
	ArnPatternNEQ          *string  `json:"arnPatternNEQ,omitempty"`
	ArnPatternIn           []string `json:"arnPatternIn,omitempty"`
	ArnPatternNotIn        []string `json:"arnPatternNotIn,omitempty"`
	ArnPatternGT           *string  `json:"arnPatternGT,omitempty"`
	ArnPatternGTE          *string  `json:"arnPatternGTE,omitempty"`
	ArnPatternLT           *string  `json:"arnPatternLT,omitempty"`
	ArnPatternLTE          *string  `json:"arnPatternLTE,omitempty"`
	ArnPatternContains     *string  `json:"arnPatternContains,omitempty"`
	ArnPatternHasPrefix    *string  `json:"arnPatternHasPrefix,omitempty"`
	ArnPatternHasSuffix    *string  `json:"arnPatternHasSuffix,omitempty"`
	ArnPatternEqualFold    *string  `json:"arnPatternEqualFold,omitempty"`
	ArnPatternContainsFold *string  `json:"arnPatternContainsFold,omitempty"`

	// "app" edge predicates.
	HasApp     *bool            `json:"hasApp,omitempty"`
	HasAppWith []*AppWhereInput `json:"hasAppWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AppResWhereInput) AddPredicates(predicates ...predicate.AppRes) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AppResWhereInput filter on the AppResQuery builder.
func (i *AppResWhereInput) Filter(q *AppResQuery) (*AppResQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAppResWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAppResWhereInput is returned in case the AppResWhereInput is empty.
var ErrEmptyAppResWhereInput = errors.New("ent: empty predicate AppResWhereInput")

// P returns a predicate for filtering appresslice.
// An error is returned if the input is empty or invalid.
func (i *AppResWhereInput) P() (predicate.AppRes, error) {
	var predicates []predicate.AppRes
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, appres.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AppRes, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, appres.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AppRes, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, appres.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, appres.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, appres.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, appres.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, appres.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, appres.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, appres.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, appres.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, appres.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, appres.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, appres.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, appres.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, appres.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, appres.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, appres.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, appres.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, appres.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, appres.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, appres.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, appres.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, appres.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, appres.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, appres.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, appres.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, appres.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, appres.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, appres.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, appres.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, appres.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, appres.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, appres.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, appres.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, appres.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, appres.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, appres.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, appres.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, appres.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, appres.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, appres.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, appres.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, appres.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, appres.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, appres.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, appres.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, appres.UpdatedAtNotNil())
	}
	if i.AppID != nil {
		predicates = append(predicates, appres.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, appres.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, appres.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, appres.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, appres.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, appres.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, appres.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, appres.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, appres.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, appres.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, appres.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, appres.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, appres.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, appres.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, appres.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, appres.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, appres.NameContainsFold(*i.NameContainsFold))
	}
	if i.TypeName != nil {
		predicates = append(predicates, appres.TypeNameEQ(*i.TypeName))
	}
	if i.TypeNameNEQ != nil {
		predicates = append(predicates, appres.TypeNameNEQ(*i.TypeNameNEQ))
	}
	if len(i.TypeNameIn) > 0 {
		predicates = append(predicates, appres.TypeNameIn(i.TypeNameIn...))
	}
	if len(i.TypeNameNotIn) > 0 {
		predicates = append(predicates, appres.TypeNameNotIn(i.TypeNameNotIn...))
	}
	if i.TypeNameGT != nil {
		predicates = append(predicates, appres.TypeNameGT(*i.TypeNameGT))
	}
	if i.TypeNameGTE != nil {
		predicates = append(predicates, appres.TypeNameGTE(*i.TypeNameGTE))
	}
	if i.TypeNameLT != nil {
		predicates = append(predicates, appres.TypeNameLT(*i.TypeNameLT))
	}
	if i.TypeNameLTE != nil {
		predicates = append(predicates, appres.TypeNameLTE(*i.TypeNameLTE))
	}
	if i.TypeNameContains != nil {
		predicates = append(predicates, appres.TypeNameContains(*i.TypeNameContains))
	}
	if i.TypeNameHasPrefix != nil {
		predicates = append(predicates, appres.TypeNameHasPrefix(*i.TypeNameHasPrefix))
	}
	if i.TypeNameHasSuffix != nil {
		predicates = append(predicates, appres.TypeNameHasSuffix(*i.TypeNameHasSuffix))
	}
	if i.TypeNameEqualFold != nil {
		predicates = append(predicates, appres.TypeNameEqualFold(*i.TypeNameEqualFold))
	}
	if i.TypeNameContainsFold != nil {
		predicates = append(predicates, appres.TypeNameContainsFold(*i.TypeNameContainsFold))
	}
	if i.ArnPattern != nil {
		predicates = append(predicates, appres.ArnPatternEQ(*i.ArnPattern))
	}
	if i.ArnPatternNEQ != nil {
		predicates = append(predicates, appres.ArnPatternNEQ(*i.ArnPatternNEQ))
	}
	if len(i.ArnPatternIn) > 0 {
		predicates = append(predicates, appres.ArnPatternIn(i.ArnPatternIn...))
	}
	if len(i.ArnPatternNotIn) > 0 {
		predicates = append(predicates, appres.ArnPatternNotIn(i.ArnPatternNotIn...))
	}
	if i.ArnPatternGT != nil {
		predicates = append(predicates, appres.ArnPatternGT(*i.ArnPatternGT))
	}
	if i.ArnPatternGTE != nil {
		predicates = append(predicates, appres.ArnPatternGTE(*i.ArnPatternGTE))
	}
	if i.ArnPatternLT != nil {
		predicates = append(predicates, appres.ArnPatternLT(*i.ArnPatternLT))
	}
	if i.ArnPatternLTE != nil {
		predicates = append(predicates, appres.ArnPatternLTE(*i.ArnPatternLTE))
	}
	if i.ArnPatternContains != nil {
		predicates = append(predicates, appres.ArnPatternContains(*i.ArnPatternContains))
	}
	if i.ArnPatternHasPrefix != nil {
		predicates = append(predicates, appres.ArnPatternHasPrefix(*i.ArnPatternHasPrefix))
	}
	if i.ArnPatternHasSuffix != nil {
		predicates = append(predicates, appres.ArnPatternHasSuffix(*i.ArnPatternHasSuffix))
	}
	if i.ArnPatternEqualFold != nil {
		predicates = append(predicates, appres.ArnPatternEqualFold(*i.ArnPatternEqualFold))
	}
	if i.ArnPatternContainsFold != nil {
		predicates = append(predicates, appres.ArnPatternContainsFold(*i.ArnPatternContainsFold))
	}

	if i.HasApp != nil {
		p := appres.HasApp()
		if !*i.HasApp {
			p = appres.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAppWith) > 0 {
		with := make([]predicate.App, 0, len(i.HasAppWith))
		for _, w := range i.HasAppWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAppWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, appres.HasAppWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAppResWhereInput
	case 1:
		return predicates[0], nil
	default:
		return appres.And(predicates...), nil
	}
}

// AppRoleWhereInput represents a where input for filtering AppRole queries.
type AppRoleWhereInput struct {
	Predicates []predicate.AppRole  `json:"-"`
	Not        *AppRoleWhereInput   `json:"not,omitempty"`
	Or         []*AppRoleWhereInput `json:"or,omitempty"`
	And        []*AppRoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "auto_grant" field predicates.
	AutoGrant    *bool `json:"autoGrant,omitempty"`
	AutoGrantNEQ *bool `json:"autoGrantNEQ,omitempty"`

	// "editable" field predicates.
	Editable    *bool `json:"editable,omitempty"`
	EditableNEQ *bool `json:"editableNEQ,omitempty"`

	// "app" edge predicates.
	HasApp     *bool            `json:"hasApp,omitempty"`
	HasAppWith []*AppWhereInput `json:"hasAppWith,omitempty"`

	// "policies" edge predicates.
	HasPolicies     *bool                  `json:"hasPolicies,omitempty"`
	HasPoliciesWith []*AppPolicyWhereInput `json:"hasPoliciesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AppRoleWhereInput) AddPredicates(predicates ...predicate.AppRole) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AppRoleWhereInput filter on the AppRoleQuery builder.
func (i *AppRoleWhereInput) Filter(q *AppRoleQuery) (*AppRoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAppRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAppRoleWhereInput is returned in case the AppRoleWhereInput is empty.
var ErrEmptyAppRoleWhereInput = errors.New("ent: empty predicate AppRoleWhereInput")

// P returns a predicate for filtering approles.
// An error is returned if the input is empty or invalid.
func (i *AppRoleWhereInput) P() (predicate.AppRole, error) {
	var predicates []predicate.AppRole
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, approle.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AppRole, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, approle.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AppRole, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, approle.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, approle.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, approle.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, approle.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, approle.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, approle.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, approle.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, approle.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, approle.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, approle.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, approle.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, approle.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, approle.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, approle.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, approle.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, approle.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, approle.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, approle.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, approle.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, approle.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, approle.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, approle.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, approle.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, approle.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, approle.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, approle.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, approle.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, approle.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, approle.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, approle.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, approle.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, approle.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, approle.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, approle.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, approle.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, approle.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, approle.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, approle.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, approle.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, approle.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, approle.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, approle.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, approle.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, approle.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, approle.UpdatedAtNotNil())
	}
	if i.AppID != nil {
		predicates = append(predicates, approle.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, approle.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, approle.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, approle.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, approle.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, approle.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, approle.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, approle.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, approle.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, approle.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, approle.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, approle.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, approle.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, approle.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, approle.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, approle.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, approle.NameContainsFold(*i.NameContainsFold))
	}
	if i.AutoGrant != nil {
		predicates = append(predicates, approle.AutoGrantEQ(*i.AutoGrant))
	}
	if i.AutoGrantNEQ != nil {
		predicates = append(predicates, approle.AutoGrantNEQ(*i.AutoGrantNEQ))
	}
	if i.Editable != nil {
		predicates = append(predicates, approle.EditableEQ(*i.Editable))
	}
	if i.EditableNEQ != nil {
		predicates = append(predicates, approle.EditableNEQ(*i.EditableNEQ))
	}

	if i.HasApp != nil {
		p := approle.HasApp()
		if !*i.HasApp {
			p = approle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAppWith) > 0 {
		with := make([]predicate.App, 0, len(i.HasAppWith))
		for _, w := range i.HasAppWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAppWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, approle.HasAppWith(with...))
	}
	if i.HasPolicies != nil {
		p := approle.HasPolicies()
		if !*i.HasPolicies {
			p = approle.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPoliciesWith) > 0 {
		with := make([]predicate.AppPolicy, 0, len(i.HasPoliciesWith))
		for _, w := range i.HasPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, approle.HasPoliciesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAppRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return approle.And(predicates...), nil
	}
}

// OrgWhereInput represents a where input for filtering Org queries.
type OrgWhereInput struct {
	Predicates []predicate.Org  `json:"-"`
	Not        *OrgWhereInput   `json:"not,omitempty"`
	Or         []*OrgWhereInput `json:"or,omitempty"`
	And        []*OrgWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "owner_id" field predicates.
	OwnerID       *int  `json:"ownerID,omitempty"`
	OwnerIDNEQ    *int  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn     []int `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn  []int `json:"ownerIDNotIn,omitempty"`
	OwnerIDIsNil  bool  `json:"ownerIDIsNil,omitempty"`
	OwnerIDNotNil bool  `json:"ownerIDNotNil,omitempty"`

	// "parent_id" field predicates.
	ParentID      *int  `json:"parentID,omitempty"`
	ParentIDNEQ   *int  `json:"parentIDNEQ,omitempty"`
	ParentIDIn    []int `json:"parentIDIn,omitempty"`
	ParentIDNotIn []int `json:"parentIDNotIn,omitempty"`

	// "domain" field predicates.
	Domain             *string  `json:"domain,omitempty"`
	DomainNEQ          *string  `json:"domainNEQ,omitempty"`
	DomainIn           []string `json:"domainIn,omitempty"`
	DomainNotIn        []string `json:"domainNotIn,omitempty"`
	DomainGT           *string  `json:"domainGT,omitempty"`
	DomainGTE          *string  `json:"domainGTE,omitempty"`
	DomainLT           *string  `json:"domainLT,omitempty"`
	DomainLTE          *string  `json:"domainLTE,omitempty"`
	DomainContains     *string  `json:"domainContains,omitempty"`
	DomainHasPrefix    *string  `json:"domainHasPrefix,omitempty"`
	DomainHasSuffix    *string  `json:"domainHasSuffix,omitempty"`
	DomainIsNil        bool     `json:"domainIsNil,omitempty"`
	DomainNotNil       bool     `json:"domainNotNil,omitempty"`
	DomainEqualFold    *string  `json:"domainEqualFold,omitempty"`
	DomainContainsFold *string  `json:"domainContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeIsNil        bool     `json:"codeIsNil,omitempty"`
	CodeNotNil       bool     `json:"codeNotNil,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "path" field predicates.
	Path             *string  `json:"path,omitempty"`
	PathNEQ          *string  `json:"pathNEQ,omitempty"`
	PathIn           []string `json:"pathIn,omitempty"`
	PathNotIn        []string `json:"pathNotIn,omitempty"`
	PathGT           *string  `json:"pathGT,omitempty"`
	PathGTE          *string  `json:"pathGTE,omitempty"`
	PathLT           *string  `json:"pathLT,omitempty"`
	PathLTE          *string  `json:"pathLTE,omitempty"`
	PathContains     *string  `json:"pathContains,omitempty"`
	PathHasPrefix    *string  `json:"pathHasPrefix,omitempty"`
	PathHasSuffix    *string  `json:"pathHasSuffix,omitempty"`
	PathIsNil        bool     `json:"pathIsNil,omitempty"`
	PathNotNil       bool     `json:"pathNotNil,omitempty"`
	PathEqualFold    *string  `json:"pathEqualFold,omitempty"`
	PathContainsFold *string  `json:"pathContainsFold,omitempty"`

	// "country_code" field predicates.
	CountryCode             *string  `json:"countryCode,omitempty"`
	CountryCodeNEQ          *string  `json:"countryCodeNEQ,omitempty"`
	CountryCodeIn           []string `json:"countryCodeIn,omitempty"`
	CountryCodeNotIn        []string `json:"countryCodeNotIn,omitempty"`
	CountryCodeGT           *string  `json:"countryCodeGT,omitempty"`
	CountryCodeGTE          *string  `json:"countryCodeGTE,omitempty"`
	CountryCodeLT           *string  `json:"countryCodeLT,omitempty"`
	CountryCodeLTE          *string  `json:"countryCodeLTE,omitempty"`
	CountryCodeContains     *string  `json:"countryCodeContains,omitempty"`
	CountryCodeHasPrefix    *string  `json:"countryCodeHasPrefix,omitempty"`
	CountryCodeHasSuffix    *string  `json:"countryCodeHasSuffix,omitempty"`
	CountryCodeIsNil        bool     `json:"countryCodeIsNil,omitempty"`
	CountryCodeNotNil       bool     `json:"countryCodeNotNil,omitempty"`
	CountryCodeEqualFold    *string  `json:"countryCodeEqualFold,omitempty"`
	CountryCodeContainsFold *string  `json:"countryCodeContainsFold,omitempty"`

	// "timezone" field predicates.
	Timezone             *string  `json:"timezone,omitempty"`
	TimezoneNEQ          *string  `json:"timezoneNEQ,omitempty"`
	TimezoneIn           []string `json:"timezoneIn,omitempty"`
	TimezoneNotIn        []string `json:"timezoneNotIn,omitempty"`
	TimezoneGT           *string  `json:"timezoneGT,omitempty"`
	TimezoneGTE          *string  `json:"timezoneGTE,omitempty"`
	TimezoneLT           *string  `json:"timezoneLT,omitempty"`
	TimezoneLTE          *string  `json:"timezoneLTE,omitempty"`
	TimezoneContains     *string  `json:"timezoneContains,omitempty"`
	TimezoneHasPrefix    *string  `json:"timezoneHasPrefix,omitempty"`
	TimezoneHasSuffix    *string  `json:"timezoneHasSuffix,omitempty"`
	TimezoneIsNil        bool     `json:"timezoneIsNil,omitempty"`
	TimezoneNotNil       bool     `json:"timezoneNotNil,omitempty"`
	TimezoneEqualFold    *string  `json:"timezoneEqualFold,omitempty"`
	TimezoneContainsFold *string  `json:"timezoneContainsFold,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool            `json:"hasParent,omitempty"`
	HasParentWith []*OrgWhereInput `json:"hasParentWith,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool            `json:"hasChildren,omitempty"`
	HasChildrenWith []*OrgWhereInput `json:"hasChildrenWith,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "roles_and_groups" edge predicates.
	HasRolesAndGroups     *bool                `json:"hasRolesAndGroups,omitempty"`
	HasRolesAndGroupsWith []*OrgRoleWhereInput `json:"hasRolesAndGroupsWith,omitempty"`

	// "permissions" edge predicates.
	HasPermissions     *bool                   `json:"hasPermissions,omitempty"`
	HasPermissionsWith []*PermissionWhereInput `json:"hasPermissionsWith,omitempty"`

	// "policies" edge predicates.
	HasPolicies     *bool                  `json:"hasPolicies,omitempty"`
	HasPoliciesWith []*OrgPolicyWhereInput `json:"hasPoliciesWith,omitempty"`

	// "apps" edge predicates.
	HasApps     *bool            `json:"hasApps,omitempty"`
	HasAppsWith []*AppWhereInput `json:"hasAppsWith,omitempty"`

	// "org_user" edge predicates.
	HasOrgUser     *bool                `json:"hasOrgUser,omitempty"`
	HasOrgUserWith []*OrgUserWhereInput `json:"hasOrgUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrgWhereInput) AddPredicates(predicates ...predicate.Org) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrgWhereInput filter on the OrgQuery builder.
func (i *OrgWhereInput) Filter(q *OrgQuery) (*OrgQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrgWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrgWhereInput is returned in case the OrgWhereInput is empty.
var ErrEmptyOrgWhereInput = errors.New("ent: empty predicate OrgWhereInput")

// P returns a predicate for filtering orgs.
// An error is returned if the input is empty or invalid.
func (i *OrgWhereInput) P() (predicate.Org, error) {
	var predicates []predicate.Org
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, org.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Org, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, org.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Org, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, org.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, org.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, org.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, org.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, org.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, org.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, org.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, org.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, org.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, org.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, org.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, org.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, org.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, org.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, org.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, org.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, org.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, org.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, org.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, org.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, org.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, org.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, org.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, org.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, org.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, org.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, org.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, org.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, org.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, org.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, org.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, org.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, org.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, org.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, org.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, org.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, org.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, org.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, org.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, org.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, org.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, org.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, org.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, org.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, org.UpdatedAtNotNil())
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, org.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, org.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, org.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, org.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, org.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, org.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, org.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, org.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, org.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, org.DeletedAtNotNil())
	}
	if i.OwnerID != nil {
		predicates = append(predicates, org.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, org.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, org.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, org.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDIsNil {
		predicates = append(predicates, org.OwnerIDIsNil())
	}
	if i.OwnerIDNotNil {
		predicates = append(predicates, org.OwnerIDNotNil())
	}
	if i.ParentID != nil {
		predicates = append(predicates, org.ParentIDEQ(*i.ParentID))
	}
	if i.ParentIDNEQ != nil {
		predicates = append(predicates, org.ParentIDNEQ(*i.ParentIDNEQ))
	}
	if len(i.ParentIDIn) > 0 {
		predicates = append(predicates, org.ParentIDIn(i.ParentIDIn...))
	}
	if len(i.ParentIDNotIn) > 0 {
		predicates = append(predicates, org.ParentIDNotIn(i.ParentIDNotIn...))
	}
	if i.Domain != nil {
		predicates = append(predicates, org.DomainEQ(*i.Domain))
	}
	if i.DomainNEQ != nil {
		predicates = append(predicates, org.DomainNEQ(*i.DomainNEQ))
	}
	if len(i.DomainIn) > 0 {
		predicates = append(predicates, org.DomainIn(i.DomainIn...))
	}
	if len(i.DomainNotIn) > 0 {
		predicates = append(predicates, org.DomainNotIn(i.DomainNotIn...))
	}
	if i.DomainGT != nil {
		predicates = append(predicates, org.DomainGT(*i.DomainGT))
	}
	if i.DomainGTE != nil {
		predicates = append(predicates, org.DomainGTE(*i.DomainGTE))
	}
	if i.DomainLT != nil {
		predicates = append(predicates, org.DomainLT(*i.DomainLT))
	}
	if i.DomainLTE != nil {
		predicates = append(predicates, org.DomainLTE(*i.DomainLTE))
	}
	if i.DomainContains != nil {
		predicates = append(predicates, org.DomainContains(*i.DomainContains))
	}
	if i.DomainHasPrefix != nil {
		predicates = append(predicates, org.DomainHasPrefix(*i.DomainHasPrefix))
	}
	if i.DomainHasSuffix != nil {
		predicates = append(predicates, org.DomainHasSuffix(*i.DomainHasSuffix))
	}
	if i.DomainIsNil {
		predicates = append(predicates, org.DomainIsNil())
	}
	if i.DomainNotNil {
		predicates = append(predicates, org.DomainNotNil())
	}
	if i.DomainEqualFold != nil {
		predicates = append(predicates, org.DomainEqualFold(*i.DomainEqualFold))
	}
	if i.DomainContainsFold != nil {
		predicates = append(predicates, org.DomainContainsFold(*i.DomainContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, org.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, org.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, org.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, org.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, org.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, org.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, org.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, org.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, org.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, org.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, org.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeIsNil {
		predicates = append(predicates, org.CodeIsNil())
	}
	if i.CodeNotNil {
		predicates = append(predicates, org.CodeNotNil())
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, org.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, org.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, org.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, org.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, org.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, org.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, org.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, org.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, org.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, org.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, org.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, org.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, org.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, org.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, org.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, org.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, org.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, org.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, org.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, org.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, org.StatusNotNil())
	}
	if i.Path != nil {
		predicates = append(predicates, org.PathEQ(*i.Path))
	}
	if i.PathNEQ != nil {
		predicates = append(predicates, org.PathNEQ(*i.PathNEQ))
	}
	if len(i.PathIn) > 0 {
		predicates = append(predicates, org.PathIn(i.PathIn...))
	}
	if len(i.PathNotIn) > 0 {
		predicates = append(predicates, org.PathNotIn(i.PathNotIn...))
	}
	if i.PathGT != nil {
		predicates = append(predicates, org.PathGT(*i.PathGT))
	}
	if i.PathGTE != nil {
		predicates = append(predicates, org.PathGTE(*i.PathGTE))
	}
	if i.PathLT != nil {
		predicates = append(predicates, org.PathLT(*i.PathLT))
	}
	if i.PathLTE != nil {
		predicates = append(predicates, org.PathLTE(*i.PathLTE))
	}
	if i.PathContains != nil {
		predicates = append(predicates, org.PathContains(*i.PathContains))
	}
	if i.PathHasPrefix != nil {
		predicates = append(predicates, org.PathHasPrefix(*i.PathHasPrefix))
	}
	if i.PathHasSuffix != nil {
		predicates = append(predicates, org.PathHasSuffix(*i.PathHasSuffix))
	}
	if i.PathIsNil {
		predicates = append(predicates, org.PathIsNil())
	}
	if i.PathNotNil {
		predicates = append(predicates, org.PathNotNil())
	}
	if i.PathEqualFold != nil {
		predicates = append(predicates, org.PathEqualFold(*i.PathEqualFold))
	}
	if i.PathContainsFold != nil {
		predicates = append(predicates, org.PathContainsFold(*i.PathContainsFold))
	}
	if i.CountryCode != nil {
		predicates = append(predicates, org.CountryCodeEQ(*i.CountryCode))
	}
	if i.CountryCodeNEQ != nil {
		predicates = append(predicates, org.CountryCodeNEQ(*i.CountryCodeNEQ))
	}
	if len(i.CountryCodeIn) > 0 {
		predicates = append(predicates, org.CountryCodeIn(i.CountryCodeIn...))
	}
	if len(i.CountryCodeNotIn) > 0 {
		predicates = append(predicates, org.CountryCodeNotIn(i.CountryCodeNotIn...))
	}
	if i.CountryCodeGT != nil {
		predicates = append(predicates, org.CountryCodeGT(*i.CountryCodeGT))
	}
	if i.CountryCodeGTE != nil {
		predicates = append(predicates, org.CountryCodeGTE(*i.CountryCodeGTE))
	}
	if i.CountryCodeLT != nil {
		predicates = append(predicates, org.CountryCodeLT(*i.CountryCodeLT))
	}
	if i.CountryCodeLTE != nil {
		predicates = append(predicates, org.CountryCodeLTE(*i.CountryCodeLTE))
	}
	if i.CountryCodeContains != nil {
		predicates = append(predicates, org.CountryCodeContains(*i.CountryCodeContains))
	}
	if i.CountryCodeHasPrefix != nil {
		predicates = append(predicates, org.CountryCodeHasPrefix(*i.CountryCodeHasPrefix))
	}
	if i.CountryCodeHasSuffix != nil {
		predicates = append(predicates, org.CountryCodeHasSuffix(*i.CountryCodeHasSuffix))
	}
	if i.CountryCodeIsNil {
		predicates = append(predicates, org.CountryCodeIsNil())
	}
	if i.CountryCodeNotNil {
		predicates = append(predicates, org.CountryCodeNotNil())
	}
	if i.CountryCodeEqualFold != nil {
		predicates = append(predicates, org.CountryCodeEqualFold(*i.CountryCodeEqualFold))
	}
	if i.CountryCodeContainsFold != nil {
		predicates = append(predicates, org.CountryCodeContainsFold(*i.CountryCodeContainsFold))
	}
	if i.Timezone != nil {
		predicates = append(predicates, org.TimezoneEQ(*i.Timezone))
	}
	if i.TimezoneNEQ != nil {
		predicates = append(predicates, org.TimezoneNEQ(*i.TimezoneNEQ))
	}
	if len(i.TimezoneIn) > 0 {
		predicates = append(predicates, org.TimezoneIn(i.TimezoneIn...))
	}
	if len(i.TimezoneNotIn) > 0 {
		predicates = append(predicates, org.TimezoneNotIn(i.TimezoneNotIn...))
	}
	if i.TimezoneGT != nil {
		predicates = append(predicates, org.TimezoneGT(*i.TimezoneGT))
	}
	if i.TimezoneGTE != nil {
		predicates = append(predicates, org.TimezoneGTE(*i.TimezoneGTE))
	}
	if i.TimezoneLT != nil {
		predicates = append(predicates, org.TimezoneLT(*i.TimezoneLT))
	}
	if i.TimezoneLTE != nil {
		predicates = append(predicates, org.TimezoneLTE(*i.TimezoneLTE))
	}
	if i.TimezoneContains != nil {
		predicates = append(predicates, org.TimezoneContains(*i.TimezoneContains))
	}
	if i.TimezoneHasPrefix != nil {
		predicates = append(predicates, org.TimezoneHasPrefix(*i.TimezoneHasPrefix))
	}
	if i.TimezoneHasSuffix != nil {
		predicates = append(predicates, org.TimezoneHasSuffix(*i.TimezoneHasSuffix))
	}
	if i.TimezoneIsNil {
		predicates = append(predicates, org.TimezoneIsNil())
	}
	if i.TimezoneNotNil {
		predicates = append(predicates, org.TimezoneNotNil())
	}
	if i.TimezoneEqualFold != nil {
		predicates = append(predicates, org.TimezoneEqualFold(*i.TimezoneEqualFold))
	}
	if i.TimezoneContainsFold != nil {
		predicates = append(predicates, org.TimezoneContainsFold(*i.TimezoneContainsFold))
	}

	if i.HasParent != nil {
		p := org.HasParent()
		if !*i.HasParent {
			p = org.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Org, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, org.HasParentWith(with...))
	}
	if i.HasChildren != nil {
		p := org.HasChildren()
		if !*i.HasChildren {
			p = org.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Org, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, org.HasChildrenWith(with...))
	}
	if i.HasOwner != nil {
		p := org.HasOwner()
		if !*i.HasOwner {
			p = org.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, org.HasOwnerWith(with...))
	}
	if i.HasUsers != nil {
		p := org.HasUsers()
		if !*i.HasUsers {
			p = org.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, org.HasUsersWith(with...))
	}
	if i.HasRolesAndGroups != nil {
		p := org.HasRolesAndGroups()
		if !*i.HasRolesAndGroups {
			p = org.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesAndGroupsWith) > 0 {
		with := make([]predicate.OrgRole, 0, len(i.HasRolesAndGroupsWith))
		for _, w := range i.HasRolesAndGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesAndGroupsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, org.HasRolesAndGroupsWith(with...))
	}
	if i.HasPermissions != nil {
		p := org.HasPermissions()
		if !*i.HasPermissions {
			p = org.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionsWith) > 0 {
		with := make([]predicate.Permission, 0, len(i.HasPermissionsWith))
		for _, w := range i.HasPermissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, org.HasPermissionsWith(with...))
	}
	if i.HasPolicies != nil {
		p := org.HasPolicies()
		if !*i.HasPolicies {
			p = org.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPoliciesWith) > 0 {
		with := make([]predicate.OrgPolicy, 0, len(i.HasPoliciesWith))
		for _, w := range i.HasPoliciesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPoliciesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, org.HasPoliciesWith(with...))
	}
	if i.HasApps != nil {
		p := org.HasApps()
		if !*i.HasApps {
			p = org.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAppsWith) > 0 {
		with := make([]predicate.App, 0, len(i.HasAppsWith))
		for _, w := range i.HasAppsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAppsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, org.HasAppsWith(with...))
	}
	if i.HasOrgUser != nil {
		p := org.HasOrgUser()
		if !*i.HasOrgUser {
			p = org.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrgUserWith) > 0 {
		with := make([]predicate.OrgUser, 0, len(i.HasOrgUserWith))
		for _, w := range i.HasOrgUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrgUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, org.HasOrgUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrgWhereInput
	case 1:
		return predicates[0], nil
	default:
		return org.And(predicates...), nil
	}
}

// OrgPolicyWhereInput represents a where input for filtering OrgPolicy queries.
type OrgPolicyWhereInput struct {
	Predicates []predicate.OrgPolicy  `json:"-"`
	Not        *OrgPolicyWhereInput   `json:"not,omitempty"`
	Or         []*OrgPolicyWhereInput `json:"or,omitempty"`
	And        []*OrgPolicyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "org_id" field predicates.
	OrgID      *int  `json:"orgID,omitempty"`
	OrgIDNEQ   *int  `json:"orgIDNEQ,omitempty"`
	OrgIDIn    []int `json:"orgIDIn,omitempty"`
	OrgIDNotIn []int `json:"orgIDNotIn,omitempty"`

	// "app_policy_id" field predicates.
	AppPolicyID       *int  `json:"appPolicyID,omitempty"`
	AppPolicyIDNEQ    *int  `json:"appPolicyIDNEQ,omitempty"`
	AppPolicyIDIn     []int `json:"appPolicyIDIn,omitempty"`
	AppPolicyIDNotIn  []int `json:"appPolicyIDNotIn,omitempty"`
	AppPolicyIDGT     *int  `json:"appPolicyIDGT,omitempty"`
	AppPolicyIDGTE    *int  `json:"appPolicyIDGTE,omitempty"`
	AppPolicyIDLT     *int  `json:"appPolicyIDLT,omitempty"`
	AppPolicyIDLTE    *int  `json:"appPolicyIDLTE,omitempty"`
	AppPolicyIDIsNil  bool  `json:"appPolicyIDIsNil,omitempty"`
	AppPolicyIDNotNil bool  `json:"appPolicyIDNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "comments" field predicates.
	Comments             *string  `json:"comments,omitempty"`
	CommentsNEQ          *string  `json:"commentsNEQ,omitempty"`
	CommentsIn           []string `json:"commentsIn,omitempty"`
	CommentsNotIn        []string `json:"commentsNotIn,omitempty"`
	CommentsGT           *string  `json:"commentsGT,omitempty"`
	CommentsGTE          *string  `json:"commentsGTE,omitempty"`
	CommentsLT           *string  `json:"commentsLT,omitempty"`
	CommentsLTE          *string  `json:"commentsLTE,omitempty"`
	CommentsContains     *string  `json:"commentsContains,omitempty"`
	CommentsHasPrefix    *string  `json:"commentsHasPrefix,omitempty"`
	CommentsHasSuffix    *string  `json:"commentsHasSuffix,omitempty"`
	CommentsEqualFold    *string  `json:"commentsEqualFold,omitempty"`
	CommentsContainsFold *string  `json:"commentsContainsFold,omitempty"`

	// "org" edge predicates.
	HasOrg     *bool            `json:"hasOrg,omitempty"`
	HasOrgWith []*OrgWhereInput `json:"hasOrgWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrgPolicyWhereInput) AddPredicates(predicates ...predicate.OrgPolicy) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrgPolicyWhereInput filter on the OrgPolicyQuery builder.
func (i *OrgPolicyWhereInput) Filter(q *OrgPolicyQuery) (*OrgPolicyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrgPolicyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrgPolicyWhereInput is returned in case the OrgPolicyWhereInput is empty.
var ErrEmptyOrgPolicyWhereInput = errors.New("ent: empty predicate OrgPolicyWhereInput")

// P returns a predicate for filtering orgpolicies.
// An error is returned if the input is empty or invalid.
func (i *OrgPolicyWhereInput) P() (predicate.OrgPolicy, error) {
	var predicates []predicate.OrgPolicy
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orgpolicy.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgPolicy, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orgpolicy.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgPolicy, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orgpolicy.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orgpolicy.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orgpolicy.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orgpolicy.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orgpolicy.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orgpolicy.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orgpolicy.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orgpolicy.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orgpolicy.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, orgpolicy.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, orgpolicy.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, orgpolicy.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, orgpolicy.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, orgpolicy.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, orgpolicy.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, orgpolicy.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, orgpolicy.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, orgpolicy.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, orgpolicy.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, orgpolicy.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, orgpolicy.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, orgpolicy.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, orgpolicy.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, orgpolicy.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, orgpolicy.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, orgpolicy.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, orgpolicy.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, orgpolicy.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, orgpolicy.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, orgpolicy.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, orgpolicy.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, orgpolicy.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, orgpolicy.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, orgpolicy.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, orgpolicy.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, orgpolicy.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, orgpolicy.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, orgpolicy.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, orgpolicy.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, orgpolicy.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, orgpolicy.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, orgpolicy.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, orgpolicy.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, orgpolicy.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, orgpolicy.UpdatedAtNotNil())
	}
	if i.OrgID != nil {
		predicates = append(predicates, orgpolicy.OrgIDEQ(*i.OrgID))
	}
	if i.OrgIDNEQ != nil {
		predicates = append(predicates, orgpolicy.OrgIDNEQ(*i.OrgIDNEQ))
	}
	if len(i.OrgIDIn) > 0 {
		predicates = append(predicates, orgpolicy.OrgIDIn(i.OrgIDIn...))
	}
	if len(i.OrgIDNotIn) > 0 {
		predicates = append(predicates, orgpolicy.OrgIDNotIn(i.OrgIDNotIn...))
	}
	if i.AppPolicyID != nil {
		predicates = append(predicates, orgpolicy.AppPolicyIDEQ(*i.AppPolicyID))
	}
	if i.AppPolicyIDNEQ != nil {
		predicates = append(predicates, orgpolicy.AppPolicyIDNEQ(*i.AppPolicyIDNEQ))
	}
	if len(i.AppPolicyIDIn) > 0 {
		predicates = append(predicates, orgpolicy.AppPolicyIDIn(i.AppPolicyIDIn...))
	}
	if len(i.AppPolicyIDNotIn) > 0 {
		predicates = append(predicates, orgpolicy.AppPolicyIDNotIn(i.AppPolicyIDNotIn...))
	}
	if i.AppPolicyIDGT != nil {
		predicates = append(predicates, orgpolicy.AppPolicyIDGT(*i.AppPolicyIDGT))
	}
	if i.AppPolicyIDGTE != nil {
		predicates = append(predicates, orgpolicy.AppPolicyIDGTE(*i.AppPolicyIDGTE))
	}
	if i.AppPolicyIDLT != nil {
		predicates = append(predicates, orgpolicy.AppPolicyIDLT(*i.AppPolicyIDLT))
	}
	if i.AppPolicyIDLTE != nil {
		predicates = append(predicates, orgpolicy.AppPolicyIDLTE(*i.AppPolicyIDLTE))
	}
	if i.AppPolicyIDIsNil {
		predicates = append(predicates, orgpolicy.AppPolicyIDIsNil())
	}
	if i.AppPolicyIDNotNil {
		predicates = append(predicates, orgpolicy.AppPolicyIDNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, orgpolicy.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, orgpolicy.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, orgpolicy.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, orgpolicy.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, orgpolicy.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, orgpolicy.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, orgpolicy.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, orgpolicy.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, orgpolicy.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, orgpolicy.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, orgpolicy.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, orgpolicy.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, orgpolicy.NameContainsFold(*i.NameContainsFold))
	}
	if i.Comments != nil {
		predicates = append(predicates, orgpolicy.CommentsEQ(*i.Comments))
	}
	if i.CommentsNEQ != nil {
		predicates = append(predicates, orgpolicy.CommentsNEQ(*i.CommentsNEQ))
	}
	if len(i.CommentsIn) > 0 {
		predicates = append(predicates, orgpolicy.CommentsIn(i.CommentsIn...))
	}
	if len(i.CommentsNotIn) > 0 {
		predicates = append(predicates, orgpolicy.CommentsNotIn(i.CommentsNotIn...))
	}
	if i.CommentsGT != nil {
		predicates = append(predicates, orgpolicy.CommentsGT(*i.CommentsGT))
	}
	if i.CommentsGTE != nil {
		predicates = append(predicates, orgpolicy.CommentsGTE(*i.CommentsGTE))
	}
	if i.CommentsLT != nil {
		predicates = append(predicates, orgpolicy.CommentsLT(*i.CommentsLT))
	}
	if i.CommentsLTE != nil {
		predicates = append(predicates, orgpolicy.CommentsLTE(*i.CommentsLTE))
	}
	if i.CommentsContains != nil {
		predicates = append(predicates, orgpolicy.CommentsContains(*i.CommentsContains))
	}
	if i.CommentsHasPrefix != nil {
		predicates = append(predicates, orgpolicy.CommentsHasPrefix(*i.CommentsHasPrefix))
	}
	if i.CommentsHasSuffix != nil {
		predicates = append(predicates, orgpolicy.CommentsHasSuffix(*i.CommentsHasSuffix))
	}
	if i.CommentsEqualFold != nil {
		predicates = append(predicates, orgpolicy.CommentsEqualFold(*i.CommentsEqualFold))
	}
	if i.CommentsContainsFold != nil {
		predicates = append(predicates, orgpolicy.CommentsContainsFold(*i.CommentsContainsFold))
	}

	if i.HasOrg != nil {
		p := orgpolicy.HasOrg()
		if !*i.HasOrg {
			p = orgpolicy.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrgWith) > 0 {
		with := make([]predicate.Org, 0, len(i.HasOrgWith))
		for _, w := range i.HasOrgWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrgWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orgpolicy.HasOrgWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrgPolicyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orgpolicy.And(predicates...), nil
	}
}

// OrgRoleWhereInput represents a where input for filtering OrgRole queries.
type OrgRoleWhereInput struct {
	Predicates []predicate.OrgRole  `json:"-"`
	Not        *OrgRoleWhereInput   `json:"not,omitempty"`
	Or         []*OrgRoleWhereInput `json:"or,omitempty"`
	And        []*OrgRoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "org_id" field predicates.
	OrgID      *int  `json:"orgID,omitempty"`
	OrgIDNEQ   *int  `json:"orgIDNEQ,omitempty"`
	OrgIDIn    []int `json:"orgIDIn,omitempty"`
	OrgIDNotIn []int `json:"orgIDNotIn,omitempty"`

	// "kind" field predicates.
	Kind      *orgrole.Kind  `json:"kind,omitempty"`
	KindNEQ   *orgrole.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []orgrole.Kind `json:"kindIn,omitempty"`
	KindNotIn []orgrole.Kind `json:"kindNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrgRoleWhereInput) AddPredicates(predicates ...predicate.OrgRole) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrgRoleWhereInput filter on the OrgRoleQuery builder.
func (i *OrgRoleWhereInput) Filter(q *OrgRoleQuery) (*OrgRoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrgRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrgRoleWhereInput is returned in case the OrgRoleWhereInput is empty.
var ErrEmptyOrgRoleWhereInput = errors.New("ent: empty predicate OrgRoleWhereInput")

// P returns a predicate for filtering orgroles.
// An error is returned if the input is empty or invalid.
func (i *OrgRoleWhereInput) P() (predicate.OrgRole, error) {
	var predicates []predicate.OrgRole
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orgrole.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgRole, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orgrole.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgRole, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orgrole.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orgrole.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orgrole.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orgrole.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orgrole.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orgrole.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orgrole.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orgrole.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orgrole.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, orgrole.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, orgrole.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, orgrole.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, orgrole.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, orgrole.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, orgrole.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, orgrole.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, orgrole.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, orgrole.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, orgrole.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, orgrole.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, orgrole.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, orgrole.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, orgrole.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, orgrole.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, orgrole.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, orgrole.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, orgrole.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, orgrole.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, orgrole.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, orgrole.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, orgrole.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, orgrole.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, orgrole.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, orgrole.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, orgrole.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, orgrole.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, orgrole.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, orgrole.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, orgrole.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, orgrole.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, orgrole.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, orgrole.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, orgrole.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, orgrole.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, orgrole.UpdatedAtNotNil())
	}
	if i.OrgID != nil {
		predicates = append(predicates, orgrole.OrgIDEQ(*i.OrgID))
	}
	if i.OrgIDNEQ != nil {
		predicates = append(predicates, orgrole.OrgIDNEQ(*i.OrgIDNEQ))
	}
	if len(i.OrgIDIn) > 0 {
		predicates = append(predicates, orgrole.OrgIDIn(i.OrgIDIn...))
	}
	if len(i.OrgIDNotIn) > 0 {
		predicates = append(predicates, orgrole.OrgIDNotIn(i.OrgIDNotIn...))
	}
	if i.Kind != nil {
		predicates = append(predicates, orgrole.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, orgrole.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, orgrole.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, orgrole.KindNotIn(i.KindNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, orgrole.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, orgrole.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, orgrole.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, orgrole.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, orgrole.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, orgrole.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, orgrole.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, orgrole.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, orgrole.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, orgrole.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, orgrole.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, orgrole.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, orgrole.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrgRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orgrole.And(predicates...), nil
	}
}

// OrgUserWhereInput represents a where input for filtering OrgUser queries.
type OrgUserWhereInput struct {
	Predicates []predicate.OrgUser  `json:"-"`
	Not        *OrgUserWhereInput   `json:"not,omitempty"`
	Or         []*OrgUserWhereInput `json:"or,omitempty"`
	And        []*OrgUserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "org_id" field predicates.
	OrgID      *int  `json:"orgID,omitempty"`
	OrgIDNEQ   *int  `json:"orgIDNEQ,omitempty"`
	OrgIDIn    []int `json:"orgIDIn,omitempty"`
	OrgIDNotIn []int `json:"orgIDNotIn,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrgUserWhereInput) AddPredicates(predicates ...predicate.OrgUser) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrgUserWhereInput filter on the OrgUserQuery builder.
func (i *OrgUserWhereInput) Filter(q *OrgUserQuery) (*OrgUserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrgUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrgUserWhereInput is returned in case the OrgUserWhereInput is empty.
var ErrEmptyOrgUserWhereInput = errors.New("ent: empty predicate OrgUserWhereInput")

// P returns a predicate for filtering orgusers.
// An error is returned if the input is empty or invalid.
func (i *OrgUserWhereInput) P() (predicate.OrgUser, error) {
	var predicates []predicate.OrgUser
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orguser.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgUser, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orguser.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgUser, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orguser.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orguser.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orguser.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orguser.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orguser.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orguser.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orguser.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orguser.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orguser.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, orguser.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, orguser.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, orguser.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, orguser.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, orguser.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, orguser.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, orguser.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, orguser.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, orguser.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, orguser.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, orguser.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, orguser.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, orguser.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, orguser.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, orguser.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, orguser.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, orguser.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, orguser.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, orguser.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, orguser.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, orguser.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, orguser.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, orguser.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, orguser.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, orguser.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, orguser.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, orguser.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, orguser.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, orguser.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, orguser.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, orguser.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, orguser.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, orguser.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, orguser.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, orguser.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, orguser.UpdatedAtNotNil())
	}
	if i.OrgID != nil {
		predicates = append(predicates, orguser.OrgIDEQ(*i.OrgID))
	}
	if i.OrgIDNEQ != nil {
		predicates = append(predicates, orguser.OrgIDNEQ(*i.OrgIDNEQ))
	}
	if len(i.OrgIDIn) > 0 {
		predicates = append(predicates, orguser.OrgIDIn(i.OrgIDIn...))
	}
	if len(i.OrgIDNotIn) > 0 {
		predicates = append(predicates, orguser.OrgIDNotIn(i.OrgIDNotIn...))
	}
	if i.UserID != nil {
		predicates = append(predicates, orguser.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, orguser.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, orguser.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, orguser.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, orguser.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, orguser.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, orguser.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, orguser.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, orguser.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, orguser.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, orguser.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, orguser.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, orguser.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, orguser.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, orguser.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, orguser.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, orguser.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrgUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orguser.And(predicates...), nil
	}
}

// PermissionWhereInput represents a where input for filtering Permission queries.
type PermissionWhereInput struct {
	Predicates []predicate.Permission  `json:"-"`
	Not        *PermissionWhereInput   `json:"not,omitempty"`
	Or         []*PermissionWhereInput `json:"or,omitempty"`
	And        []*PermissionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "org_id" field predicates.
	OrgID      *int  `json:"orgID,omitempty"`
	OrgIDNEQ   *int  `json:"orgIDNEQ,omitempty"`
	OrgIDIn    []int `json:"orgIDIn,omitempty"`
	OrgIDNotIn []int `json:"orgIDNotIn,omitempty"`

	// "principal_kind" field predicates.
	PrincipalKind      *permission.PrincipalKind  `json:"principalKind,omitempty"`
	PrincipalKindNEQ   *permission.PrincipalKind  `json:"principalKindNEQ,omitempty"`
	PrincipalKindIn    []permission.PrincipalKind `json:"principalKindIn,omitempty"`
	PrincipalKindNotIn []permission.PrincipalKind `json:"principalKindNotIn,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "role_id" field predicates.
	RoleID       *int  `json:"roleID,omitempty"`
	RoleIDNEQ    *int  `json:"roleIDNEQ,omitempty"`
	RoleIDIn     []int `json:"roleIDIn,omitempty"`
	RoleIDNotIn  []int `json:"roleIDNotIn,omitempty"`
	RoleIDGT     *int  `json:"roleIDGT,omitempty"`
	RoleIDGTE    *int  `json:"roleIDGTE,omitempty"`
	RoleIDLT     *int  `json:"roleIDLT,omitempty"`
	RoleIDLTE    *int  `json:"roleIDLTE,omitempty"`
	RoleIDIsNil  bool  `json:"roleIDIsNil,omitempty"`
	RoleIDNotNil bool  `json:"roleIDNotNil,omitempty"`

	// "org_policy_id" field predicates.
	OrgPolicyID      *int  `json:"orgPolicyID,omitempty"`
	OrgPolicyIDNEQ   *int  `json:"orgPolicyIDNEQ,omitempty"`
	OrgPolicyIDIn    []int `json:"orgPolicyIDIn,omitempty"`
	OrgPolicyIDNotIn []int `json:"orgPolicyIDNotIn,omitempty"`
	OrgPolicyIDGT    *int  `json:"orgPolicyIDGT,omitempty"`
	OrgPolicyIDGTE   *int  `json:"orgPolicyIDGTE,omitempty"`
	OrgPolicyIDLT    *int  `json:"orgPolicyIDLT,omitempty"`
	OrgPolicyIDLTE   *int  `json:"orgPolicyIDLTE,omitempty"`

	// "start_at" field predicates.
	StartAt       *time.Time  `json:"startAt,omitempty"`
	StartAtNEQ    *time.Time  `json:"startAtNEQ,omitempty"`
	StartAtIn     []time.Time `json:"startAtIn,omitempty"`
	StartAtNotIn  []time.Time `json:"startAtNotIn,omitempty"`
	StartAtGT     *time.Time  `json:"startAtGT,omitempty"`
	StartAtGTE    *time.Time  `json:"startAtGTE,omitempty"`
	StartAtLT     *time.Time  `json:"startAtLT,omitempty"`
	StartAtLTE    *time.Time  `json:"startAtLTE,omitempty"`
	StartAtIsNil  bool        `json:"startAtIsNil,omitempty"`
	StartAtNotNil bool        `json:"startAtNotNil,omitempty"`

	// "end_at" field predicates.
	EndAt       *time.Time  `json:"endAt,omitempty"`
	EndAtNEQ    *time.Time  `json:"endAtNEQ,omitempty"`
	EndAtIn     []time.Time `json:"endAtIn,omitempty"`
	EndAtNotIn  []time.Time `json:"endAtNotIn,omitempty"`
	EndAtGT     *time.Time  `json:"endAtGT,omitempty"`
	EndAtGTE    *time.Time  `json:"endAtGTE,omitempty"`
	EndAtLT     *time.Time  `json:"endAtLT,omitempty"`
	EndAtLTE    *time.Time  `json:"endAtLTE,omitempty"`
	EndAtIsNil  bool        `json:"endAtIsNil,omitempty"`
	EndAtNotNil bool        `json:"endAtNotNil,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "org" edge predicates.
	HasOrg     *bool            `json:"hasOrg,omitempty"`
	HasOrgWith []*OrgWhereInput `json:"hasOrgWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PermissionWhereInput) AddPredicates(predicates ...predicate.Permission) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PermissionWhereInput filter on the PermissionQuery builder.
func (i *PermissionWhereInput) Filter(q *PermissionQuery) (*PermissionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPermissionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPermissionWhereInput is returned in case the PermissionWhereInput is empty.
var ErrEmptyPermissionWhereInput = errors.New("ent: empty predicate PermissionWhereInput")

// P returns a predicate for filtering permissions.
// An error is returned if the input is empty or invalid.
func (i *PermissionWhereInput) P() (predicate.Permission, error) {
	var predicates []predicate.Permission
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, permission.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Permission, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, permission.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Permission, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, permission.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, permission.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, permission.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, permission.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, permission.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, permission.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, permission.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, permission.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, permission.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, permission.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, permission.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, permission.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, permission.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, permission.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, permission.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, permission.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, permission.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, permission.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, permission.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, permission.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, permission.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, permission.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, permission.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, permission.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, permission.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, permission.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, permission.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, permission.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, permission.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, permission.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, permission.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, permission.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, permission.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, permission.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, permission.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, permission.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, permission.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, permission.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, permission.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, permission.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, permission.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, permission.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, permission.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, permission.UpdatedAtNotNil())
	}
	if i.OrgID != nil {
		predicates = append(predicates, permission.OrgIDEQ(*i.OrgID))
	}
	if i.OrgIDNEQ != nil {
		predicates = append(predicates, permission.OrgIDNEQ(*i.OrgIDNEQ))
	}
	if len(i.OrgIDIn) > 0 {
		predicates = append(predicates, permission.OrgIDIn(i.OrgIDIn...))
	}
	if len(i.OrgIDNotIn) > 0 {
		predicates = append(predicates, permission.OrgIDNotIn(i.OrgIDNotIn...))
	}
	if i.PrincipalKind != nil {
		predicates = append(predicates, permission.PrincipalKindEQ(*i.PrincipalKind))
	}
	if i.PrincipalKindNEQ != nil {
		predicates = append(predicates, permission.PrincipalKindNEQ(*i.PrincipalKindNEQ))
	}
	if len(i.PrincipalKindIn) > 0 {
		predicates = append(predicates, permission.PrincipalKindIn(i.PrincipalKindIn...))
	}
	if len(i.PrincipalKindNotIn) > 0 {
		predicates = append(predicates, permission.PrincipalKindNotIn(i.PrincipalKindNotIn...))
	}
	if i.UserID != nil {
		predicates = append(predicates, permission.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, permission.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, permission.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, permission.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, permission.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, permission.UserIDNotNil())
	}
	if i.RoleID != nil {
		predicates = append(predicates, permission.RoleIDEQ(*i.RoleID))
	}
	if i.RoleIDNEQ != nil {
		predicates = append(predicates, permission.RoleIDNEQ(*i.RoleIDNEQ))
	}
	if len(i.RoleIDIn) > 0 {
		predicates = append(predicates, permission.RoleIDIn(i.RoleIDIn...))
	}
	if len(i.RoleIDNotIn) > 0 {
		predicates = append(predicates, permission.RoleIDNotIn(i.RoleIDNotIn...))
	}
	if i.RoleIDGT != nil {
		predicates = append(predicates, permission.RoleIDGT(*i.RoleIDGT))
	}
	if i.RoleIDGTE != nil {
		predicates = append(predicates, permission.RoleIDGTE(*i.RoleIDGTE))
	}
	if i.RoleIDLT != nil {
		predicates = append(predicates, permission.RoleIDLT(*i.RoleIDLT))
	}
	if i.RoleIDLTE != nil {
		predicates = append(predicates, permission.RoleIDLTE(*i.RoleIDLTE))
	}
	if i.RoleIDIsNil {
		predicates = append(predicates, permission.RoleIDIsNil())
	}
	if i.RoleIDNotNil {
		predicates = append(predicates, permission.RoleIDNotNil())
	}
	if i.OrgPolicyID != nil {
		predicates = append(predicates, permission.OrgPolicyIDEQ(*i.OrgPolicyID))
	}
	if i.OrgPolicyIDNEQ != nil {
		predicates = append(predicates, permission.OrgPolicyIDNEQ(*i.OrgPolicyIDNEQ))
	}
	if len(i.OrgPolicyIDIn) > 0 {
		predicates = append(predicates, permission.OrgPolicyIDIn(i.OrgPolicyIDIn...))
	}
	if len(i.OrgPolicyIDNotIn) > 0 {
		predicates = append(predicates, permission.OrgPolicyIDNotIn(i.OrgPolicyIDNotIn...))
	}
	if i.OrgPolicyIDGT != nil {
		predicates = append(predicates, permission.OrgPolicyIDGT(*i.OrgPolicyIDGT))
	}
	if i.OrgPolicyIDGTE != nil {
		predicates = append(predicates, permission.OrgPolicyIDGTE(*i.OrgPolicyIDGTE))
	}
	if i.OrgPolicyIDLT != nil {
		predicates = append(predicates, permission.OrgPolicyIDLT(*i.OrgPolicyIDLT))
	}
	if i.OrgPolicyIDLTE != nil {
		predicates = append(predicates, permission.OrgPolicyIDLTE(*i.OrgPolicyIDLTE))
	}
	if i.StartAt != nil {
		predicates = append(predicates, permission.StartAtEQ(*i.StartAt))
	}
	if i.StartAtNEQ != nil {
		predicates = append(predicates, permission.StartAtNEQ(*i.StartAtNEQ))
	}
	if len(i.StartAtIn) > 0 {
		predicates = append(predicates, permission.StartAtIn(i.StartAtIn...))
	}
	if len(i.StartAtNotIn) > 0 {
		predicates = append(predicates, permission.StartAtNotIn(i.StartAtNotIn...))
	}
	if i.StartAtGT != nil {
		predicates = append(predicates, permission.StartAtGT(*i.StartAtGT))
	}
	if i.StartAtGTE != nil {
		predicates = append(predicates, permission.StartAtGTE(*i.StartAtGTE))
	}
	if i.StartAtLT != nil {
		predicates = append(predicates, permission.StartAtLT(*i.StartAtLT))
	}
	if i.StartAtLTE != nil {
		predicates = append(predicates, permission.StartAtLTE(*i.StartAtLTE))
	}
	if i.StartAtIsNil {
		predicates = append(predicates, permission.StartAtIsNil())
	}
	if i.StartAtNotNil {
		predicates = append(predicates, permission.StartAtNotNil())
	}
	if i.EndAt != nil {
		predicates = append(predicates, permission.EndAtEQ(*i.EndAt))
	}
	if i.EndAtNEQ != nil {
		predicates = append(predicates, permission.EndAtNEQ(*i.EndAtNEQ))
	}
	if len(i.EndAtIn) > 0 {
		predicates = append(predicates, permission.EndAtIn(i.EndAtIn...))
	}
	if len(i.EndAtNotIn) > 0 {
		predicates = append(predicates, permission.EndAtNotIn(i.EndAtNotIn...))
	}
	if i.EndAtGT != nil {
		predicates = append(predicates, permission.EndAtGT(*i.EndAtGT))
	}
	if i.EndAtGTE != nil {
		predicates = append(predicates, permission.EndAtGTE(*i.EndAtGTE))
	}
	if i.EndAtLT != nil {
		predicates = append(predicates, permission.EndAtLT(*i.EndAtLT))
	}
	if i.EndAtLTE != nil {
		predicates = append(predicates, permission.EndAtLTE(*i.EndAtLTE))
	}
	if i.EndAtIsNil {
		predicates = append(predicates, permission.EndAtIsNil())
	}
	if i.EndAtNotNil {
		predicates = append(predicates, permission.EndAtNotNil())
	}
	if i.Status != nil {
		predicates = append(predicates, permission.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, permission.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, permission.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, permission.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, permission.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, permission.StatusNotNil())
	}

	if i.HasOrg != nil {
		p := permission.HasOrg()
		if !*i.HasOrg {
			p = permission.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrgWith) > 0 {
		with := make([]predicate.Org, 0, len(i.HasOrgWith))
		for _, w := range i.HasOrgWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrgWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, permission.HasOrgWith(with...))
	}
	if i.HasUser != nil {
		p := permission.HasUser()
		if !*i.HasUser {
			p = permission.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, permission.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPermissionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return permission.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "principal_name" field predicates.
	PrincipalName             *string  `json:"principalName,omitempty"`
	PrincipalNameNEQ          *string  `json:"principalNameNEQ,omitempty"`
	PrincipalNameIn           []string `json:"principalNameIn,omitempty"`
	PrincipalNameNotIn        []string `json:"principalNameNotIn,omitempty"`
	PrincipalNameGT           *string  `json:"principalNameGT,omitempty"`
	PrincipalNameGTE          *string  `json:"principalNameGTE,omitempty"`
	PrincipalNameLT           *string  `json:"principalNameLT,omitempty"`
	PrincipalNameLTE          *string  `json:"principalNameLTE,omitempty"`
	PrincipalNameContains     *string  `json:"principalNameContains,omitempty"`
	PrincipalNameHasPrefix    *string  `json:"principalNameHasPrefix,omitempty"`
	PrincipalNameHasSuffix    *string  `json:"principalNameHasSuffix,omitempty"`
	PrincipalNameEqualFold    *string  `json:"principalNameEqualFold,omitempty"`
	PrincipalNameContainsFold *string  `json:"principalNameContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "mobile" field predicates.
	Mobile             *string  `json:"mobile,omitempty"`
	MobileNEQ          *string  `json:"mobileNEQ,omitempty"`
	MobileIn           []string `json:"mobileIn,omitempty"`
	MobileNotIn        []string `json:"mobileNotIn,omitempty"`
	MobileGT           *string  `json:"mobileGT,omitempty"`
	MobileGTE          *string  `json:"mobileGTE,omitempty"`
	MobileLT           *string  `json:"mobileLT,omitempty"`
	MobileLTE          *string  `json:"mobileLTE,omitempty"`
	MobileContains     *string  `json:"mobileContains,omitempty"`
	MobileHasPrefix    *string  `json:"mobileHasPrefix,omitempty"`
	MobileHasSuffix    *string  `json:"mobileHasSuffix,omitempty"`
	MobileIsNil        bool     `json:"mobileIsNil,omitempty"`
	MobileNotNil       bool     `json:"mobileNotNil,omitempty"`
	MobileEqualFold    *string  `json:"mobileEqualFold,omitempty"`
	MobileContainsFold *string  `json:"mobileContainsFold,omitempty"`

	// "creation_type" field predicates.
	CreationType      *user.CreationType  `json:"creationType,omitempty"`
	CreationTypeNEQ   *user.CreationType  `json:"creationTypeNEQ,omitempty"`
	CreationTypeIn    []user.CreationType `json:"creationTypeIn,omitempty"`
	CreationTypeNotIn []user.CreationType `json:"creationTypeNotIn,omitempty"`

	// "register_ip" field predicates.
	RegisterIP             *string  `json:"registerIP,omitempty"`
	RegisterIPNEQ          *string  `json:"registerIPNEQ,omitempty"`
	RegisterIPIn           []string `json:"registerIPIn,omitempty"`
	RegisterIPNotIn        []string `json:"registerIPNotIn,omitempty"`
	RegisterIPGT           *string  `json:"registerIPGT,omitempty"`
	RegisterIPGTE          *string  `json:"registerIPGTE,omitempty"`
	RegisterIPLT           *string  `json:"registerIPLT,omitempty"`
	RegisterIPLTE          *string  `json:"registerIPLTE,omitempty"`
	RegisterIPContains     *string  `json:"registerIPContains,omitempty"`
	RegisterIPHasPrefix    *string  `json:"registerIPHasPrefix,omitempty"`
	RegisterIPHasSuffix    *string  `json:"registerIPHasSuffix,omitempty"`
	RegisterIPEqualFold    *string  `json:"registerIPEqualFold,omitempty"`
	RegisterIPContainsFold *string  `json:"registerIPContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "identities" edge predicates.
	HasIdentities     *bool                     `json:"hasIdentities,omitempty"`
	HasIdentitiesWith []*UserIdentityWhereInput `json:"hasIdentitiesWith,omitempty"`

	// "login_profile" edge predicates.
	HasLoginProfile     *bool                         `json:"hasLoginProfile,omitempty"`
	HasLoginProfileWith []*UserLoginProfileWhereInput `json:"hasLoginProfileWith,omitempty"`

	// "passwords" edge predicates.
	HasPasswords     *bool                     `json:"hasPasswords,omitempty"`
	HasPasswordsWith []*UserPasswordWhereInput `json:"hasPasswordsWith,omitempty"`

	// "devices" edge predicates.
	HasDevices     *bool                   `json:"hasDevices,omitempty"`
	HasDevicesWith []*UserDeviceWhereInput `json:"hasDevicesWith,omitempty"`

	// "permissions" edge predicates.
	HasPermissions     *bool                   `json:"hasPermissions,omitempty"`
	HasPermissionsWith []*PermissionWhereInput `json:"hasPermissionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, user.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, user.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, user.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, user.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, user.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, user.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, user.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, user.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, user.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, user.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, user.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, user.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, user.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, user.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, user.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, user.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, user.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, user.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, user.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, user.UpdatedAtNotNil())
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, user.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, user.DeletedAtNotNil())
	}
	if i.PrincipalName != nil {
		predicates = append(predicates, user.PrincipalNameEQ(*i.PrincipalName))
	}
	if i.PrincipalNameNEQ != nil {
		predicates = append(predicates, user.PrincipalNameNEQ(*i.PrincipalNameNEQ))
	}
	if len(i.PrincipalNameIn) > 0 {
		predicates = append(predicates, user.PrincipalNameIn(i.PrincipalNameIn...))
	}
	if len(i.PrincipalNameNotIn) > 0 {
		predicates = append(predicates, user.PrincipalNameNotIn(i.PrincipalNameNotIn...))
	}
	if i.PrincipalNameGT != nil {
		predicates = append(predicates, user.PrincipalNameGT(*i.PrincipalNameGT))
	}
	if i.PrincipalNameGTE != nil {
		predicates = append(predicates, user.PrincipalNameGTE(*i.PrincipalNameGTE))
	}
	if i.PrincipalNameLT != nil {
		predicates = append(predicates, user.PrincipalNameLT(*i.PrincipalNameLT))
	}
	if i.PrincipalNameLTE != nil {
		predicates = append(predicates, user.PrincipalNameLTE(*i.PrincipalNameLTE))
	}
	if i.PrincipalNameContains != nil {
		predicates = append(predicates, user.PrincipalNameContains(*i.PrincipalNameContains))
	}
	if i.PrincipalNameHasPrefix != nil {
		predicates = append(predicates, user.PrincipalNameHasPrefix(*i.PrincipalNameHasPrefix))
	}
	if i.PrincipalNameHasSuffix != nil {
		predicates = append(predicates, user.PrincipalNameHasSuffix(*i.PrincipalNameHasSuffix))
	}
	if i.PrincipalNameEqualFold != nil {
		predicates = append(predicates, user.PrincipalNameEqualFold(*i.PrincipalNameEqualFold))
	}
	if i.PrincipalNameContainsFold != nil {
		predicates = append(predicates, user.PrincipalNameContainsFold(*i.PrincipalNameContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, user.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, user.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, user.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, user.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, user.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, user.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, user.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, user.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, user.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, user.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, user.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, user.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, user.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, user.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, user.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Mobile != nil {
		predicates = append(predicates, user.MobileEQ(*i.Mobile))
	}
	if i.MobileNEQ != nil {
		predicates = append(predicates, user.MobileNEQ(*i.MobileNEQ))
	}
	if len(i.MobileIn) > 0 {
		predicates = append(predicates, user.MobileIn(i.MobileIn...))
	}
	if len(i.MobileNotIn) > 0 {
		predicates = append(predicates, user.MobileNotIn(i.MobileNotIn...))
	}
	if i.MobileGT != nil {
		predicates = append(predicates, user.MobileGT(*i.MobileGT))
	}
	if i.MobileGTE != nil {
		predicates = append(predicates, user.MobileGTE(*i.MobileGTE))
	}
	if i.MobileLT != nil {
		predicates = append(predicates, user.MobileLT(*i.MobileLT))
	}
	if i.MobileLTE != nil {
		predicates = append(predicates, user.MobileLTE(*i.MobileLTE))
	}
	if i.MobileContains != nil {
		predicates = append(predicates, user.MobileContains(*i.MobileContains))
	}
	if i.MobileHasPrefix != nil {
		predicates = append(predicates, user.MobileHasPrefix(*i.MobileHasPrefix))
	}
	if i.MobileHasSuffix != nil {
		predicates = append(predicates, user.MobileHasSuffix(*i.MobileHasSuffix))
	}
	if i.MobileIsNil {
		predicates = append(predicates, user.MobileIsNil())
	}
	if i.MobileNotNil {
		predicates = append(predicates, user.MobileNotNil())
	}
	if i.MobileEqualFold != nil {
		predicates = append(predicates, user.MobileEqualFold(*i.MobileEqualFold))
	}
	if i.MobileContainsFold != nil {
		predicates = append(predicates, user.MobileContainsFold(*i.MobileContainsFold))
	}
	if i.CreationType != nil {
		predicates = append(predicates, user.CreationTypeEQ(*i.CreationType))
	}
	if i.CreationTypeNEQ != nil {
		predicates = append(predicates, user.CreationTypeNEQ(*i.CreationTypeNEQ))
	}
	if len(i.CreationTypeIn) > 0 {
		predicates = append(predicates, user.CreationTypeIn(i.CreationTypeIn...))
	}
	if len(i.CreationTypeNotIn) > 0 {
		predicates = append(predicates, user.CreationTypeNotIn(i.CreationTypeNotIn...))
	}
	if i.RegisterIP != nil {
		predicates = append(predicates, user.RegisterIPEQ(*i.RegisterIP))
	}
	if i.RegisterIPNEQ != nil {
		predicates = append(predicates, user.RegisterIPNEQ(*i.RegisterIPNEQ))
	}
	if len(i.RegisterIPIn) > 0 {
		predicates = append(predicates, user.RegisterIPIn(i.RegisterIPIn...))
	}
	if len(i.RegisterIPNotIn) > 0 {
		predicates = append(predicates, user.RegisterIPNotIn(i.RegisterIPNotIn...))
	}
	if i.RegisterIPGT != nil {
		predicates = append(predicates, user.RegisterIPGT(*i.RegisterIPGT))
	}
	if i.RegisterIPGTE != nil {
		predicates = append(predicates, user.RegisterIPGTE(*i.RegisterIPGTE))
	}
	if i.RegisterIPLT != nil {
		predicates = append(predicates, user.RegisterIPLT(*i.RegisterIPLT))
	}
	if i.RegisterIPLTE != nil {
		predicates = append(predicates, user.RegisterIPLTE(*i.RegisterIPLTE))
	}
	if i.RegisterIPContains != nil {
		predicates = append(predicates, user.RegisterIPContains(*i.RegisterIPContains))
	}
	if i.RegisterIPHasPrefix != nil {
		predicates = append(predicates, user.RegisterIPHasPrefix(*i.RegisterIPHasPrefix))
	}
	if i.RegisterIPHasSuffix != nil {
		predicates = append(predicates, user.RegisterIPHasSuffix(*i.RegisterIPHasSuffix))
	}
	if i.RegisterIPEqualFold != nil {
		predicates = append(predicates, user.RegisterIPEqualFold(*i.RegisterIPEqualFold))
	}
	if i.RegisterIPContainsFold != nil {
		predicates = append(predicates, user.RegisterIPContainsFold(*i.RegisterIPContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, user.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, user.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, user.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, user.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, user.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, user.StatusNotNil())
	}

	if i.HasIdentities != nil {
		p := user.HasIdentities()
		if !*i.HasIdentities {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIdentitiesWith) > 0 {
		with := make([]predicate.UserIdentity, 0, len(i.HasIdentitiesWith))
		for _, w := range i.HasIdentitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIdentitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasIdentitiesWith(with...))
	}
	if i.HasLoginProfile != nil {
		p := user.HasLoginProfile()
		if !*i.HasLoginProfile {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLoginProfileWith) > 0 {
		with := make([]predicate.UserLoginProfile, 0, len(i.HasLoginProfileWith))
		for _, w := range i.HasLoginProfileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLoginProfileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasLoginProfileWith(with...))
	}
	if i.HasPasswords != nil {
		p := user.HasPasswords()
		if !*i.HasPasswords {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPasswordsWith) > 0 {
		with := make([]predicate.UserPassword, 0, len(i.HasPasswordsWith))
		for _, w := range i.HasPasswordsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPasswordsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPasswordsWith(with...))
	}
	if i.HasDevices != nil {
		p := user.HasDevices()
		if !*i.HasDevices {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDevicesWith) > 0 {
		with := make([]predicate.UserDevice, 0, len(i.HasDevicesWith))
		for _, w := range i.HasDevicesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDevicesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasDevicesWith(with...))
	}
	if i.HasPermissions != nil {
		p := user.HasPermissions()
		if !*i.HasPermissions {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPermissionsWith) > 0 {
		with := make([]predicate.Permission, 0, len(i.HasPermissionsWith))
		for _, w := range i.HasPermissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPermissionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPermissionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserDeviceWhereInput represents a where input for filtering UserDevice queries.
type UserDeviceWhereInput struct {
	Predicates []predicate.UserDevice  `json:"-"`
	Not        *UserDeviceWhereInput   `json:"not,omitempty"`
	Or         []*UserDeviceWhereInput `json:"or,omitempty"`
	And        []*UserDeviceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "device_uid" field predicates.
	DeviceUID             *string  `json:"deviceUID,omitempty"`
	DeviceUIDNEQ          *string  `json:"deviceUIDNEQ,omitempty"`
	DeviceUIDIn           []string `json:"deviceUIDIn,omitempty"`
	DeviceUIDNotIn        []string `json:"deviceUIDNotIn,omitempty"`
	DeviceUIDGT           *string  `json:"deviceUIDGT,omitempty"`
	DeviceUIDGTE          *string  `json:"deviceUIDGTE,omitempty"`
	DeviceUIDLT           *string  `json:"deviceUIDLT,omitempty"`
	DeviceUIDLTE          *string  `json:"deviceUIDLTE,omitempty"`
	DeviceUIDContains     *string  `json:"deviceUIDContains,omitempty"`
	DeviceUIDHasPrefix    *string  `json:"deviceUIDHasPrefix,omitempty"`
	DeviceUIDHasSuffix    *string  `json:"deviceUIDHasSuffix,omitempty"`
	DeviceUIDEqualFold    *string  `json:"deviceUIDEqualFold,omitempty"`
	DeviceUIDContainsFold *string  `json:"deviceUIDContainsFold,omitempty"`

	// "device_name" field predicates.
	DeviceName             *string  `json:"deviceName,omitempty"`
	DeviceNameNEQ          *string  `json:"deviceNameNEQ,omitempty"`
	DeviceNameIn           []string `json:"deviceNameIn,omitempty"`
	DeviceNameNotIn        []string `json:"deviceNameNotIn,omitempty"`
	DeviceNameGT           *string  `json:"deviceNameGT,omitempty"`
	DeviceNameGTE          *string  `json:"deviceNameGTE,omitempty"`
	DeviceNameLT           *string  `json:"deviceNameLT,omitempty"`
	DeviceNameLTE          *string  `json:"deviceNameLTE,omitempty"`
	DeviceNameContains     *string  `json:"deviceNameContains,omitempty"`
	DeviceNameHasPrefix    *string  `json:"deviceNameHasPrefix,omitempty"`
	DeviceNameHasSuffix    *string  `json:"deviceNameHasSuffix,omitempty"`
	DeviceNameIsNil        bool     `json:"deviceNameIsNil,omitempty"`
	DeviceNameNotNil       bool     `json:"deviceNameNotNil,omitempty"`
	DeviceNameEqualFold    *string  `json:"deviceNameEqualFold,omitempty"`
	DeviceNameContainsFold *string  `json:"deviceNameContainsFold,omitempty"`

	// "system_name" field predicates.
	SystemName             *string  `json:"systemName,omitempty"`
	SystemNameNEQ          *string  `json:"systemNameNEQ,omitempty"`
	SystemNameIn           []string `json:"systemNameIn,omitempty"`
	SystemNameNotIn        []string `json:"systemNameNotIn,omitempty"`
	SystemNameGT           *string  `json:"systemNameGT,omitempty"`
	SystemNameGTE          *string  `json:"systemNameGTE,omitempty"`
	SystemNameLT           *string  `json:"systemNameLT,omitempty"`
	SystemNameLTE          *string  `json:"systemNameLTE,omitempty"`
	SystemNameContains     *string  `json:"systemNameContains,omitempty"`
	SystemNameHasPrefix    *string  `json:"systemNameHasPrefix,omitempty"`
	SystemNameHasSuffix    *string  `json:"systemNameHasSuffix,omitempty"`
	SystemNameIsNil        bool     `json:"systemNameIsNil,omitempty"`
	SystemNameNotNil       bool     `json:"systemNameNotNil,omitempty"`
	SystemNameEqualFold    *string  `json:"systemNameEqualFold,omitempty"`
	SystemNameContainsFold *string  `json:"systemNameContainsFold,omitempty"`

	// "system_version" field predicates.
	SystemVersion             *string  `json:"systemVersion,omitempty"`
	SystemVersionNEQ          *string  `json:"systemVersionNEQ,omitempty"`
	SystemVersionIn           []string `json:"systemVersionIn,omitempty"`
	SystemVersionNotIn        []string `json:"systemVersionNotIn,omitempty"`
	SystemVersionGT           *string  `json:"systemVersionGT,omitempty"`
	SystemVersionGTE          *string  `json:"systemVersionGTE,omitempty"`
	SystemVersionLT           *string  `json:"systemVersionLT,omitempty"`
	SystemVersionLTE          *string  `json:"systemVersionLTE,omitempty"`
	SystemVersionContains     *string  `json:"systemVersionContains,omitempty"`
	SystemVersionHasPrefix    *string  `json:"systemVersionHasPrefix,omitempty"`
	SystemVersionHasSuffix    *string  `json:"systemVersionHasSuffix,omitempty"`
	SystemVersionIsNil        bool     `json:"systemVersionIsNil,omitempty"`
	SystemVersionNotNil       bool     `json:"systemVersionNotNil,omitempty"`
	SystemVersionEqualFold    *string  `json:"systemVersionEqualFold,omitempty"`
	SystemVersionContainsFold *string  `json:"systemVersionContainsFold,omitempty"`

	// "app_version" field predicates.
	AppVersion             *string  `json:"appVersion,omitempty"`
	AppVersionNEQ          *string  `json:"appVersionNEQ,omitempty"`
	AppVersionIn           []string `json:"appVersionIn,omitempty"`
	AppVersionNotIn        []string `json:"appVersionNotIn,omitempty"`
	AppVersionGT           *string  `json:"appVersionGT,omitempty"`
	AppVersionGTE          *string  `json:"appVersionGTE,omitempty"`
	AppVersionLT           *string  `json:"appVersionLT,omitempty"`
	AppVersionLTE          *string  `json:"appVersionLTE,omitempty"`
	AppVersionContains     *string  `json:"appVersionContains,omitempty"`
	AppVersionHasPrefix    *string  `json:"appVersionHasPrefix,omitempty"`
	AppVersionHasSuffix    *string  `json:"appVersionHasSuffix,omitempty"`
	AppVersionIsNil        bool     `json:"appVersionIsNil,omitempty"`
	AppVersionNotNil       bool     `json:"appVersionNotNil,omitempty"`
	AppVersionEqualFold    *string  `json:"appVersionEqualFold,omitempty"`
	AppVersionContainsFold *string  `json:"appVersionContainsFold,omitempty"`

	// "device_model" field predicates.
	DeviceModel             *string  `json:"deviceModel,omitempty"`
	DeviceModelNEQ          *string  `json:"deviceModelNEQ,omitempty"`
	DeviceModelIn           []string `json:"deviceModelIn,omitempty"`
	DeviceModelNotIn        []string `json:"deviceModelNotIn,omitempty"`
	DeviceModelGT           *string  `json:"deviceModelGT,omitempty"`
	DeviceModelGTE          *string  `json:"deviceModelGTE,omitempty"`
	DeviceModelLT           *string  `json:"deviceModelLT,omitempty"`
	DeviceModelLTE          *string  `json:"deviceModelLTE,omitempty"`
	DeviceModelContains     *string  `json:"deviceModelContains,omitempty"`
	DeviceModelHasPrefix    *string  `json:"deviceModelHasPrefix,omitempty"`
	DeviceModelHasSuffix    *string  `json:"deviceModelHasSuffix,omitempty"`
	DeviceModelIsNil        bool     `json:"deviceModelIsNil,omitempty"`
	DeviceModelNotNil       bool     `json:"deviceModelNotNil,omitempty"`
	DeviceModelEqualFold    *string  `json:"deviceModelEqualFold,omitempty"`
	DeviceModelContainsFold *string  `json:"deviceModelContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserDeviceWhereInput) AddPredicates(predicates ...predicate.UserDevice) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserDeviceWhereInput filter on the UserDeviceQuery builder.
func (i *UserDeviceWhereInput) Filter(q *UserDeviceQuery) (*UserDeviceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserDeviceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserDeviceWhereInput is returned in case the UserDeviceWhereInput is empty.
var ErrEmptyUserDeviceWhereInput = errors.New("ent: empty predicate UserDeviceWhereInput")

// P returns a predicate for filtering userdevices.
// An error is returned if the input is empty or invalid.
func (i *UserDeviceWhereInput) P() (predicate.UserDevice, error) {
	var predicates []predicate.UserDevice
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userdevice.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserDevice, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userdevice.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserDevice, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userdevice.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userdevice.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userdevice.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userdevice.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userdevice.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userdevice.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userdevice.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userdevice.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userdevice.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, userdevice.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, userdevice.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, userdevice.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, userdevice.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, userdevice.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, userdevice.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, userdevice.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, userdevice.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userdevice.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userdevice.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userdevice.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userdevice.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userdevice.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userdevice.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userdevice.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userdevice.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, userdevice.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, userdevice.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, userdevice.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, userdevice.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, userdevice.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, userdevice.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, userdevice.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, userdevice.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, userdevice.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, userdevice.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userdevice.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userdevice.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userdevice.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userdevice.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userdevice.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userdevice.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userdevice.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userdevice.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, userdevice.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, userdevice.UpdatedAtNotNil())
	}
	if i.UserID != nil {
		predicates = append(predicates, userdevice.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userdevice.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userdevice.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userdevice.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, userdevice.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, userdevice.UserIDNotNil())
	}
	if i.DeviceUID != nil {
		predicates = append(predicates, userdevice.DeviceUIDEQ(*i.DeviceUID))
	}
	if i.DeviceUIDNEQ != nil {
		predicates = append(predicates, userdevice.DeviceUIDNEQ(*i.DeviceUIDNEQ))
	}
	if len(i.DeviceUIDIn) > 0 {
		predicates = append(predicates, userdevice.DeviceUIDIn(i.DeviceUIDIn...))
	}
	if len(i.DeviceUIDNotIn) > 0 {
		predicates = append(predicates, userdevice.DeviceUIDNotIn(i.DeviceUIDNotIn...))
	}
	if i.DeviceUIDGT != nil {
		predicates = append(predicates, userdevice.DeviceUIDGT(*i.DeviceUIDGT))
	}
	if i.DeviceUIDGTE != nil {
		predicates = append(predicates, userdevice.DeviceUIDGTE(*i.DeviceUIDGTE))
	}
	if i.DeviceUIDLT != nil {
		predicates = append(predicates, userdevice.DeviceUIDLT(*i.DeviceUIDLT))
	}
	if i.DeviceUIDLTE != nil {
		predicates = append(predicates, userdevice.DeviceUIDLTE(*i.DeviceUIDLTE))
	}
	if i.DeviceUIDContains != nil {
		predicates = append(predicates, userdevice.DeviceUIDContains(*i.DeviceUIDContains))
	}
	if i.DeviceUIDHasPrefix != nil {
		predicates = append(predicates, userdevice.DeviceUIDHasPrefix(*i.DeviceUIDHasPrefix))
	}
	if i.DeviceUIDHasSuffix != nil {
		predicates = append(predicates, userdevice.DeviceUIDHasSuffix(*i.DeviceUIDHasSuffix))
	}
	if i.DeviceUIDEqualFold != nil {
		predicates = append(predicates, userdevice.DeviceUIDEqualFold(*i.DeviceUIDEqualFold))
	}
	if i.DeviceUIDContainsFold != nil {
		predicates = append(predicates, userdevice.DeviceUIDContainsFold(*i.DeviceUIDContainsFold))
	}
	if i.DeviceName != nil {
		predicates = append(predicates, userdevice.DeviceNameEQ(*i.DeviceName))
	}
	if i.DeviceNameNEQ != nil {
		predicates = append(predicates, userdevice.DeviceNameNEQ(*i.DeviceNameNEQ))
	}
	if len(i.DeviceNameIn) > 0 {
		predicates = append(predicates, userdevice.DeviceNameIn(i.DeviceNameIn...))
	}
	if len(i.DeviceNameNotIn) > 0 {
		predicates = append(predicates, userdevice.DeviceNameNotIn(i.DeviceNameNotIn...))
	}
	if i.DeviceNameGT != nil {
		predicates = append(predicates, userdevice.DeviceNameGT(*i.DeviceNameGT))
	}
	if i.DeviceNameGTE != nil {
		predicates = append(predicates, userdevice.DeviceNameGTE(*i.DeviceNameGTE))
	}
	if i.DeviceNameLT != nil {
		predicates = append(predicates, userdevice.DeviceNameLT(*i.DeviceNameLT))
	}
	if i.DeviceNameLTE != nil {
		predicates = append(predicates, userdevice.DeviceNameLTE(*i.DeviceNameLTE))
	}
	if i.DeviceNameContains != nil {
		predicates = append(predicates, userdevice.DeviceNameContains(*i.DeviceNameContains))
	}
	if i.DeviceNameHasPrefix != nil {
		predicates = append(predicates, userdevice.DeviceNameHasPrefix(*i.DeviceNameHasPrefix))
	}
	if i.DeviceNameHasSuffix != nil {
		predicates = append(predicates, userdevice.DeviceNameHasSuffix(*i.DeviceNameHasSuffix))
	}
	if i.DeviceNameIsNil {
		predicates = append(predicates, userdevice.DeviceNameIsNil())
	}
	if i.DeviceNameNotNil {
		predicates = append(predicates, userdevice.DeviceNameNotNil())
	}
	if i.DeviceNameEqualFold != nil {
		predicates = append(predicates, userdevice.DeviceNameEqualFold(*i.DeviceNameEqualFold))
	}
	if i.DeviceNameContainsFold != nil {
		predicates = append(predicates, userdevice.DeviceNameContainsFold(*i.DeviceNameContainsFold))
	}
	if i.SystemName != nil {
		predicates = append(predicates, userdevice.SystemNameEQ(*i.SystemName))
	}
	if i.SystemNameNEQ != nil {
		predicates = append(predicates, userdevice.SystemNameNEQ(*i.SystemNameNEQ))
	}
	if len(i.SystemNameIn) > 0 {
		predicates = append(predicates, userdevice.SystemNameIn(i.SystemNameIn...))
	}
	if len(i.SystemNameNotIn) > 0 {
		predicates = append(predicates, userdevice.SystemNameNotIn(i.SystemNameNotIn...))
	}
	if i.SystemNameGT != nil {
		predicates = append(predicates, userdevice.SystemNameGT(*i.SystemNameGT))
	}
	if i.SystemNameGTE != nil {
		predicates = append(predicates, userdevice.SystemNameGTE(*i.SystemNameGTE))
	}
	if i.SystemNameLT != nil {
		predicates = append(predicates, userdevice.SystemNameLT(*i.SystemNameLT))
	}
	if i.SystemNameLTE != nil {
		predicates = append(predicates, userdevice.SystemNameLTE(*i.SystemNameLTE))
	}
	if i.SystemNameContains != nil {
		predicates = append(predicates, userdevice.SystemNameContains(*i.SystemNameContains))
	}
	if i.SystemNameHasPrefix != nil {
		predicates = append(predicates, userdevice.SystemNameHasPrefix(*i.SystemNameHasPrefix))
	}
	if i.SystemNameHasSuffix != nil {
		predicates = append(predicates, userdevice.SystemNameHasSuffix(*i.SystemNameHasSuffix))
	}
	if i.SystemNameIsNil {
		predicates = append(predicates, userdevice.SystemNameIsNil())
	}
	if i.SystemNameNotNil {
		predicates = append(predicates, userdevice.SystemNameNotNil())
	}
	if i.SystemNameEqualFold != nil {
		predicates = append(predicates, userdevice.SystemNameEqualFold(*i.SystemNameEqualFold))
	}
	if i.SystemNameContainsFold != nil {
		predicates = append(predicates, userdevice.SystemNameContainsFold(*i.SystemNameContainsFold))
	}
	if i.SystemVersion != nil {
		predicates = append(predicates, userdevice.SystemVersionEQ(*i.SystemVersion))
	}
	if i.SystemVersionNEQ != nil {
		predicates = append(predicates, userdevice.SystemVersionNEQ(*i.SystemVersionNEQ))
	}
	if len(i.SystemVersionIn) > 0 {
		predicates = append(predicates, userdevice.SystemVersionIn(i.SystemVersionIn...))
	}
	if len(i.SystemVersionNotIn) > 0 {
		predicates = append(predicates, userdevice.SystemVersionNotIn(i.SystemVersionNotIn...))
	}
	if i.SystemVersionGT != nil {
		predicates = append(predicates, userdevice.SystemVersionGT(*i.SystemVersionGT))
	}
	if i.SystemVersionGTE != nil {
		predicates = append(predicates, userdevice.SystemVersionGTE(*i.SystemVersionGTE))
	}
	if i.SystemVersionLT != nil {
		predicates = append(predicates, userdevice.SystemVersionLT(*i.SystemVersionLT))
	}
	if i.SystemVersionLTE != nil {
		predicates = append(predicates, userdevice.SystemVersionLTE(*i.SystemVersionLTE))
	}
	if i.SystemVersionContains != nil {
		predicates = append(predicates, userdevice.SystemVersionContains(*i.SystemVersionContains))
	}
	if i.SystemVersionHasPrefix != nil {
		predicates = append(predicates, userdevice.SystemVersionHasPrefix(*i.SystemVersionHasPrefix))
	}
	if i.SystemVersionHasSuffix != nil {
		predicates = append(predicates, userdevice.SystemVersionHasSuffix(*i.SystemVersionHasSuffix))
	}
	if i.SystemVersionIsNil {
		predicates = append(predicates, userdevice.SystemVersionIsNil())
	}
	if i.SystemVersionNotNil {
		predicates = append(predicates, userdevice.SystemVersionNotNil())
	}
	if i.SystemVersionEqualFold != nil {
		predicates = append(predicates, userdevice.SystemVersionEqualFold(*i.SystemVersionEqualFold))
	}
	if i.SystemVersionContainsFold != nil {
		predicates = append(predicates, userdevice.SystemVersionContainsFold(*i.SystemVersionContainsFold))
	}
	if i.AppVersion != nil {
		predicates = append(predicates, userdevice.AppVersionEQ(*i.AppVersion))
	}
	if i.AppVersionNEQ != nil {
		predicates = append(predicates, userdevice.AppVersionNEQ(*i.AppVersionNEQ))
	}
	if len(i.AppVersionIn) > 0 {
		predicates = append(predicates, userdevice.AppVersionIn(i.AppVersionIn...))
	}
	if len(i.AppVersionNotIn) > 0 {
		predicates = append(predicates, userdevice.AppVersionNotIn(i.AppVersionNotIn...))
	}
	if i.AppVersionGT != nil {
		predicates = append(predicates, userdevice.AppVersionGT(*i.AppVersionGT))
	}
	if i.AppVersionGTE != nil {
		predicates = append(predicates, userdevice.AppVersionGTE(*i.AppVersionGTE))
	}
	if i.AppVersionLT != nil {
		predicates = append(predicates, userdevice.AppVersionLT(*i.AppVersionLT))
	}
	if i.AppVersionLTE != nil {
		predicates = append(predicates, userdevice.AppVersionLTE(*i.AppVersionLTE))
	}
	if i.AppVersionContains != nil {
		predicates = append(predicates, userdevice.AppVersionContains(*i.AppVersionContains))
	}
	if i.AppVersionHasPrefix != nil {
		predicates = append(predicates, userdevice.AppVersionHasPrefix(*i.AppVersionHasPrefix))
	}
	if i.AppVersionHasSuffix != nil {
		predicates = append(predicates, userdevice.AppVersionHasSuffix(*i.AppVersionHasSuffix))
	}
	if i.AppVersionIsNil {
		predicates = append(predicates, userdevice.AppVersionIsNil())
	}
	if i.AppVersionNotNil {
		predicates = append(predicates, userdevice.AppVersionNotNil())
	}
	if i.AppVersionEqualFold != nil {
		predicates = append(predicates, userdevice.AppVersionEqualFold(*i.AppVersionEqualFold))
	}
	if i.AppVersionContainsFold != nil {
		predicates = append(predicates, userdevice.AppVersionContainsFold(*i.AppVersionContainsFold))
	}
	if i.DeviceModel != nil {
		predicates = append(predicates, userdevice.DeviceModelEQ(*i.DeviceModel))
	}
	if i.DeviceModelNEQ != nil {
		predicates = append(predicates, userdevice.DeviceModelNEQ(*i.DeviceModelNEQ))
	}
	if len(i.DeviceModelIn) > 0 {
		predicates = append(predicates, userdevice.DeviceModelIn(i.DeviceModelIn...))
	}
	if len(i.DeviceModelNotIn) > 0 {
		predicates = append(predicates, userdevice.DeviceModelNotIn(i.DeviceModelNotIn...))
	}
	if i.DeviceModelGT != nil {
		predicates = append(predicates, userdevice.DeviceModelGT(*i.DeviceModelGT))
	}
	if i.DeviceModelGTE != nil {
		predicates = append(predicates, userdevice.DeviceModelGTE(*i.DeviceModelGTE))
	}
	if i.DeviceModelLT != nil {
		predicates = append(predicates, userdevice.DeviceModelLT(*i.DeviceModelLT))
	}
	if i.DeviceModelLTE != nil {
		predicates = append(predicates, userdevice.DeviceModelLTE(*i.DeviceModelLTE))
	}
	if i.DeviceModelContains != nil {
		predicates = append(predicates, userdevice.DeviceModelContains(*i.DeviceModelContains))
	}
	if i.DeviceModelHasPrefix != nil {
		predicates = append(predicates, userdevice.DeviceModelHasPrefix(*i.DeviceModelHasPrefix))
	}
	if i.DeviceModelHasSuffix != nil {
		predicates = append(predicates, userdevice.DeviceModelHasSuffix(*i.DeviceModelHasSuffix))
	}
	if i.DeviceModelIsNil {
		predicates = append(predicates, userdevice.DeviceModelIsNil())
	}
	if i.DeviceModelNotNil {
		predicates = append(predicates, userdevice.DeviceModelNotNil())
	}
	if i.DeviceModelEqualFold != nil {
		predicates = append(predicates, userdevice.DeviceModelEqualFold(*i.DeviceModelEqualFold))
	}
	if i.DeviceModelContainsFold != nil {
		predicates = append(predicates, userdevice.DeviceModelContainsFold(*i.DeviceModelContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, userdevice.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, userdevice.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, userdevice.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, userdevice.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, userdevice.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, userdevice.StatusNotNil())
	}

	if i.HasUser != nil {
		p := userdevice.HasUser()
		if !*i.HasUser {
			p = userdevice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userdevice.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserDeviceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userdevice.And(predicates...), nil
	}
}

// UserIdentityWhereInput represents a where input for filtering UserIdentity queries.
type UserIdentityWhereInput struct {
	Predicates []predicate.UserIdentity  `json:"-"`
	Not        *UserIdentityWhereInput   `json:"not,omitempty"`
	Or         []*UserIdentityWhereInput `json:"or,omitempty"`
	And        []*UserIdentityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "kind" field predicates.
	Kind      *useridentity.Kind  `json:"kind,omitempty"`
	KindNEQ   *useridentity.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []useridentity.Kind `json:"kindIn,omitempty"`
	KindNotIn []useridentity.Kind `json:"kindNotIn,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeIsNil        bool     `json:"codeIsNil,omitempty"`
	CodeNotNil       bool     `json:"codeNotNil,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "code_extend" field predicates.
	CodeExtend             *string  `json:"codeExtend,omitempty"`
	CodeExtendNEQ          *string  `json:"codeExtendNEQ,omitempty"`
	CodeExtendIn           []string `json:"codeExtendIn,omitempty"`
	CodeExtendNotIn        []string `json:"codeExtendNotIn,omitempty"`
	CodeExtendGT           *string  `json:"codeExtendGT,omitempty"`
	CodeExtendGTE          *string  `json:"codeExtendGTE,omitempty"`
	CodeExtendLT           *string  `json:"codeExtendLT,omitempty"`
	CodeExtendLTE          *string  `json:"codeExtendLTE,omitempty"`
	CodeExtendContains     *string  `json:"codeExtendContains,omitempty"`
	CodeExtendHasPrefix    *string  `json:"codeExtendHasPrefix,omitempty"`
	CodeExtendHasSuffix    *string  `json:"codeExtendHasSuffix,omitempty"`
	CodeExtendIsNil        bool     `json:"codeExtendIsNil,omitempty"`
	CodeExtendNotNil       bool     `json:"codeExtendNotNil,omitempty"`
	CodeExtendEqualFold    *string  `json:"codeExtendEqualFold,omitempty"`
	CodeExtendContainsFold *string  `json:"codeExtendContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserIdentityWhereInput) AddPredicates(predicates ...predicate.UserIdentity) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserIdentityWhereInput filter on the UserIdentityQuery builder.
func (i *UserIdentityWhereInput) Filter(q *UserIdentityQuery) (*UserIdentityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserIdentityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserIdentityWhereInput is returned in case the UserIdentityWhereInput is empty.
var ErrEmptyUserIdentityWhereInput = errors.New("ent: empty predicate UserIdentityWhereInput")

// P returns a predicate for filtering useridentities.
// An error is returned if the input is empty or invalid.
func (i *UserIdentityWhereInput) P() (predicate.UserIdentity, error) {
	var predicates []predicate.UserIdentity
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, useridentity.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserIdentity, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, useridentity.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserIdentity, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, useridentity.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, useridentity.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, useridentity.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, useridentity.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, useridentity.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, useridentity.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, useridentity.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, useridentity.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, useridentity.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, useridentity.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, useridentity.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, useridentity.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, useridentity.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, useridentity.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, useridentity.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, useridentity.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, useridentity.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, useridentity.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, useridentity.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, useridentity.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, useridentity.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, useridentity.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, useridentity.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, useridentity.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, useridentity.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, useridentity.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, useridentity.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, useridentity.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, useridentity.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, useridentity.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, useridentity.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, useridentity.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, useridentity.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, useridentity.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, useridentity.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, useridentity.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, useridentity.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, useridentity.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, useridentity.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, useridentity.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, useridentity.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, useridentity.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, useridentity.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, useridentity.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, useridentity.UpdatedAtNotNil())
	}
	if i.UserID != nil {
		predicates = append(predicates, useridentity.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, useridentity.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, useridentity.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, useridentity.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, useridentity.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, useridentity.UserIDNotNil())
	}
	if i.Kind != nil {
		predicates = append(predicates, useridentity.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, useridentity.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, useridentity.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, useridentity.KindNotIn(i.KindNotIn...))
	}
	if i.Code != nil {
		predicates = append(predicates, useridentity.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, useridentity.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, useridentity.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, useridentity.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, useridentity.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, useridentity.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, useridentity.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, useridentity.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, useridentity.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, useridentity.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, useridentity.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeIsNil {
		predicates = append(predicates, useridentity.CodeIsNil())
	}
	if i.CodeNotNil {
		predicates = append(predicates, useridentity.CodeNotNil())
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, useridentity.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, useridentity.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.CodeExtend != nil {
		predicates = append(predicates, useridentity.CodeExtendEQ(*i.CodeExtend))
	}
	if i.CodeExtendNEQ != nil {
		predicates = append(predicates, useridentity.CodeExtendNEQ(*i.CodeExtendNEQ))
	}
	if len(i.CodeExtendIn) > 0 {
		predicates = append(predicates, useridentity.CodeExtendIn(i.CodeExtendIn...))
	}
	if len(i.CodeExtendNotIn) > 0 {
		predicates = append(predicates, useridentity.CodeExtendNotIn(i.CodeExtendNotIn...))
	}
	if i.CodeExtendGT != nil {
		predicates = append(predicates, useridentity.CodeExtendGT(*i.CodeExtendGT))
	}
	if i.CodeExtendGTE != nil {
		predicates = append(predicates, useridentity.CodeExtendGTE(*i.CodeExtendGTE))
	}
	if i.CodeExtendLT != nil {
		predicates = append(predicates, useridentity.CodeExtendLT(*i.CodeExtendLT))
	}
	if i.CodeExtendLTE != nil {
		predicates = append(predicates, useridentity.CodeExtendLTE(*i.CodeExtendLTE))
	}
	if i.CodeExtendContains != nil {
		predicates = append(predicates, useridentity.CodeExtendContains(*i.CodeExtendContains))
	}
	if i.CodeExtendHasPrefix != nil {
		predicates = append(predicates, useridentity.CodeExtendHasPrefix(*i.CodeExtendHasPrefix))
	}
	if i.CodeExtendHasSuffix != nil {
		predicates = append(predicates, useridentity.CodeExtendHasSuffix(*i.CodeExtendHasSuffix))
	}
	if i.CodeExtendIsNil {
		predicates = append(predicates, useridentity.CodeExtendIsNil())
	}
	if i.CodeExtendNotNil {
		predicates = append(predicates, useridentity.CodeExtendNotNil())
	}
	if i.CodeExtendEqualFold != nil {
		predicates = append(predicates, useridentity.CodeExtendEqualFold(*i.CodeExtendEqualFold))
	}
	if i.CodeExtendContainsFold != nil {
		predicates = append(predicates, useridentity.CodeExtendContainsFold(*i.CodeExtendContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, useridentity.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, useridentity.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, useridentity.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, useridentity.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, useridentity.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, useridentity.StatusNotNil())
	}

	if i.HasUser != nil {
		p := useridentity.HasUser()
		if !*i.HasUser {
			p = useridentity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, useridentity.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserIdentityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return useridentity.And(predicates...), nil
	}
}

// UserLoginProfileWhereInput represents a where input for filtering UserLoginProfile queries.
type UserLoginProfileWhereInput struct {
	Predicates []predicate.UserLoginProfile  `json:"-"`
	Not        *UserLoginProfileWhereInput   `json:"not,omitempty"`
	Or         []*UserLoginProfileWhereInput `json:"or,omitempty"`
	And        []*UserLoginProfileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "can_login" field predicates.
	CanLogin       *bool `json:"canLogin,omitempty"`
	CanLoginNEQ    *bool `json:"canLoginNEQ,omitempty"`
	CanLoginIsNil  bool  `json:"canLoginIsNil,omitempty"`
	CanLoginNotNil bool  `json:"canLoginNotNil,omitempty"`

	// "set_kind" field predicates.
	SetKind      *userloginprofile.SetKind  `json:"setKind,omitempty"`
	SetKindNEQ   *userloginprofile.SetKind  `json:"setKindNEQ,omitempty"`
	SetKindIn    []userloginprofile.SetKind `json:"setKindIn,omitempty"`
	SetKindNotIn []userloginprofile.SetKind `json:"setKindNotIn,omitempty"`

	// "password_reset" field predicates.
	PasswordReset       *bool `json:"passwordReset,omitempty"`
	PasswordResetNEQ    *bool `json:"passwordResetNEQ,omitempty"`
	PasswordResetIsNil  bool  `json:"passwordResetIsNil,omitempty"`
	PasswordResetNotNil bool  `json:"passwordResetNotNil,omitempty"`

	// "verify_device" field predicates.
	VerifyDevice    *bool `json:"verifyDevice,omitempty"`
	VerifyDeviceNEQ *bool `json:"verifyDeviceNEQ,omitempty"`

	// "mfa_enabled" field predicates.
	MfaEnabled       *bool `json:"mfaEnabled,omitempty"`
	MfaEnabledNEQ    *bool `json:"mfaEnabledNEQ,omitempty"`
	MfaEnabledIsNil  bool  `json:"mfaEnabledIsNil,omitempty"`
	MfaEnabledNotNil bool  `json:"mfaEnabledNotNil,omitempty"`

	// "mfa_secret" field predicates.
	MfaSecret             *string  `json:"mfaSecret,omitempty"`
	MfaSecretNEQ          *string  `json:"mfaSecretNEQ,omitempty"`
	MfaSecretIn           []string `json:"mfaSecretIn,omitempty"`
	MfaSecretNotIn        []string `json:"mfaSecretNotIn,omitempty"`
	MfaSecretGT           *string  `json:"mfaSecretGT,omitempty"`
	MfaSecretGTE          *string  `json:"mfaSecretGTE,omitempty"`
	MfaSecretLT           *string  `json:"mfaSecretLT,omitempty"`
	MfaSecretLTE          *string  `json:"mfaSecretLTE,omitempty"`
	MfaSecretContains     *string  `json:"mfaSecretContains,omitempty"`
	MfaSecretHasPrefix    *string  `json:"mfaSecretHasPrefix,omitempty"`
	MfaSecretHasSuffix    *string  `json:"mfaSecretHasSuffix,omitempty"`
	MfaSecretIsNil        bool     `json:"mfaSecretIsNil,omitempty"`
	MfaSecretNotNil       bool     `json:"mfaSecretNotNil,omitempty"`
	MfaSecretEqualFold    *string  `json:"mfaSecretEqualFold,omitempty"`
	MfaSecretContainsFold *string  `json:"mfaSecretContainsFold,omitempty"`

	// "mfa_status" field predicates.
	MfaStatus       *typex.SimpleStatus  `json:"mfaStatus,omitempty"`
	MfaStatusNEQ    *typex.SimpleStatus  `json:"mfaStatusNEQ,omitempty"`
	MfaStatusIn     []typex.SimpleStatus `json:"mfaStatusIn,omitempty"`
	MfaStatusNotIn  []typex.SimpleStatus `json:"mfaStatusNotIn,omitempty"`
	MfaStatusIsNil  bool                 `json:"mfaStatusIsNil,omitempty"`
	MfaStatusNotNil bool                 `json:"mfaStatusNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserLoginProfileWhereInput) AddPredicates(predicates ...predicate.UserLoginProfile) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserLoginProfileWhereInput filter on the UserLoginProfileQuery builder.
func (i *UserLoginProfileWhereInput) Filter(q *UserLoginProfileQuery) (*UserLoginProfileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserLoginProfileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserLoginProfileWhereInput is returned in case the UserLoginProfileWhereInput is empty.
var ErrEmptyUserLoginProfileWhereInput = errors.New("ent: empty predicate UserLoginProfileWhereInput")

// P returns a predicate for filtering userloginprofiles.
// An error is returned if the input is empty or invalid.
func (i *UserLoginProfileWhereInput) P() (predicate.UserLoginProfile, error) {
	var predicates []predicate.UserLoginProfile
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userloginprofile.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserLoginProfile, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userloginprofile.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserLoginProfile, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userloginprofile.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userloginprofile.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userloginprofile.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userloginprofile.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userloginprofile.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userloginprofile.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userloginprofile.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userloginprofile.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userloginprofile.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, userloginprofile.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, userloginprofile.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, userloginprofile.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, userloginprofile.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, userloginprofile.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, userloginprofile.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, userloginprofile.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, userloginprofile.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userloginprofile.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userloginprofile.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userloginprofile.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userloginprofile.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userloginprofile.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userloginprofile.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userloginprofile.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userloginprofile.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, userloginprofile.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, userloginprofile.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, userloginprofile.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, userloginprofile.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, userloginprofile.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, userloginprofile.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, userloginprofile.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, userloginprofile.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, userloginprofile.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, userloginprofile.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userloginprofile.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userloginprofile.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userloginprofile.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, userloginprofile.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, userloginprofile.UpdatedAtNotNil())
	}
	if i.UserID != nil {
		predicates = append(predicates, userloginprofile.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userloginprofile.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userloginprofile.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userloginprofile.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, userloginprofile.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, userloginprofile.UserIDNotNil())
	}
	if i.CanLogin != nil {
		predicates = append(predicates, userloginprofile.CanLoginEQ(*i.CanLogin))
	}
	if i.CanLoginNEQ != nil {
		predicates = append(predicates, userloginprofile.CanLoginNEQ(*i.CanLoginNEQ))
	}
	if i.CanLoginIsNil {
		predicates = append(predicates, userloginprofile.CanLoginIsNil())
	}
	if i.CanLoginNotNil {
		predicates = append(predicates, userloginprofile.CanLoginNotNil())
	}
	if i.SetKind != nil {
		predicates = append(predicates, userloginprofile.SetKindEQ(*i.SetKind))
	}
	if i.SetKindNEQ != nil {
		predicates = append(predicates, userloginprofile.SetKindNEQ(*i.SetKindNEQ))
	}
	if len(i.SetKindIn) > 0 {
		predicates = append(predicates, userloginprofile.SetKindIn(i.SetKindIn...))
	}
	if len(i.SetKindNotIn) > 0 {
		predicates = append(predicates, userloginprofile.SetKindNotIn(i.SetKindNotIn...))
	}
	if i.PasswordReset != nil {
		predicates = append(predicates, userloginprofile.PasswordResetEQ(*i.PasswordReset))
	}
	if i.PasswordResetNEQ != nil {
		predicates = append(predicates, userloginprofile.PasswordResetNEQ(*i.PasswordResetNEQ))
	}
	if i.PasswordResetIsNil {
		predicates = append(predicates, userloginprofile.PasswordResetIsNil())
	}
	if i.PasswordResetNotNil {
		predicates = append(predicates, userloginprofile.PasswordResetNotNil())
	}
	if i.VerifyDevice != nil {
		predicates = append(predicates, userloginprofile.VerifyDeviceEQ(*i.VerifyDevice))
	}
	if i.VerifyDeviceNEQ != nil {
		predicates = append(predicates, userloginprofile.VerifyDeviceNEQ(*i.VerifyDeviceNEQ))
	}
	if i.MfaEnabled != nil {
		predicates = append(predicates, userloginprofile.MfaEnabledEQ(*i.MfaEnabled))
	}
	if i.MfaEnabledNEQ != nil {
		predicates = append(predicates, userloginprofile.MfaEnabledNEQ(*i.MfaEnabledNEQ))
	}
	if i.MfaEnabledIsNil {
		predicates = append(predicates, userloginprofile.MfaEnabledIsNil())
	}
	if i.MfaEnabledNotNil {
		predicates = append(predicates, userloginprofile.MfaEnabledNotNil())
	}
	if i.MfaSecret != nil {
		predicates = append(predicates, userloginprofile.MfaSecretEQ(*i.MfaSecret))
	}
	if i.MfaSecretNEQ != nil {
		predicates = append(predicates, userloginprofile.MfaSecretNEQ(*i.MfaSecretNEQ))
	}
	if len(i.MfaSecretIn) > 0 {
		predicates = append(predicates, userloginprofile.MfaSecretIn(i.MfaSecretIn...))
	}
	if len(i.MfaSecretNotIn) > 0 {
		predicates = append(predicates, userloginprofile.MfaSecretNotIn(i.MfaSecretNotIn...))
	}
	if i.MfaSecretGT != nil {
		predicates = append(predicates, userloginprofile.MfaSecretGT(*i.MfaSecretGT))
	}
	if i.MfaSecretGTE != nil {
		predicates = append(predicates, userloginprofile.MfaSecretGTE(*i.MfaSecretGTE))
	}
	if i.MfaSecretLT != nil {
		predicates = append(predicates, userloginprofile.MfaSecretLT(*i.MfaSecretLT))
	}
	if i.MfaSecretLTE != nil {
		predicates = append(predicates, userloginprofile.MfaSecretLTE(*i.MfaSecretLTE))
	}
	if i.MfaSecretContains != nil {
		predicates = append(predicates, userloginprofile.MfaSecretContains(*i.MfaSecretContains))
	}
	if i.MfaSecretHasPrefix != nil {
		predicates = append(predicates, userloginprofile.MfaSecretHasPrefix(*i.MfaSecretHasPrefix))
	}
	if i.MfaSecretHasSuffix != nil {
		predicates = append(predicates, userloginprofile.MfaSecretHasSuffix(*i.MfaSecretHasSuffix))
	}
	if i.MfaSecretIsNil {
		predicates = append(predicates, userloginprofile.MfaSecretIsNil())
	}
	if i.MfaSecretNotNil {
		predicates = append(predicates, userloginprofile.MfaSecretNotNil())
	}
	if i.MfaSecretEqualFold != nil {
		predicates = append(predicates, userloginprofile.MfaSecretEqualFold(*i.MfaSecretEqualFold))
	}
	if i.MfaSecretContainsFold != nil {
		predicates = append(predicates, userloginprofile.MfaSecretContainsFold(*i.MfaSecretContainsFold))
	}
	if i.MfaStatus != nil {
		predicates = append(predicates, userloginprofile.MfaStatusEQ(*i.MfaStatus))
	}
	if i.MfaStatusNEQ != nil {
		predicates = append(predicates, userloginprofile.MfaStatusNEQ(*i.MfaStatusNEQ))
	}
	if len(i.MfaStatusIn) > 0 {
		predicates = append(predicates, userloginprofile.MfaStatusIn(i.MfaStatusIn...))
	}
	if len(i.MfaStatusNotIn) > 0 {
		predicates = append(predicates, userloginprofile.MfaStatusNotIn(i.MfaStatusNotIn...))
	}
	if i.MfaStatusIsNil {
		predicates = append(predicates, userloginprofile.MfaStatusIsNil())
	}
	if i.MfaStatusNotNil {
		predicates = append(predicates, userloginprofile.MfaStatusNotNil())
	}

	if i.HasUser != nil {
		p := userloginprofile.HasUser()
		if !*i.HasUser {
			p = userloginprofile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userloginprofile.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserLoginProfileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userloginprofile.And(predicates...), nil
	}
}

// UserPasswordWhereInput represents a where input for filtering UserPassword queries.
type UserPasswordWhereInput struct {
	Predicates []predicate.UserPassword  `json:"-"`
	Not        *UserPasswordWhereInput   `json:"not,omitempty"`
	Or         []*UserPasswordWhereInput `json:"or,omitempty"`
	And        []*UserPasswordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "scene" field predicates.
	Scene      *userpassword.Scene  `json:"scene,omitempty"`
	SceneNEQ   *userpassword.Scene  `json:"sceneNEQ,omitempty"`
	SceneIn    []userpassword.Scene `json:"sceneIn,omitempty"`
	SceneNotIn []userpassword.Scene `json:"sceneNotIn,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "status" field predicates.
	Status       *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ    *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn     []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn  []typex.SimpleStatus `json:"statusNotIn,omitempty"`
	StatusIsNil  bool                 `json:"statusIsNil,omitempty"`
	StatusNotNil bool                 `json:"statusNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserPasswordWhereInput) AddPredicates(predicates ...predicate.UserPassword) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserPasswordWhereInput filter on the UserPasswordQuery builder.
func (i *UserPasswordWhereInput) Filter(q *UserPasswordQuery) (*UserPasswordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserPasswordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserPasswordWhereInput is returned in case the UserPasswordWhereInput is empty.
var ErrEmptyUserPasswordWhereInput = errors.New("ent: empty predicate UserPasswordWhereInput")

// P returns a predicate for filtering userpasswords.
// An error is returned if the input is empty or invalid.
func (i *UserPasswordWhereInput) P() (predicate.UserPassword, error) {
	var predicates []predicate.UserPassword
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userpassword.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserPassword, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userpassword.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserPassword, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userpassword.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userpassword.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userpassword.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userpassword.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userpassword.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userpassword.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userpassword.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userpassword.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userpassword.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, userpassword.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, userpassword.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, userpassword.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, userpassword.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, userpassword.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, userpassword.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, userpassword.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, userpassword.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userpassword.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userpassword.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userpassword.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userpassword.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userpassword.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userpassword.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userpassword.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userpassword.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, userpassword.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, userpassword.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, userpassword.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, userpassword.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, userpassword.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, userpassword.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, userpassword.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, userpassword.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, userpassword.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, userpassword.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, userpassword.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, userpassword.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, userpassword.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, userpassword.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, userpassword.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, userpassword.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, userpassword.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, userpassword.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, userpassword.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, userpassword.UpdatedAtNotNil())
	}
	if i.UserID != nil {
		predicates = append(predicates, userpassword.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, userpassword.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, userpassword.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, userpassword.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, userpassword.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, userpassword.UserIDNotNil())
	}
	if i.Scene != nil {
		predicates = append(predicates, userpassword.SceneEQ(*i.Scene))
	}
	if i.SceneNEQ != nil {
		predicates = append(predicates, userpassword.SceneNEQ(*i.SceneNEQ))
	}
	if len(i.SceneIn) > 0 {
		predicates = append(predicates, userpassword.SceneIn(i.SceneIn...))
	}
	if len(i.SceneNotIn) > 0 {
		predicates = append(predicates, userpassword.SceneNotIn(i.SceneNotIn...))
	}
	if i.Password != nil {
		predicates = append(predicates, userpassword.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, userpassword.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, userpassword.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, userpassword.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, userpassword.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, userpassword.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, userpassword.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, userpassword.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, userpassword.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, userpassword.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, userpassword.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, userpassword.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, userpassword.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, userpassword.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, userpassword.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, userpassword.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, userpassword.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, userpassword.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, userpassword.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusIsNil {
		predicates = append(predicates, userpassword.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, userpassword.StatusNotNil())
	}

	if i.HasUser != nil {
		p := userpassword.HasUser()
		if !*i.HasUser {
			p = userpassword.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userpassword.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserPasswordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userpassword.And(predicates...), nil
	}
}
