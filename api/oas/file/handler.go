// Code generated by woco, DO NOT EDIT.

package file

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/tsingsun/woocoo/web/handler"
)

// RegisterFileHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterFileHandlers(router *gin.RouterGroup, si FileServer) {
	router.DELETE("/files/:fileId", wrapDeleteFile(si))
	router.GET("/files/:fileId", wrapGetFile(si))
	router.GET("/files/:fileId/raw", wrapGetFileRaw(si))
	router.POST("/files/report-ref-count", wrapReportRefCount(si))
	router.POST("/files", wrapUploadFile(si))
	router.POST("/files/upload-info", wrapUploadFileInfo(si))
}

func wrapDeleteFile(si FileServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req DeleteFileRequest
		if err := c.ShouldBindUri(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		err := si.DeleteFile(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
	}
}

func wrapGetFile(si FileServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req GetFileRequest
		if err := c.ShouldBindUri(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetFile(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapGetFileRaw(si FileServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req GetFileRawRequest
		if err := c.ShouldBindUri(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.GetFileRaw(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		c.Data(http.StatusOK, "application/octet-stream", resp)
	}
}

func wrapReportRefCount(si FileServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req ReportRefCountRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.ReportRefCount(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapUploadFile(si FileServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req UploadFileRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.UploadFile(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}

func wrapUploadFileInfo(si FileServer) func(c *gin.Context) {
	return func(c *gin.Context) {
		var req UploadFileInfoRequest
		if err := c.ShouldBind(&req); err != nil {
			handler.AbortWithError(c, http.StatusBadRequest, err)
			return
		}
		resp, err := si.UploadFileInfo(c, &req)
		if err != nil {
			c.Error(err)
			return
		}
		handler.NegotiateResponse(c, http.StatusOK, resp, []string{"application/json"})
	}
}
